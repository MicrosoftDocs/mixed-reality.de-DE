---
title: Räumliche Zuordnung
description: Räumliche Zuordnung bietet eine detaillierte Darstellung der echten Oberflächen in der Umgebung für die HoloLens.
author: mattzmsft
ms.author: mazeller
ms.date: 03/21/2018
ms.topic: article
keywords: räumliche Zuordnung, HoloLens, mixed Reality, Surface Wiederaufbau, Netz, sr
ms.openlocfilehash: 31abeca624512f1d5e721dbe879ca2243cf41345
ms.sourcegitcommit: 384b0087899cd835a3a965f75c6f6c607c9edd1b
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 04/12/2019
ms.locfileid: "59605044"
---
# <a name="spatial-mapping"></a><span data-ttu-id="01867-104">Räumliche Zuordnung</span><span class="sxs-lookup"><span data-stu-id="01867-104">Spatial mapping</span></span>

<span data-ttu-id="01867-105">Räumliche Zuordnung bietet eine detaillierte Darstellung der echten Oberflächen in der Umgebung für die HoloLens, ermöglicht Entwicklern das Erstellen einer überzeugenden mixed Reality-Erfahrung.</span><span class="sxs-lookup"><span data-stu-id="01867-105">Spatial mapping provides a detailed representation of real-world surfaces in the environment around the HoloLens, allowing developers to create a convincing mixed reality experience.</span></span> <span data-ttu-id="01867-106">Durch das Zusammenführen der realen Welt mit der virtuellen Welt, kann eine Anwendung Hologramme echte scheinen vornehmen.</span><span class="sxs-lookup"><span data-stu-id="01867-106">By merging the real world with the virtual world, an application can make holograms seem real.</span></span> <span data-ttu-id="01867-107">Durch die Bereitstellung vertraut realen Verhaltensweisen und Interaktionen können ein Anwendungen Erwartungen der Benutzer auch alternative besser ausrichten.</span><span class="sxs-lookup"><span data-stu-id="01867-107">Applications can also more naturally align with user expectations by providing familiar real-world behaviors and interactions.</span></span>

<br>

>[!VIDEO https://www.youtube.com/embed/zff2aQ1RaVo]

## <a name="device-support"></a><span data-ttu-id="01867-108">Unterstützung von Geräten</span><span class="sxs-lookup"><span data-stu-id="01867-108">Device support</span></span>

<table>
<tr>
<th><span data-ttu-id="01867-109">Feature</span><span class="sxs-lookup"><span data-stu-id="01867-109">Feature</span></span></th><th style="width:150px"> <span data-ttu-id="01867-110"><a href="hololens-hardware-details.md">HoloLens (1. Generation)</a></span><span class="sxs-lookup"><span data-stu-id="01867-110"><a href="hololens-hardware-details.md">HoloLens (1st gen)</a></span></span></th><th style="width:150px"><span data-ttu-id="01867-111">HoloLens 2</span><span class="sxs-lookup"><span data-stu-id="01867-111">HoloLens 2</span></span></th><th style="width:150px"> <span data-ttu-id="01867-112"><a href="immersive-headset-hardware-details.md">Immersive headsets</a></span><span class="sxs-lookup"><span data-stu-id="01867-112"><a href="immersive-headset-hardware-details.md">Immersive headsets</a></span></span></th>
</tr><tr>
<td> <span data-ttu-id="01867-113">Räumliche Zuordnung</span><span class="sxs-lookup"><span data-stu-id="01867-113">Spatial mapping</span></span></td><td style="text-align: center;"> <span data-ttu-id="01867-114">✔️</span><span class="sxs-lookup"><span data-stu-id="01867-114">✔️</span></span></td><td style="text-align: center;"> <span data-ttu-id="01867-115">✔️</span><span class="sxs-lookup"><span data-stu-id="01867-115">✔️</span></span></td><td style="text-align: center;"></td>
</tr>
</table>



## <a name="conceptual-overview"></a><span data-ttu-id="01867-116">Konzeptionelle Übersicht</span><span class="sxs-lookup"><span data-stu-id="01867-116">Conceptual overview</span></span>

<span data-ttu-id="01867-117">![Mesh-Oberflächen, die für einen Raum](images/SurfaceReconstruction.jpg)</span><span class="sxs-lookup"><span data-stu-id="01867-117">![Mesh surfaces covering a room](images/SurfaceReconstruction.jpg)</span></span><br>
<span data-ttu-id="01867-118">*Ein Beispiel für eine räumliche Zuordnung Mesh deckt einen Raum*</span><span class="sxs-lookup"><span data-stu-id="01867-118">*An example of a spatial mapping mesh covering a room*</span></span>

<span data-ttu-id="01867-119">Die zwei primären Objekttypen, für die räumliche Zuordnung verwendet werden "Räumlichen Oberfläche Observer" und der 'räumliche Fläche".</span><span class="sxs-lookup"><span data-stu-id="01867-119">The two primary object types used for spatial mapping are the 'Spatial Surface Observer' and the 'Spatial Surface'.</span></span>

<span data-ttu-id="01867-120">Die Anwendung bietet dem räumliche Oberfläche Beobachter ein oder mehrere Volumes umgebende, um die Regionen des Speicherplatzes zu definieren, in dem die Anwendung die räumliche Zuordnungsdaten empfangen möchte.</span><span class="sxs-lookup"><span data-stu-id="01867-120">The application provides the Spatial Surface Observer with one or more bounding volumes, to define the regions of space in which the application wishes to receive spatial mapping data.</span></span> <span data-ttu-id="01867-121">Für die einzelnen Volumes stellt die räumliche Zuordnung die Anwendung mit einem Satz von räumlichen Oberflächen bereit.</span><span class="sxs-lookup"><span data-stu-id="01867-121">For each of these volumes, spatial mapping will provide the application with a set of Spatial Surfaces.</span></span>

<span data-ttu-id="01867-122">Diese Volumes (in einer festen Position in Bezug auf die reale Welt) nicht bewegt werden können oder sie die HoloLens (sie verschieben, aber nicht drehen, mit der HoloLens Fortschreiten über die Umgebung) angefügt werden.</span><span class="sxs-lookup"><span data-stu-id="01867-122">These volumes may be stationary (in a fixed location with respect to the real world) or they may be attached to the HoloLens (they move, but do not rotate, with the HoloLens as it moves through the environment).</span></span> <span data-ttu-id="01867-123">Jeder räumliche Fläche wird beschrieben, reale Flächen in einer kleinen Anzahl von Leerzeichen, dargestellt als ein Dreieckgitter angefügt wird, ein World gesperrt [räumliche Koordinatensystem](coordinate-systems.md).</span><span class="sxs-lookup"><span data-stu-id="01867-123">Each spatial surface describes real-world surfaces in a small volume of space, represented as a triangle mesh attached to a world-locked [spatial coordinate system](coordinate-systems.md).</span></span>

<span data-ttu-id="01867-124">Neue Daten über die Umgebung erfasst, die HoloLens, und beim Auftreten von Änderungen in der Umgebung werden räumliche Flächen angezeigt, nicht mehr angezeigt, und ändern.</span><span class="sxs-lookup"><span data-stu-id="01867-124">As the HoloLens gathers new data about the environment, and as changes to the environment occur, spatial surfaces will appear, disappear and change.</span></span>

## <a name="common-usage-scenarios"></a><span data-ttu-id="01867-125">Allgemeine Verwendungsszenarien</span><span class="sxs-lookup"><span data-stu-id="01867-125">Common usage scenarios</span></span>

![Abbildungen der allgemeine Verwendungsszenarien räumliche Zuordnung: Ablage "," verdecken "," Physik "und" Navigation](images/sm-concepts-1000px.png)

### <a name="placement"></a><span data-ttu-id="01867-127">Platzierung</span><span class="sxs-lookup"><span data-stu-id="01867-127">Placement</span></span>

<span data-ttu-id="01867-128">Räumliche Zuordnung bietet Anwendungen die Möglichkeit bieten, natürliche und vertraute Formen der Interaktion des Benutzers; Was ist möglicherweise natürlicher wirkt als das Platzieren von Ihrem Telefons nach unten auf dem Schreibtisch?</span><span class="sxs-lookup"><span data-stu-id="01867-128">Spatial mapping provides applications with the opportunity to present natural and familiar forms of interaction to the user; what could be more natural than placing your phone down on the desk?</span></span>

<span data-ttu-id="01867-129">Die Platzierung von Hologramme einschränken (oder üblicher, einer beliebigen Auswahl von räumlichen Standorten), liegen auf Oberflächen bietet eine natürliche Zuordnung von 3D (Punkt im Raum) bis 2D (zeigen Sie auf der Oberfläche).</span><span class="sxs-lookup"><span data-stu-id="01867-129">Constraining the placement of holograms (or more generally, any selection of spatial locations) to lie on surfaces provides a natural mapping from 3D (point in space) to 2D (point on surface).</span></span> <span data-ttu-id="01867-130">Dies reduziert die Menge an Informationen, die der Benutzer muss für die Anwendung bereitstellen, und deshalb gibt es die Interaktionen des Benutzers schneller, einfacher und präziser.</span><span class="sxs-lookup"><span data-stu-id="01867-130">This reduces the amount of information the user needs to provide to the application and thus makes the user's interactions faster, easier and more precise.</span></span> <span data-ttu-id="01867-131">Dies gilt besonders, da'sofort distance' ist nicht etwas, das wir verwendet werden, für andere Benutzer oder Computer physisch zu kommunizieren.</span><span class="sxs-lookup"><span data-stu-id="01867-131">This is particularly true because 'distance away' is not something that we are used to physically communicating to other people or to computers.</span></span> <span data-ttu-id="01867-132">Wenn wir mit unseren Finger zeigen, werden wir eine Richtung, aber nicht mit einer Entfernung angeben.</span><span class="sxs-lookup"><span data-stu-id="01867-132">When we point with our finger, we are specifying a direction but not a distance.</span></span>

<span data-ttu-id="01867-133">Ein wichtiger Vorsichtshinweis ist, die, wenn eine Anwendung die Entfernung von der Richtung ableitet (z. B. durch Ausführen einer Raycast des Benutzers Blicke Richtung des nächsten finden räumliche Oberfläche), dies muss Ergebnisse liefern, die der Benutzer zuverlässig einschätzen kann.</span><span class="sxs-lookup"><span data-stu-id="01867-133">An important caveat here is that when an application infers distance from direction (for example by performing a raycast along the user's gaze direction to find the nearest spatial surface), this must yield results that the user is able to reliably predict.</span></span> <span data-ttu-id="01867-134">Andernfalls verliert der Benutzer deren Sinn des Steuerelements, und dies kann schnell frustrierend werden.</span><span class="sxs-lookup"><span data-stu-id="01867-134">Otherwise, the user will lose their sense of control and this can quickly become frustrating.</span></span> <span data-ttu-id="01867-135">Eine Methode, die dabei hilft, ist zum Ausführen von mehreren Raycasts anstelle nur eines.</span><span class="sxs-lookup"><span data-stu-id="01867-135">One method that helps with this is to perform multiple raycasts instead of just one.</span></span> <span data-ttu-id="01867-136">Reibungslose und besser vorhersagbare, weniger anfällig für aus vorübergehenden "Ausreißer" Ergebnissen beeinflussen (wie durch Strahlung kleine Lücken übergeben, oder drücken kleine Teile der Geometrie an, die der Benutzer nicht bekannt ist verursacht werden kann), sollte die aggregierten Ergebnisse sein.</span><span class="sxs-lookup"><span data-stu-id="01867-136">The aggregate results should be smoother and more predictable, less susceptible to influence from transient 'outlier' results (as can be caused by rays passing through tiny holes or hitting small bits of geometry that the user is not aware of).</span></span> <span data-ttu-id="01867-137">Aggregierung oder Glättung kann auch im Laufe der Zeit ausgeführt werden; Beispielsweise können Sie die maximale Geschwindigkeit einschränken, an der ggf. ein Hologramm Entfernung des Benutzers variieren kann.</span><span class="sxs-lookup"><span data-stu-id="01867-137">Aggregation or smoothing can also be performed over time; for example you can limit the maximum speed at which a hologram can vary in distance from the user.</span></span> <span data-ttu-id="01867-138">Wodurch einfach die minimalen und maximalen Abstand hilft auch, damit die – Hologramm verschoben werden nicht plötzlich Weg in die Ferne fliegen oder stammen, zurück in den Benutzer abstürzt.</span><span class="sxs-lookup"><span data-stu-id="01867-138">Simply limiting the minimum and maximum distance value can also help, so the hologram being moved does not suddenly fly away into the distance or come crashing back into the user's face.</span></span>

<span data-ttu-id="01867-139">Anwendungen können auch die Form und die Richtung der Flächen Guide – Hologramm Platzierung verwenden.</span><span class="sxs-lookup"><span data-stu-id="01867-139">Applications can also use the shape and direction of surfaces to guide hologram placement.</span></span> <span data-ttu-id="01867-140">Eine holographic Stuhl sollte kein durch Wände eindringt und sollten sind unveränderliche mit dem Boden, auch wenn es etwas ungleichmäßigen ist.</span><span class="sxs-lookup"><span data-stu-id="01867-140">A holographic chair should not penetrate through walls and should sit flush with the floor even if it is slightly uneven.</span></span> <span data-ttu-id="01867-141">Diese Art von Funktion würde wahrscheinlich auf die Verwendung der Physik Konflikte statt nur Raycasts, gelten jedoch ähnliche Themen basieren.</span><span class="sxs-lookup"><span data-stu-id="01867-141">This kind of functionality would likely rely upon the use of physics collisions rather than just raycasts, however similar concerns will apply.</span></span> <span data-ttu-id="01867-142">Wenn die – Hologramm angeordnet werden viele kleine Polygone, die bleiben verfügt, wie die "Legs" eines Stuhls, kann es sinnvoll, erweitern die physikalische Darstellung die Polygone etwas breiter und reibungslose, sodass sie mehr über räumliche Flächen ohne schieben können Erstellen von Bildschirmfotos.</span><span class="sxs-lookup"><span data-stu-id="01867-142">If the hologram being placed has many small polygons that stick out, like the legs on a chair, it may make sense to expand the physics representation of those polygons to something wider and smoother so that they are more able to slide over spatial surfaces without snagging.</span></span>

<span data-ttu-id="01867-143">An dessen Ende der Skala Benutzereingabe kann vereinfacht werden sofort vollständig aus, und räumliche Flächen können verwendet werden, vollständig automatisch – Hologramm Platzierung ausführen.</span><span class="sxs-lookup"><span data-stu-id="01867-143">At its extreme, user input can be simplified away entirely and spatial surfaces can be used to perform entirely automatic hologram placement.</span></span> <span data-ttu-id="01867-144">Beispielsweise kann die Anwendung einen holographic Light-Switch an einer beliebigen Stelle an die Wand für den Benutzer zum Drücken platzieren.</span><span class="sxs-lookup"><span data-stu-id="01867-144">For example, the application could place a holographic light-switch somewhere on the wall for the user to press.</span></span> <span data-ttu-id="01867-145">Gelten die gleichen Vorbehalte zur Vorhersagbarkeit doppelt hier; Wenn der Benutzer steuern – Hologramm Platzierung erwartet, aber die Anwendung nicht immer Hologramme platzieren ist, erwarten sie, dass (sofern die Light-Schalter an einer Stelle, die den Benutzer zu erreichen, kann nicht angezeigt), wird dies führt dazu, dass sein.</span><span class="sxs-lookup"><span data-stu-id="01867-145">The same caveat about predictability applies doubly here; if the user expects control over hologram placement, but the application does not always place holograms where they expect (if the light-switch appears somewhere that the user cannot reach), then this will be a frustrating experience.</span></span> <span data-ttu-id="01867-146">Es kann tatsächlich nicht schlimmer kommen, automatische Platzierung auszuführen, die Benutzer-Korrektur erfordert ein Teil der Zeit, als die, müssen nur die Benutzer immer Platzierung selbst; ausführen Da das erfolgreiche automatische Platzierung wird *erwartet*, manuelle Korrektur scheint eine Belastung dar.</span><span class="sxs-lookup"><span data-stu-id="01867-146">It can actually be worse to perform automatic placement that requires user correction some of the time, than to just require the user to always perform placement themselves; because successful automatic placement is *expected*, manual correction feels like a burden!</span></span>

<span data-ttu-id="01867-147">Beachten Sie auch, dass die Fähigkeit einer Anwendung zur Verwendung von räumlicher Oberflächen für die Platzierung stark von der Anwendung abhängig ist [Scannen Erfahrung](spatial-mapping-design.md#the-environment-scanning-experience).</span><span class="sxs-lookup"><span data-stu-id="01867-147">Note also that the ability of an application to use spatial surfaces for placement depends heavily on the application's [scanning experience](spatial-mapping-design.md#the-environment-scanning-experience).</span></span> <span data-ttu-id="01867-148">Wenn eine Oberfläche nicht gescannt wurde, kann es für die Platzierung verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="01867-148">If a surface has not been scanned, then it cannot be used for placement.</span></span> <span data-ttu-id="01867-149">Es ist Aufgabe der Anwendung, die dies deutlich für den Benutzer zu machen, damit er entweder unterstützen können, überprüfen die neue Flächen aus, oder wählen Sie einen neuen Speicherort.</span><span class="sxs-lookup"><span data-stu-id="01867-149">It is up to the application to make this clear to the user, so that they can either help scan new surfaces or select a new location.</span></span>

<span data-ttu-id="01867-150">Visuelles Feedback an den Benutzer ist von größter Wichtigkeit, während der Platzierung.</span><span class="sxs-lookup"><span data-stu-id="01867-150">Visual feedback to the user is of paramount importance during placement.</span></span> <span data-ttu-id="01867-151">Der Benutzer muss wissen, wo die Hologramm in Bezug auf die nächste Oberfläche mit [Erdung Effekte](spatial-mapping.md#visualization).</span><span class="sxs-lookup"><span data-stu-id="01867-151">The user needs to know where the hologram is in relation to the nearest surface with [grounding effects](spatial-mapping.md#visualization).</span></span> <span data-ttu-id="01867-152">Sie sollten wissen, warum das Verschieben von ihren – Hologramm (z. B. aufgrund von Konflikt mit einem anderen in der Nähe Oberfläche) eingeschränkt wird.</span><span class="sxs-lookup"><span data-stu-id="01867-152">They should understand why the movement of their hologram is being constrained (for example, due to collision with another nearby surface).</span></span> <span data-ttu-id="01867-153">Wenn sie ggf. ein Hologramm in der aktuellen Position einfügen können, sollten visuelles Feedback verdeutlichen, warum nicht vornehmen.</span><span class="sxs-lookup"><span data-stu-id="01867-153">If they cannot place a hologram in the current location, then visual feedback should make it clear why not.</span></span> <span data-ttu-id="01867-154">Z. B. wenn der Benutzer versucht, platzieren Sie hängen ein holographic Sofa Hälfte in die Wand, und klicken Sie dann die Teile der Sofa, die hinter den Zaun sind verärgert farblich pulsate sollten.</span><span class="sxs-lookup"><span data-stu-id="01867-154">For example, if the user is trying to place a holographic couch stuck half-way into the wall, then the portions of the couch that are behind the wall should pulsate in an angry color.</span></span> <span data-ttu-id="01867-155">Oder umgekehrt, wenn die Anwendung eine räumliche Oberfläche an einem Ort nicht finden können, in denen der Benutzer eine reale Oberfläche sehen können, klicken Sie dann die Anwendung muss dies deutlich machen.</span><span class="sxs-lookup"><span data-stu-id="01867-155">Or conversely, if the application cannot find a spatial surface in a location where the user can see a real-world surface, then the application should make this clear.</span></span> <span data-ttu-id="01867-156">Das fehlen offensichtliche einen Effekt sollen in diesem Bereich kann dieses Ziel erreichen.</span><span class="sxs-lookup"><span data-stu-id="01867-156">The obvious absence of a grounding effect in this area may achieve this purpose.</span></span>

### <a name="occlusion"></a><span data-ttu-id="01867-157">Okklusion</span><span class="sxs-lookup"><span data-stu-id="01867-157">Occlusion</span></span>

<span data-ttu-id="01867-158">Eine der hauptsächlichen Verwendungsformen räumliche Zuordnung Flächen ist einfach Hologramme verdeckt.</span><span class="sxs-lookup"><span data-stu-id="01867-158">One of the primary uses of spatial mapping surfaces is simply to occlude holograms.</span></span> <span data-ttu-id="01867-159">Dieses einfache Verhalten hat enorme Auswirkungen auf die wahrgenommene für eine realistischere Darstellung Hologramme, die beim Erzeugen eines stellen, die den gleichen physischen Bereich wie der Benutzer wirklich darstellen.</span><span class="sxs-lookup"><span data-stu-id="01867-159">This simple behavior has a huge impact on the perceived realism of holograms, helping to create a visceral sense that really inhabit the same physical space as the user.</span></span>

<span data-ttu-id="01867-160">Verdecken enthält außerdem Informationen für den Benutzer; ggf. ein Hologramm angezeigt wird, die von einer realen Oberfläche okkludierte werden, bieten sich zusätzliches von visuellem Feedback, die räumliche Position der dieser – Hologramm, in der ganzen Welt.</span><span class="sxs-lookup"><span data-stu-id="01867-160">Occlusion also provides information to the user; when a hologram appears to be occluded by a real-world surface, this provides additional visual feedback as to the spatial location of that hologram in the world.</span></span> <span data-ttu-id="01867-161">Im Gegensatz dazu verdecken kann auch sinnvoll *ausblenden* Informationen vom Benutzer; occluding Hologramme hinter Wände können visuelle Überfrachtung intuitive Weise zu reduzieren.</span><span class="sxs-lookup"><span data-stu-id="01867-161">Conversely, occlusion can also usefully *hide* information from the user; occluding holograms behind walls can reduce visual clutter in an intuitive way.</span></span> <span data-ttu-id="01867-162">Um ggf. ein Hologramm anzuzeigen oder auszublenden, muss der Benutzer lediglich ihren Köpfen zu verschieben.</span><span class="sxs-lookup"><span data-stu-id="01867-162">To hide or reveal a hologram, the user merely has to move their head.</span></span>

<span data-ttu-id="01867-163">Verdecken kann auch verwendet werden, um die Erwartungen an einer natürlichen Benutzeroberfläche basierend auf vertrauten physischen Interaktionen vorzubereiten; Wenn durch eine Fläche, die ggf. ein Hologramm ist okkludierte ist da, die dann bei solid handelt, also der Benutzer sollte erwarten, dass ein Hologramm *in Konflikt stehen* , Entwurfsoberfläche, und nicht einfach durch ihn durchlaufen.</span><span class="sxs-lookup"><span data-stu-id="01867-163">Occlusion can also be used to prime expectations for a natural user interface based upon familiar physical interactions; if a hologram is occluded by a surface it is because that surface is solid, so the user should expect that the hologram will *collide* with that surface and not simply pass through it.</span></span>

<span data-ttu-id="01867-164">In einigen Fällen ist verdecken von Hologramme nicht erwünscht.</span><span class="sxs-lookup"><span data-stu-id="01867-164">Sometimes, occlusion of holograms is undesirable.</span></span> <span data-ttu-id="01867-165">Wenn ein Benutzer benötigt, um ggf. ein Hologramm interagieren zu können, müssen sie - angezeigt, auch wenn er sich hinter einer echten Oberfläche befindet.</span><span class="sxs-lookup"><span data-stu-id="01867-165">If a user needs to be able to interact with a hologram, then they need to be able to see it - even if it is behind a real-world surface.</span></span> <span data-ttu-id="01867-166">In solchen Fällen sinnvoll es in der Regel um solche ggf. ein Hologramm anders gerendert werden, wenn es okkludierte ist (z. B. durch das Reduzieren der Helligkeit).</span><span class="sxs-lookup"><span data-stu-id="01867-166">In such cases, it usually makes sense to render such a hologram differently when it is occluded (for example, by reducing its brightness).</span></span> <span data-ttu-id="01867-167">Auf diese Weise der Benutzer kann die Hologramm visuell zu suchen, aber sie werden weiterhin in der Beachten Sie, dass er sich hinter der etwas befindet.</span><span class="sxs-lookup"><span data-stu-id="01867-167">This way, the user will be able to visually locate the hologram, but they will still be aware that it is behind something.</span></span>

### <a name="physics"></a><span data-ttu-id="01867-168">Physik</span><span class="sxs-lookup"><span data-stu-id="01867-168">Physics</span></span>

<span data-ttu-id="01867-169">Die Verwendung der Physiksimulation ist eine andere Art, in die räumliche Zuordnung verwendet werden, kann um zu erzwingen die *Anwesenheit* von Hologramme im physischen Raum des Benutzers.</span><span class="sxs-lookup"><span data-stu-id="01867-169">The use of physics simulation is another way in which spatial mapping can be used to reinforce the *presence* of holograms in the user's physical space.</span></span> <span data-ttu-id="01867-170">Wenn meine holographic Gummiball realistisch gesehen wird die aus meinem Schreibtisch, über dem Boden springt und nicht mehr angezeigt, unter dem Sofa wird, ist es möglicherweise schwierig für mich zu glauben, dass sie nicht wirklich vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="01867-170">When my holographic rubber ball rolls realistically off my desk, bounces across the floor and disappears under the couch, it might be hard for me to believe that it's not really there.</span></span>

<span data-ttu-id="01867-171">Physiksimulation bietet auch die Möglichkeit, eine Anwendung natürliche und vertraute Physik-basierte Interaktionen zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="01867-171">Physics simulation also provides the opportunity for an application to use natural and familiar physics-based interactions.</span></span> <span data-ttu-id="01867-172">Beim Verschieben eines holographic Möbel, um auf dem Boden wird wahrscheinlich einfacher sein, für den Benutzer, wenn die Möbel reagiert, als ob er über dem Boden, mit dem entsprechenden Trägheit und Reibung gleitend wurden.</span><span class="sxs-lookup"><span data-stu-id="01867-172">Moving a piece of holographic furniture around on the floor will likely be easier for the user if the furniture responds as if it were sliding across the floor with the appropriate inertia and friction.</span></span>

<span data-ttu-id="01867-173">Um realistische physikalische Verhalten zu generieren, Sie müssen wahrscheinlich einige ausführen [mesh Verarbeitung](spatial-mapping.md#mesh-processing) wie füllen Lücken, Entfernen von Gleitkomma-Wahnvorstellungen und Glättung Allgemeines Flächen.</span><span class="sxs-lookup"><span data-stu-id="01867-173">In order to generate realistic physical behaviors, you will likely need to perform some [mesh processing](spatial-mapping.md#mesh-processing) such as filling holes, removing floating hallucinations and smoothing rough surfaces.</span></span>

<span data-ttu-id="01867-174">Sie müssen auch beachten wie Ihrer Anwendungsverzeichnis [Scannen Erfahrung](spatial-mapping-design.md#the-environment-scanning-experience) wirkt sich auf die Physiksimulation.</span><span class="sxs-lookup"><span data-stu-id="01867-174">You will also need to consider how your application's [scanning experience](spatial-mapping-design.md#the-environment-scanning-experience) influences its physics simulation.</span></span> <span data-ttu-id="01867-175">Zuerst wird nicht fehlen Flächen mit in Konflikt stehen; Was geschieht, wenn die Gummiball off wird die Gang und am Ende der Welt bekannt?</span><span class="sxs-lookup"><span data-stu-id="01867-175">Firstly, missing surfaces won't collide with anything; what happens when the rubber ball rolls off down the corridor and off the end of the known world?</span></span> <span data-ttu-id="01867-176">Als Nächstes müssen Sie entscheiden, ob Sie fortgesetzt werden, um auf Änderungen in der Umgebung im Laufe der Zeit zu reagieren.</span><span class="sxs-lookup"><span data-stu-id="01867-176">Secondly, you need to decide whether you will continue to respond to changes in the environment over time.</span></span> <span data-ttu-id="01867-177">In einigen Fällen möchten Sie so schnell wie möglich Antworten; Nehmen wir an, wenn der Benutzer als verschiebbar Barrikaden in Verteidigung gegen eine Tempest eingehende Roman Pfeile Türen und Möbel verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="01867-177">In some cases, you will want to respond as quickly as possible; say if the user is using doors and furniture as movable barricades in defense against a tempest of incoming Roman arrows.</span></span> <span data-ttu-id="01867-178">In anderen Fällen sollten, Sie in neuen Updates zu ignorieren; einbringen Ihrer holographic Sportwagen rund um die Oval auf Ihre Boden plötzlich möglicherweise nicht so unterhaltsam, wenn möchte, dass Ihr Hund in der Mitte der Spur befinden.</span><span class="sxs-lookup"><span data-stu-id="01867-178">In other cases though, you may want to ignore new updates; driving your holographic sports car around the racetrack on your floor may suddenly not be so fun if your dog decides to sit in the middle of the track.</span></span>

### <a name="navigation"></a><span data-ttu-id="01867-179">Navigation</span><span class="sxs-lookup"><span data-stu-id="01867-179">Navigation</span></span>

<span data-ttu-id="01867-180">Räumliche Zuordnungsdaten können Anwendungen holographic Zeichen (oder -Agents) gewähren die Möglichkeit, die reale Welt auf die gleiche Weise wie eine Person zu navigieren.</span><span class="sxs-lookup"><span data-stu-id="01867-180">Applications can use spatial mapping data to grant holographic characters (or agents) the ability to navigate the real world in the same way a real person would.</span></span> <span data-ttu-id="01867-181">Dies kann helfen, das Vorhandensein von holographic Zeichen zu verstärken, indem sie auf den gleichen Satz von natürlichen, vertrauten Verhalten wie die der Benutzer und ihre Freunde zu beschränken.</span><span class="sxs-lookup"><span data-stu-id="01867-181">This can help reinforce the presence of holographic characters by restricting them to the same set of natural, familiar behaviors as those of the user and their friends.</span></span>

<span data-ttu-id="01867-182">Navigationsfunktionen können auch nützlich sein.</span><span class="sxs-lookup"><span data-stu-id="01867-182">Navigation capabilities could be useful to users as well.</span></span> <span data-ttu-id="01867-183">Sobald eine Zuordnung für die Navigation in einem bestimmten Gebiet erstellt wurde, konnte er gemeinsam genutzt werden, um holographic erfahren Sie, wie neue Benutzer nicht vertraut mit diesem Speicherort bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="01867-183">Once a navigation map has been built in a given area, it could be shared to provide holographic directions for new users unfamiliar with that location.</span></span> <span data-ttu-id="01867-184">Diese Zuordnung kann entworfen werden, um dafür zu sorgen, dass einfache "Datenflüsse" reibungslos oder um Störungen in gefährlicher Speicherorten wie dem Baustellen zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="01867-184">This map could be designed to help keep pedestrian 'traffic' flowing smoothly, or to avoid accidents in dangerous locations like construction sites.</span></span>

<span data-ttu-id="01867-185">Die wichtigsten technischen Herausforderungen bei der Implementierung der Navigationsfunktion verfügbar werden zuverlässige Erkennung von walks Oberflächen (Menschen nicht für Tabellen führen!) und ordnungsgemäßen Anpassung an Änderungen in der Umgebung (Menschen nicht Türen durchlaufen!).</span><span class="sxs-lookup"><span data-stu-id="01867-185">The key technical challenges involved in implementing navigation functionality will be reliable detection of walkable surfaces (humans don't walk on tables!) and graceful adaptation to changes in the environment (humans don't walk through closed doors!).</span></span> <span data-ttu-id="01867-186">Das Netz möglicherweise einige [Verarbeitung](spatial-mapping.md#mesh-processing) , bevor er für die Pfad-Planung und Navigation von einem virtuellen Zeichen verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="01867-186">The mesh may require some [processing](spatial-mapping.md#mesh-processing) before it is usable for path-planning and navigation by a virtual character.</span></span> <span data-ttu-id="01867-187">Mesh-Glättung, und Entfernen von Wahnvorstellungen können hängen zunehmend Zeichen zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="01867-187">Smoothing the mesh and removing hallucinations may help avoid characters becoming stuck.</span></span> <span data-ttu-id="01867-188">Möglicherweise möchten Sie auch das Gitter erheblich zu vereinfachen, um den Pfad des Zeichens-Planung und Berechnungen, die Navigation zu beschleunigen.</span><span class="sxs-lookup"><span data-stu-id="01867-188">You may also wish to drastically simplify the mesh in order to speed up your character's path-planning and navigation calculations.</span></span> <span data-ttu-id="01867-189">Dieser Herausforderungen viel Aufmerksamkeit erhalten haben, bei der Entwicklung von Videogame-Technologie, und es gibt eine Fülle von verfügbaren Forschungsliteratur zu diesen Themen.</span><span class="sxs-lookup"><span data-stu-id="01867-189">These challenges have received a great deal of attention in the development of videogame technology, and there is a wealth of available research literature on these topics.</span></span>

<span data-ttu-id="01867-190">Beachten Sie, dass die integrierten NavMesh-Funktionalität in Unity mit räumliche Zuordnung Oberflächen verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="01867-190">Note that the built-in NavMesh functionality in Unity cannot be used with spatial mapping surfaces.</span></span> <span data-ttu-id="01867-191">Dies ist, da die räumliche Zuordnung Oberflächen nicht bekannt sind, bis die Anwendung gestartet wird, während NavMesh Datendateien aus der Quelle Assets vorab generiert werden müssen.</span><span class="sxs-lookup"><span data-stu-id="01867-191">This is because spatial mapping surfaces are not known until the application starts, whereas NavMesh data files need to be generated from source assets ahead of time.</span></span> <span data-ttu-id="01867-192">Beachten Sie, dass vom System für die räumliche Zuordnung nicht bereitgestellt werden [Informationen sehr weit entfernt Flächen](spatial-mapping-design.md#the-environment-scanning-experience) aus der aktuellen Position des Benutzers.</span><span class="sxs-lookup"><span data-stu-id="01867-192">Also note that, the spatial mapping system will not provide [information about surfaces very far away](spatial-mapping-design.md#the-environment-scanning-experience) from the user's current location.</span></span> <span data-ttu-id="01867-193">Daher muss die Anwendung "Flächen selbst Denken Sie daran", wenn es ist, erstellen eine Übersicht über eine sehr große Fläche.</span><span class="sxs-lookup"><span data-stu-id="01867-193">So the application must 'remember' surfaces itself if it is to build a map of a very large area.</span></span>

### <a name="visualization"></a><span data-ttu-id="01867-194">Visualisierung</span><span class="sxs-lookup"><span data-stu-id="01867-194">Visualization</span></span>

<span data-ttu-id="01867-195">In den meisten Fällen ist es angebracht, für die räumliche Oberflächen nicht sichtbar sein. um visuelle Überfrachtung zu minimieren, und lassen die tatsächlichen Welt sprechen für sich selbst.</span><span class="sxs-lookup"><span data-stu-id="01867-195">Most of the time it is appropriate for spatial surfaces to be invisible; to minimize visual clutter and let the real world speak for itself.</span></span> <span data-ttu-id="01867-196">Allerdings ist es manchmal sinnvoll, die räumliche Zuordnung Flächen direkt, trotz der Tatsache zu visualisieren, dass ihre realen Entsprechungen bereits sichtbar sind.</span><span class="sxs-lookup"><span data-stu-id="01867-196">However, sometimes it is useful to visualize spatial mapping surfaces directly, despite the fact that their real-world counterparts are already visible.</span></span>

<span data-ttu-id="01867-197">Z. B. wenn der Benutzer versucht, platzieren Sie ggf. ein Hologramm auf einer Oberfläche (platzieren holographic CAB-Datei an die Wand, z. B..) Es kann hilfreich sein, "Hologramm erden" durch einen Schatten auf die Oberfläche.</span><span class="sxs-lookup"><span data-stu-id="01867-197">For example, when the user is trying to place a hologram onto a surface (placing a holographic cabinet on the wall, say) it can be useful to 'ground' the hologram by casting a shadow onto the surface.</span></span> <span data-ttu-id="01867-198">Dadurch wird dem Benutzer einen viel klarer Eindruck von der exakte physische Nähe zwischen den – Hologramm und der Fläche.</span><span class="sxs-lookup"><span data-stu-id="01867-198">This gives the user a much clearer sense of the exact physical proximity between the hologram and the surface.</span></span> <span data-ttu-id="01867-199">Dies ist auch ein Beispiel für die allgemeine Vorgehensweise visuell eine Änderung "Vorschau", bevor der Benutzer, ein Commit ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="01867-199">This is also an example of the more general practice of visually 'previewing' a change before the user commits to it.</span></span>

<span data-ttu-id="01867-200">Durch die Visualisierung der Flächen, kann die Anwendung ihr Verständnis von der Umgebung mit dem Benutzer freigeben.</span><span class="sxs-lookup"><span data-stu-id="01867-200">By visualizing surfaces, the application can share with the user its understanding of the environment.</span></span> <span data-ttu-id="01867-201">Beispielsweise kann ein holographic Brettspiel das horizontale bietet, die sie als "Tabellen", identifiziert hat visualisieren, damit der Benutzer weiß, wo sie gespeichert werden sollen, interagieren.</span><span class="sxs-lookup"><span data-stu-id="01867-201">For example, a holographic board game could visualize the horizontal surfaces that it has identified as 'tables', so the user knows where they should go to interact.</span></span>

<span data-ttu-id="01867-202">Visualisieren von Flächen werden eine gute Möglichkeit, die dem Benutzer in der Nähe Leerzeichen angezeigt wird, die in der Ansicht ausgeblendet sind.</span><span class="sxs-lookup"><span data-stu-id="01867-202">Visualizing surfaces can be a useful way to show the user nearby spaces that are hidden from view.</span></span> <span data-ttu-id="01867-203">Dies könnte eine einfache Möglichkeit zum Erteilen der Zugriffsrechte für die Küche (und alle seine enthaltenen Hologramme) aus ihren Wohnzimmer bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="01867-203">This could provide a simple way to give the user access to their kitchen (and all of its contained holograms) from their living room.</span></span>

<span data-ttu-id="01867-204">Die räumliche Zuordnung gebotenen Oberfläche Gitter möglicherweise nicht besonders "bereinigen".</span><span class="sxs-lookup"><span data-stu-id="01867-204">The surface meshes provided by spatial mapping may not be particularly 'clean'.</span></span> <span data-ttu-id="01867-205">Daher ist es wichtig, um sie entsprechend visuell darzustellen.</span><span class="sxs-lookup"><span data-stu-id="01867-205">Thus it is important to visualize them appropriately.</span></span> <span data-ttu-id="01867-206">Herkömmliche lichtberechnungen möglicherweise Fehler im Oberflächennormale auf eine Weise visuell ablenken markieren, während "bereinigen" auf der Oberfläche projizierte Texturen helfen können, um es einen besseren Überblick über Ihre aussehen zu verleihen.</span><span class="sxs-lookup"><span data-stu-id="01867-206">Traditional lighting calculations may highlight errors in surface normals in a visually distracting manner, whilst 'clean' textures projected onto the surface may help to give it a tidier appearance.</span></span> <span data-ttu-id="01867-207">Es ist auch möglich, führen Sie [mesh Verarbeitung](spatial-mapping.md#mesh-processing) Mesh-Eigenschaften zu verbessern, bevor die Oberflächen gerendert werden.</span><span class="sxs-lookup"><span data-stu-id="01867-207">It is also possible to perform [mesh processing](spatial-mapping.md#mesh-processing) to improve mesh properties, before the surfaces are rendered.</span></span>

## <a name="using-the-surface-observer"></a><span data-ttu-id="01867-208">Mithilfe des Entwurfsoberflächen Beobachters</span><span class="sxs-lookup"><span data-stu-id="01867-208">Using The Surface Observer</span></span>

<span data-ttu-id="01867-209">Der Ausgangspunkt für die räumliche Zuordnung ist der Oberfläche Beobachter.</span><span class="sxs-lookup"><span data-stu-id="01867-209">The starting point for spatial mapping is the surface observer.</span></span> <span data-ttu-id="01867-210">Programmablauf lautet wie folgt aus:</span><span class="sxs-lookup"><span data-stu-id="01867-210">Program flow is as follows:</span></span>
* <span data-ttu-id="01867-211">Erstellen Sie ein Surface Observer-Objekt</span><span class="sxs-lookup"><span data-stu-id="01867-211">Create a surface observer object</span></span>
   * <span data-ttu-id="01867-212">Geben Sie ein oder mehrere räumliche Volumes, um die interessante Bereiche zu definieren, in dem die Anwendung die räumliche Zuordnungsdaten empfangen möchte.</span><span class="sxs-lookup"><span data-stu-id="01867-212">Provide one or more spatial volumes, to define the regions of interest in which the application wishes to receive spatial mapping data.</span></span> <span data-ttu-id="01867-213">Ein räumlicher Volume ist einfach eine Form, die einen Bereich von Leerzeichen, z. B. eine Kugel oder ein Feld definieren.</span><span class="sxs-lookup"><span data-stu-id="01867-213">A spatial volume is simply a shape defining a region of space, such as a sphere or a box.</span></span>
   * <span data-ttu-id="01867-214">Verwenden Sie eine räumliche Volume mit einem World-locked räumliche Koordinatensystem, um einen festen Bereich der physischen Welt zu identifizieren.</span><span class="sxs-lookup"><span data-stu-id="01867-214">Use a spatial volume with a world-locked spatial coordinate system to identify a fixed region of the physical world.</span></span>
   * <span data-ttu-id="01867-215">Verwenden Sie einen räumlichen Volume aktualisiert jeder frame mit einem Text-locked räumliche Koordinatensystem, einen Bereich des zu identifizieren, die verschoben wird (aber wird nicht gedreht) mit dem Benutzer.</span><span class="sxs-lookup"><span data-stu-id="01867-215">Use a spatial volume, updated each frame with a body-locked spatial coordinate system, to identify a region of space that moves (but does not rotate) with the user.</span></span>
   * <span data-ttu-id="01867-216">Diese räumliche Volumes können später zu einem beliebigen Zeitpunkt, der Status der Anwendung oder Änderung durch den Benutzer geändert werden.</span><span class="sxs-lookup"><span data-stu-id="01867-216">These spatial volumes may be changed later at any time, as the status of the application or the user changes.</span></span>
* <span data-ttu-id="01867-217">Verwenden Sie abrufen oder eine Benachrichtigung zum Abrufen von Informationen zu räumlichen Oberflächen</span><span class="sxs-lookup"><span data-stu-id="01867-217">Use polling or notification to retrieve information about spatial surfaces</span></span>
   * <span data-ttu-id="01867-218">Sie können "den Entwurfsoberflächen Beobachter für räumliche Oberfläche Status zu einem beliebigen Zeitpunkt abrufen".</span><span class="sxs-lookup"><span data-stu-id="01867-218">You may 'poll' the surface observer for spatial surface status at any time.</span></span> <span data-ttu-id="01867-219">Alternativ können Sie für den Surface Beobachter "Flächen geändert" Ereignis registrieren, die Anwendung benachrichtigt, wenn räumliche Flächen geändert wurden.</span><span class="sxs-lookup"><span data-stu-id="01867-219">Alternatively, you may register for the surface observer's 'surfaces changed' event, which will notify the application when spatial surfaces have changed.</span></span>
   * <span data-ttu-id="01867-220">Anwendungen müssen für ein dynamisches Volume räumliche an, wie z. B. die Frustums Ansicht oder einem Text-locked Volume für jeden Frame Abruf von Änderungen durch Festlegen des relevanten Bereichs, und klicken Sie dann Abrufen des aktuellen Satzes von räumlichen Flächen.</span><span class="sxs-lookup"><span data-stu-id="01867-220">For a dynamic spatial volume, such as the view frustum, or a body-locked volume, applications will need to poll for changes each frame by setting the region of interest and then obtaining the current set of spatial surfaces.</span></span>
   * <span data-ttu-id="01867-221">Für einen statischen Datenträger, z. B. eine World-locked Cube zu einem einzigen Raum können Anwendungen registrieren, für das Ereignis "Flächen geändert" benachrichtigt, wenn räumliche Flächen, die innerhalb dieses Volume möglicherweise geändert wurde.</span><span class="sxs-lookup"><span data-stu-id="01867-221">For a static volume, such as a world-locked cube covering a single room, applications may register for the 'surfaces changed' event to be notified when spatial surfaces inside that volume may have changed.</span></span>
* <span data-ttu-id="01867-222">Verarbeiten von Flächen Änderungen</span><span class="sxs-lookup"><span data-stu-id="01867-222">Process surfaces changes</span></span>
   * <span data-ttu-id="01867-223">Durchlaufen Sie die räumliche Oberflächen zur Verfügung gestellten Satz an.</span><span class="sxs-lookup"><span data-stu-id="01867-223">Iterate the provided set of spatial surfaces.</span></span>
   * <span data-ttu-id="01867-224">Klassifizieren Sie räumliche Oberflächen als hinzugefügt, geändert oder entfernt.</span><span class="sxs-lookup"><span data-stu-id="01867-224">Classify spatial surfaces as added, changed or removed.</span></span>
   * <span data-ttu-id="01867-225">Senden Sie für jede hinzugefügte oder geänderte räumliche Fläche ggf. eine asynchrone Anforderung zum Empfangen von aktualisierten Mesh, das die Fläche des aktuellen Status auf die gewünschte Detailebene darstellt.</span><span class="sxs-lookup"><span data-stu-id="01867-225">For each added or changed spatial surface, if appropriate submit an asynchronous request to receive updated mesh representing the surface's current state at the desired level of detail.</span></span>
* <span data-ttu-id="01867-226">Verarbeiten der Anforderung asynchroner Netz (mehr Details in den folgenden Abschnitten).</span><span class="sxs-lookup"><span data-stu-id="01867-226">Process the asynchronous mesh request (more details in following sections).</span></span>

## <a name="mesh-caching"></a><span data-ttu-id="01867-227">Mesh-Caching</span><span class="sxs-lookup"><span data-stu-id="01867-227">Mesh Caching</span></span>

<span data-ttu-id="01867-228">Räumliche Flächen werden durch dichten Dreieckgitter dargestellt.</span><span class="sxs-lookup"><span data-stu-id="01867-228">Spatial surfaces are represented by dense triangle meshes.</span></span> <span data-ttu-id="01867-229">Speichern von, rendern und verarbeiten diese Gitter können erhebliche Ressourcen für COMPUTE und Speicher nutzen.</span><span class="sxs-lookup"><span data-stu-id="01867-229">Storing, rendering and processing these meshes can consume significant computational and storage resources.</span></span> <span data-ttu-id="01867-230">Daher sollte jede Anwendung ein Netz Cache-Schema für ihre Anforderungen, um die für die Mesh-Verarbeitung und Speicherung verwendeten Ressourcen zu minimieren übernehmen.</span><span class="sxs-lookup"><span data-stu-id="01867-230">As such, each application should adopt a mesh caching scheme appropriate to its needs, in order to minimize the resources used for mesh processing and storage.</span></span> <span data-ttu-id="01867-231">Dieses Schema sollten ermitteln, die Gitter beibehalten werden sollen, verwerfen, sowie wann das Netz für jede räumliche Fläche aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="01867-231">This scheme should determine which meshes to retain and which to discard, as well as when to update the mesh for each spatial surface.</span></span>

<span data-ttu-id="01867-232">Viele Überlegungen behandelt, es werden direkt informieren, wie Ihre Anwendung Zwischenspeichern Mesh Ansatz für die.</span><span class="sxs-lookup"><span data-stu-id="01867-232">Many of the considerations discussed there will directly inform how your application should approach mesh caching.</span></span> <span data-ttu-id="01867-233">Sie sollten erwägen, wie der Benutzer der Umgebung durchläuft, die Flächen erforderlich sind, bei verschiedene Oberflächen beobachtet werden werden und wenn Änderungen in der Umgebung erfasst werden sollen.</span><span class="sxs-lookup"><span data-stu-id="01867-233">You should consider how the user moves through the environment, which surfaces are needed, when different surfaces will be observed and when changes in the environment should be captured.</span></span>

<span data-ttu-id="01867-234">Beim Interpretieren der "Flächen" ein Änderungsereignis von der Oberfläche Beobachter bereitgestellt, ist die grundlegende Logik für das Zwischenspeichern Mesh wie folgt:</span><span class="sxs-lookup"><span data-stu-id="01867-234">When interpreting the 'surfaces changed' event provided by the surface observer, the basic mesh caching logic is as follows:</span></span>
* <span data-ttu-id="01867-235">Wenn die Anwendung eine räumliche Surface-ID, die es erkennt bisher nicht erkannt wurde, sollten sie dies als eine neue räumliche Oberfläche behandeln.</span><span class="sxs-lookup"><span data-stu-id="01867-235">If the application sees a spatial surface ID that it has not seen before, it should treat this as a new spatial surface.</span></span>
* <span data-ttu-id="01867-236">Wenn die Anwendung eine räumliche Oberfläche mit einer bekannten ID sieht, jedoch mit der neuen Updates, sollten sie dies als eine aktualisierte räumliche Oberfläche behandeln.</span><span class="sxs-lookup"><span data-stu-id="01867-236">If the application sees a spatial surface with a known ID but with a new update time, it should treat this as an updated spatial surface.</span></span>
* <span data-ttu-id="01867-237">Wenn die Anwendung nicht mehr eine räumliche Oberfläche mit einer bekannten ID sieht, sollten sie dies als entfernter räumlicher Oberfläche behandeln.</span><span class="sxs-lookup"><span data-stu-id="01867-237">If the application no longer sees a spatial surface with a known ID, it should treat this as a removed spatial surface.</span></span>

<span data-ttu-id="01867-238">Es obliegt an jede Anwendung, klicken Sie dann die folgenden Entscheidungen treffen:</span><span class="sxs-lookup"><span data-stu-id="01867-238">It is up to each application to then make the following choices:</span></span>
* <span data-ttu-id="01867-239">Für neue räumliche Flächen sollten Mesh werden angefordert?</span><span class="sxs-lookup"><span data-stu-id="01867-239">For new spatial surfaces, should mesh be requested?</span></span>
   * <span data-ttu-id="01867-240">Netz sollte in der Regel sofort für neue räumliche Flächen angefordert werden, die nützliche neue Informationen für den Benutzer bereitstellen kann.</span><span class="sxs-lookup"><span data-stu-id="01867-240">Generally mesh should be requested immediately for new spatial surfaces, which may provide useful new information to the user.</span></span>
   * <span data-ttu-id="01867-241">Jedoch neue räumliche Flächen, die in der Nähe und vor dem Benutzer sollte die Priorität eingeräumt werden aus, und ihre Mesh sollten zunächst angefordert werden.</span><span class="sxs-lookup"><span data-stu-id="01867-241">However, new spatial surfaces near and in front of the user should be given priority and their mesh should be requested first.</span></span>
   * <span data-ttu-id="01867-242">Wenn das neue Netz nicht erforderlich, wenn z. B. die Anwendung dauerhaftes oder temporäres 'das Modell der Umgebung fixiert hat', sollten sie nicht angefordert.</span><span class="sxs-lookup"><span data-stu-id="01867-242">If the new mesh is not needed, if for example the application has permanently or temporarily 'frozen' its model of the environment, then it should not be requested.</span></span>
* <span data-ttu-id="01867-243">Für die aktualisierten räumliche Oberflächen sollten Mesh werden angefordert?</span><span class="sxs-lookup"><span data-stu-id="01867-243">For updated spatial surfaces, should mesh be requested?</span></span>
   * <span data-ttu-id="01867-244">Aktualisierte räumliche Flächen, die in der Nähe und vor dem Benutzer Priorität zugewiesen werden soll, und ihre Mesh sollten zunächst angefordert werden.</span><span class="sxs-lookup"><span data-stu-id="01867-244">Updated spatial surfaces near and in front of the user should be given priority and their mesh should be requested first.</span></span>
   * <span data-ttu-id="01867-245">Es kann auch entsprechende neue Oberflächen als Oberflächen, vor allem bei der Überprüfung Umgebung aktualisiert höheren Priorität zugewiesen sein.</span><span class="sxs-lookup"><span data-stu-id="01867-245">It may also be appropriate to give higher priority to new surfaces than to updated surfaces, especially during the scanning experience.</span></span>
   * <span data-ttu-id="01867-246">Um Verarbeitungskosten beschränken möchten, sollten Anwendungen, die Rate zu drosseln, an der sie Updates für räumliche Flächen verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="01867-246">To limit processing costs, applications may wish to throttle the rate at which they process updates to spatial surfaces.</span></span>
   * <span data-ttu-id="01867-247">Möglicherweise folgern, dass Änderungen an einer räumlichen Oberfläche kleinere, z. B. sind Wenn die Begrenzungen der Oberfläche klein ist, sind in diesem Fall das Update wichtig genug sind, den Prozess möglicherweise nicht möglich.</span><span class="sxs-lookup"><span data-stu-id="01867-247">It may be possible to infer that changes to a spatial surface are minor, for example if the bounds of the surface are small, in which case the update may not be important enough to process.</span></span>
   * <span data-ttu-id="01867-248">Updates für räumliche Oberflächen außerhalb des aktuellen Bereichs von Interesse des Benutzers können komplett ignoriert werden, obwohl in diesem Fall sehr viel effizienter, räumliche umgebende Volumes in die Verwendung durch den Surface Beobachter ändern sein kann.</span><span class="sxs-lookup"><span data-stu-id="01867-248">Updates to spatial surfaces outside the current region of interest of the user may be ignored entirely, though in this case it may be more efficient to modify the spatial bounding volumes in use by the surface observer.</span></span>
* <span data-ttu-id="01867-249">Für entfernter räumlicher Flächen sollten Mesh werden verworfen?</span><span class="sxs-lookup"><span data-stu-id="01867-249">For removed spatial surfaces, should mesh be discarded?</span></span>
   * <span data-ttu-id="01867-250">Im Allgemeinen sollten Mesh sofort für entfernter räumlicher Flächen verworfen werden, sodass – Hologramm verdecken richtig bleibt.</span><span class="sxs-lookup"><span data-stu-id="01867-250">Generally mesh should be discarded immediately for removed spatial surfaces, so that hologram occlusion remains correct.</span></span>
   * <span data-ttu-id="01867-251">Jedoch verfügt die Anwendung Grund zur Annahme eine räumliche Oberfläche wird wieder angezeigt, in Kürze (möglicherweise je nach den Entwurf der benutzererfahrung), möglicherweise sehr viel effizienter, legen sie als zum Verwerfen der Netz aus, und es später noch Mal neu erstellen.</span><span class="sxs-lookup"><span data-stu-id="01867-251">However, if the application has reason to believe that a spatial surface will reappear shortly (perhaps based upon the design of the user experience), then it may be more efficient to retain it than to discard its mesh and recreate it again later.</span></span>
   * <span data-ttu-id="01867-252">Wenn die Anwendung ein umfangreicher Modell für die Umgebung des Benutzers erstellt, sollten sie keine Gitter zu verwerfen.</span><span class="sxs-lookup"><span data-stu-id="01867-252">If the application is building a large-scale model of the user's environment then it may not wish to discard any meshes at all.</span></span> <span data-ttu-id="01867-253">Sie müssen dennoch ressourcennutzung jedoch möglicherweise von Gitter Einreihen in die Warteschlange, auf dem Datenträger zu beschränken, wie räumliche Oberflächen nicht mehr angezeigt.</span><span class="sxs-lookup"><span data-stu-id="01867-253">It will still need to limit resource usage though, possibly by spooling meshes to disk as spatial surfaces disappear.</span></span>
   * <span data-ttu-id="01867-254">Beachten Sie, dass einige relativ selten Ereignisse während der räumlichen Oberfläche Generierung räumliche Flächen durch neue räumliche Oberflächen in einem ähnlichen Standort jedoch mit unterschiedlichen IDs ersetzt werden können.</span><span class="sxs-lookup"><span data-stu-id="01867-254">Note that some relatively rare events during spatial surface generation can cause spatial surfaces to be replaced by new spatial surfaces in a similar location but with different IDs.</span></span> <span data-ttu-id="01867-255">Folglich Anwendungen, die nicht zu eine entfernte Oberfläche verwerfen nicht bis Ende sich mit mehreren hoch überlappende räumliche Oberfläche Netzen für am gleichen Speicherort achten müssen.</span><span class="sxs-lookup"><span data-stu-id="01867-255">Consequently, applications that choose not to discard a removed surface should take care not to end up with multiple highly-overlapped spatial surface meshes covering the same location.</span></span>
* <span data-ttu-id="01867-256">Mesh für alle anderen räumlichen Flächen verworfen werden sollen?</span><span class="sxs-lookup"><span data-stu-id="01867-256">Should mesh be discarded for any other spatial surfaces?</span></span>
   * <span data-ttu-id="01867-257">Auch während einer räumlichen Oberfläche vorhanden ist, wenn es nicht mehr nützlich, um die benutzererfahrung ist, wird sie verworfen werden soll.</span><span class="sxs-lookup"><span data-stu-id="01867-257">Even while a spatial surface exists, if it is no longer useful to the user's experience then it should be discarded.</span></span> <span data-ttu-id="01867-258">Beispielsweise erforderlich ersetzt die Anwendung"der Platz auf der anderen Seite der einen Zugangspunkt mit einem anderen virtuellen Bereich', klicken Sie dann die räumlichen Flächen in diesem Raum nicht mehr.</span><span class="sxs-lookup"><span data-stu-id="01867-258">For example, if the application 'replaces' the room on the other side of a doorway with an alternate virtual space then the spatial surfaces in that room no longer matter.</span></span>

<span data-ttu-id="01867-259">Hier ist ein Beispiel Mesh cachingstrategie, räumlichen und zeitlichen Hysterese verwenden:</span><span class="sxs-lookup"><span data-stu-id="01867-259">Here is an example mesh caching strategy, using spatial and temporal hysteresis:</span></span>
* <span data-ttu-id="01867-260">Erwägen Sie eine Anwendung für die Verwendung einer Frustums geformten, räumliche Volumes von Interesse sind, die des Benutzers Blicke folgt, da sie sich mit der Registerkarte und dann aus.</span><span class="sxs-lookup"><span data-stu-id="01867-260">Consider an application that wishes to use a frustum-shaped spatial volume of interest that follows the user's gaze as they look around and walk around.</span></span>
* <span data-ttu-id="01867-261">Eine räumliche Oberfläche verschwindet möglicherweise vorübergehend von diesem Volume einfach, da der Benutzer, Weg von der Oberfläche sieht, oder um Schritte davon weiter... nur für zurück sehen oder verschiebt näher erneut einen Moment Zeit später noch mal.</span><span class="sxs-lookup"><span data-stu-id="01867-261">A spatial surface may disappear temporarily from this volume simply because the user looks away from the surface or steps further away from it... only to look back or moves closer again a moment later.</span></span> <span data-ttu-id="01867-262">In diesem Fall stellt verworfen und neu erstellen Mesh für diese Oberfläche viele redundante dar.</span><span class="sxs-lookup"><span data-stu-id="01867-262">In this case, discarding and re-creating the mesh for this surface represents a lot of redundant processing.</span></span>
* <span data-ttu-id="01867-263">Um die Anzahl der verarbeiteten Änderungen zu reduzieren, verwendet die Anwendung zwei räumliche Oberfläche Observer-Objekte, eine solche in einer anderen.</span><span class="sxs-lookup"><span data-stu-id="01867-263">To reduce the number of changes processed, the application uses two spatial surface observers, one contained within the other.</span></span> <span data-ttu-id="01867-264">Das größere Volume ist sphärischen und gilt für den Benutzer "verzögert"; Er verschiebt Sie nur bei Bedarf, um sicherzustellen, dass die Centre in 2.0 Meter des Benutzers.</span><span class="sxs-lookup"><span data-stu-id="01867-264">The larger volume is spherical and follows the user 'lazily'; it only moves when necessary to ensure that its centre is within 2.0 metres of the user.</span></span>
* <span data-ttu-id="01867-265">Neue und aktualisierte räumliche Oberfläche Gitter werden immer von der kleineren innere Oberfläche Beobachter verarbeitet, aber Gitter werden zwischengespeichert, bis sie von der größeren Beobachter für das äußere Oberfläche nicht mehr angezeigt.</span><span class="sxs-lookup"><span data-stu-id="01867-265">New and updated spatial surface meshes are always processed from the smaller inner surface observer, but meshes are cached until they disappear from the larger outer surface observer.</span></span> <span data-ttu-id="01867-266">Dadurch kann es sich um die Anwendung aus, um zu vermeiden, viele redundante Änderungen aufgrund des lokalen Benutzers Bewegung zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="01867-266">This allows the application to avoid processing many redundant changes due to local user movement.</span></span>
* <span data-ttu-id="01867-267">Da eine räumliche Oberfläche auch vorübergehend ausblenden möglicherweise aufgrund von Verlust nachverfolgung verzögert die Anwendung auch verwerfen entfernte räumliche Flächen während der nachverfolgung von Datenverlust.</span><span class="sxs-lookup"><span data-stu-id="01867-267">Since a spatial surface may also disappear temporarily due to tracking loss, the application also defers discarding removed spatial surfaces during tracking loss.</span></span>
* <span data-ttu-id="01867-268">Im Allgemeinen sollte eine Anwendung den Kompromiss zwischen Verarbeitung von reduzierten Aktualisierungen und erhöhter speicherauslastung, um zu bestimmen, die ideale cachingstrategie überprüfen.</span><span class="sxs-lookup"><span data-stu-id="01867-268">In general, an application should evaluate the tradeoff between reduced update processing and increased memory usage to determine its ideal caching strategy.</span></span>

## <a name="rendering"></a><span data-ttu-id="01867-269">Rendering</span><span class="sxs-lookup"><span data-stu-id="01867-269">Rendering</span></span>

<span data-ttu-id="01867-270">Es gibt drei Hauptmethoden, die in der räumliche Zuordnung Gitter neigen dazu, für das Rendering verwendet werden:</span><span class="sxs-lookup"><span data-stu-id="01867-270">There are three primary ways in which spatial mapping meshes tend to be used for rendering:</span></span>
* <span data-ttu-id="01867-271">Für die Oberfläche der Visualisierung</span><span class="sxs-lookup"><span data-stu-id="01867-271">For surface visualization</span></span>
   * <span data-ttu-id="01867-272">Es ist häufig nützlich, um die räumliche Flächen direkt zu visualisieren.</span><span class="sxs-lookup"><span data-stu-id="01867-272">It is often useful to visualize spatial surfaces directly.</span></span> <span data-ttu-id="01867-273">Beispielsweise können Umwandlung "Shadows" von Objekten, auf den spatial Flächen hilfreich visuelles Feedback an den Benutzer beim Platzieren von Hologramme auf Oberflächen.</span><span class="sxs-lookup"><span data-stu-id="01867-273">For example, casting 'shadows' from objects onto spatial surfaces can provide helpful visual feedback to the user while they are placing holograms on surfaces.</span></span>
   * <span data-ttu-id="01867-274">Dabei ist zu beachten ist, dass räumliche Gitter, um die Art der Gitter, die ein 3D Interpreten erstellen kann.</span><span class="sxs-lookup"><span data-stu-id="01867-274">One thing to bear in mind is that spatial meshes are different to the kind of meshes that a 3D artist might create.</span></span> <span data-ttu-id="01867-275">Die Topologie Dreieck werden nicht als "bereinigen" als Menschen erstellten Topologie und Mesh wird Leiden [verschiedene Fehler](spatial-mapping-design.md#what-influences-spatial-mapping-quality).</span><span class="sxs-lookup"><span data-stu-id="01867-275">The triangle topology will not be as 'clean' as human-created topology, and the mesh will suffer from [various errors](spatial-mapping-design.md#what-influences-spatial-mapping-quality).</span></span>
   * <span data-ttu-id="01867-276">Um eine ansprechende visuelle Ästhetik zu erstellen, Sie können daher einige ausführen möchten [mesh Verarbeitung](spatial-mapping.md#mesh-processing), z. B. Fill Lücken oder smooth Oberflächennormale.</span><span class="sxs-lookup"><span data-stu-id="01867-276">In order to create a pleasing visual aesthetic, you may thus want to perform some [mesh processing](spatial-mapping.md#mesh-processing), for example to fill holes or smooth surface normals.</span></span> <span data-ttu-id="01867-277">Möglicherweise möchten Sie auch einen Shader Projekt Interpreten konzipierte Texturen in Ihrem Mesh statt direkt auf die Visualisierung Mesh-Topologie und Normals verwenden.</span><span class="sxs-lookup"><span data-stu-id="01867-277">You may also wish to use a shader to project artist-designed textures onto your mesh instead of directly visualizing mesh topology and normals.</span></span>
* <span data-ttu-id="01867-278">Für occluding Hologramme hinter realen Oberflächen</span><span class="sxs-lookup"><span data-stu-id="01867-278">For occluding holograms behind real-world surfaces</span></span>
   * <span data-ttu-id="01867-279">Räumliche Oberflächen gerendert werden können in einem nur-Depth-Durchlauf der wirkt sich nur auf die [Tiefenpuffer](https://msdn.microsoft.com/library/windows/desktop/bb219616(v=vs.85).aspx) und wirkt sich nicht auf die Farbe renderzielen.</span><span class="sxs-lookup"><span data-stu-id="01867-279">Spatial surfaces can be rendered in a depth-only pass which only affects the [depth buffer](https://msdn.microsoft.com/library/windows/desktop/bb219616(v=vs.85).aspx) and does not affect color render targets.</span></span>
   * <span data-ttu-id="01867-280">Dies weist den Tiefenpuffer, um anschließend gerendert Hologramme hinter räumliche Flächen verdeckt.</span><span class="sxs-lookup"><span data-stu-id="01867-280">This primes the depth buffer to occlude subsequently-rendered holograms behind spatial surfaces.</span></span> <span data-ttu-id="01867-281">Genaue verdecken von Hologramme erweitert insofern Hologramme wirklich in den Raum des Benutzers vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="01867-281">Accurate occlusion of holograms enhances the sense that holograms really exist within the user's physical space.</span></span>
   * <span data-ttu-id="01867-282">Um nur tiefe-Rendering zu aktivieren, aktualisieren Sie Ihre Blend-Status, Festlegen der [RenderTargetWriteMask](https://msdn.microsoft.com/library/windows/desktop/hh404492(v=vs.85).aspx) Renderziele 0 (null) für alle Farben.</span><span class="sxs-lookup"><span data-stu-id="01867-282">To enable depth-only rendering, update your blend state to set the [RenderTargetWriteMask](https://msdn.microsoft.com/library/windows/desktop/hh404492(v=vs.85).aspx) to zero for all color render targets.</span></span>
* <span data-ttu-id="01867-283">Zum Ändern der Darstellung von Hologramme okkludierte von realen Oberflächen</span><span class="sxs-lookup"><span data-stu-id="01867-283">For modifying the appearance of holograms occluded by real-world surfaces</span></span>
   * <span data-ttu-id="01867-284">Normalerweise gerenderte Geometrie wird ausgeblendet, wenn es okkludierte ist.</span><span class="sxs-lookup"><span data-stu-id="01867-284">Normally rendered geometry is hidden when it is occluded.</span></span> <span data-ttu-id="01867-285">Dies wird erreicht, indem die Depth-Funktion Ihrer [Status der tiefenschablone](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx) auf "kleiner als oder gleich", der bewirkt, dass die Geometrie angezeigt werden, bei denen es nur ist **näher** bis zur Kamera als alle bereits gerendert Geometrie.</span><span class="sxs-lookup"><span data-stu-id="01867-285">This is achieved by setting the depth function in your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx) to "less than or equal", which causes geometry to be visible only where it is **closer** to the camera than all previously rendered geometry.</span></span>
   * <span data-ttu-id="01867-286">Allerdings kann es hilfreich sein, halten Sie bestimmte Geometrie sichtbar, selbst wenn es okkludierte ist, und klicken Sie zum Ändern der Darstellung, wenn Sie als eine Möglichkeit zum Bereitstellen von visuellem Feedback an den Benutzer okkludiert.</span><span class="sxs-lookup"><span data-stu-id="01867-286">However, it may be useful to keep certain geometry visible even when it is occluded, and to modify its appearance when occluded as a way of providing visual feedback to the user.</span></span> <span data-ttu-id="01867-287">Dies ermöglicht beispielsweise die Anwendung so, dass der Benutzer den Speicherort eines Objekts während deutlich, dass vornehmen hinter einer echten-Oberfläche.</span><span class="sxs-lookup"><span data-stu-id="01867-287">For example, this allows the application to show the user the location of an object whilst making it clear that is behind a real-world surface.</span></span>
   * <span data-ttu-id="01867-288">Rendern Sie die Geometrie zu diesem Zweck ein zweites Mal mit einen anderen Shader, der die gewünschte 'occluded' Darstellung erstellt.</span><span class="sxs-lookup"><span data-stu-id="01867-288">To achieve this, render the geometry a second time with a different shader that creates the desired 'occluded' appearance.</span></span> <span data-ttu-id="01867-289">Stellen Sie vor dem Rendern der geometriepunktwerts zum zweiten Mal, zwei Änderungen an Ihrer [Status der tiefenschablone](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx).</span><span class="sxs-lookup"><span data-stu-id="01867-289">Before rendering the geometry for the second time, make two changes to your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx).</span></span> <span data-ttu-id="01867-290">Legen Sie zunächst die tiefenfunktion auf "größer als oder gleich", damit die Geometrie angezeigt werden, wo es nur ist **Weiter** von der Kamera als alle zuvor gerenderte Geometrie.</span><span class="sxs-lookup"><span data-stu-id="01867-290">First, set the depth function to "greater than or equal" so that the geometry will be visible only where it is **further** from the camera than all previously rendered geometry.</span></span> <span data-ttu-id="01867-291">Die DepthWriteMask andererseits auf 0 (null), festgelegt wird, sodass der Tiefenpuffer nicht geändert wird (der Tiefenpuffer sollten weiterhin die Tiefe der Geometrie darstellen **nächstgelegenen** bis zur Kamera).</span><span class="sxs-lookup"><span data-stu-id="01867-291">Second, set the DepthWriteMask to zero, so that the depth buffer will not be modified (the depth buffer should continue to represent the depth of the geometry **closest** to the camera).</span></span>

<span data-ttu-id="01867-292">[Leistung](understanding-performance-for-mixed-reality.md) ist ein wichtiger Aspekt, beim Rendern der Gitter für räumliche Zuordnung.</span><span class="sxs-lookup"><span data-stu-id="01867-292">[Performance](understanding-performance-for-mixed-reality.md) is an important concern when rendering spatial mapping meshes.</span></span> <span data-ttu-id="01867-293">Hier sind einige Techniken der Rendering-Leistung für das Rendern der Gitter für räumliche Zuordnung spezifisch:</span><span class="sxs-lookup"><span data-stu-id="01867-293">Here are some rendering performance techniques specific to rendering spatial mapping meshes:</span></span>
* <span data-ttu-id="01867-294">Passen Sie Dreieck Dichte</span><span class="sxs-lookup"><span data-stu-id="01867-294">Adjust triangle density</span></span>
   * <span data-ttu-id="01867-295">Beim anfordernden räumliche Fläche aus Ihrem Surface Beobachter z. B. Gitter, fordern Sie die niedrigste Dichte an Dreieckgitter, die für Ihre Anforderungen ausreicht.</span><span class="sxs-lookup"><span data-stu-id="01867-295">When requesting spatial surface meshes from your surface observer, request the lowest density of triangle meshes that will suffice for your needs.</span></span>
   * <span data-ttu-id="01867-296">Es möglicherweise sinnvoll, Dreieck-Dichte auf einer Oberfläche von Surface-Basis, abhängig von der Oberfläche der Entfernung des Benutzers, variieren und ihrer Relevanz für die benutzerfreundlichkeit.</span><span class="sxs-lookup"><span data-stu-id="01867-296">It may make sense to vary triangle density on a surface by surface basis, depending on the surface's distance from the user, and its relevance to the user experience.</span></span>
   * <span data-ttu-id="01867-297">Verringern Dreieck Anzahl reduziert speicherauslastung und Vertex-Verarbeitungskosten in der GPU, obwohl es nicht pixelverarbeitung Kosten auswirkt.</span><span class="sxs-lookup"><span data-stu-id="01867-297">Reducing triangle counts will reduce memory usage and vertex processing costs on the GPU, though it will not affect pixel processing costs.</span></span>
* <span data-ttu-id="01867-298">Führen Sie Frustums culling</span><span class="sxs-lookup"><span data-stu-id="01867-298">Perform frustum culling</span></span>
   * <span data-ttu-id="01867-299">Frustums culling überspringt Zeichnungsobjekte, die nicht sichtbar ist, da sie außerhalb der aktuellen Anzeige Frustums sind.</span><span class="sxs-lookup"><span data-stu-id="01867-299">Frustum culling skips drawing objects that cannot be seen because they are outside the current display frustum.</span></span> <span data-ttu-id="01867-300">Dies reduziert die Kosten für die Verarbeitung von CPU- und GPU.</span><span class="sxs-lookup"><span data-stu-id="01867-300">This reduces both CPU and GPU processing costs.</span></span>
   * <span data-ttu-id="01867-301">Da culling auf einer pro-Mesh-Basis erfolgt und räumliche Flächen groß sein können, wichtige jedes räumlichen Oberfläche Gitter in kleinere Blöcke in eine effizientere culling möglicherweise (werden also weniger außerhalb des Bildschirms Dreiecke dargestellt werden).</span><span class="sxs-lookup"><span data-stu-id="01867-301">Since culling is performed on a per-mesh basis and spatial surfaces can be large, breaking each spatial surface mesh into smaller chunks may result in more efficient culling (in that fewer offscreen triangles are rendered).</span></span> <span data-ttu-id="01867-302">Es gibt jedoch ein Kompromiss, die Weitere Gitter, was man, weitere zeichnen, die Sie treffen müssen, die CPU-Kosten erhöhen können.</span><span class="sxs-lookup"><span data-stu-id="01867-302">There is a tradeoff, however; the more meshes you have, the more draw calls you must make, which can increase CPU costs.</span></span> <span data-ttu-id="01867-303">In Extremfällen kann die Berechnungen selbst culling Frustums sogar messbare CPU-Kosten aufweisen.</span><span class="sxs-lookup"><span data-stu-id="01867-303">In an extreme case, the frustum culling calculations themselves could even have a measurable CPU cost.</span></span>
* <span data-ttu-id="01867-304">Anpassen von Rendering-Reihenfolge</span><span class="sxs-lookup"><span data-stu-id="01867-304">Adjust rendering order</span></span>
   * <span data-ttu-id="01867-305">Räumliche Flächen tendenziell groß sein, da sie die gesamte benutzerumgebung Umschließung darstellen.</span><span class="sxs-lookup"><span data-stu-id="01867-305">Spatial surfaces tend to be large, because they represent the user's entire environment surrounding them.</span></span> <span data-ttu-id="01867-306">Pixel, die Verarbeitung von Kosten auf der GPU möglich so hoch sein, insbesondere in Fällen, wenn mehr als einer Ebene Geometry-Instanz angezeigt (einschließlich räumliche Flächen und andere Hologramme) vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="01867-306">Pixel processing costs on the GPU can thus be high, especially in cases where there is more than one layer of visible geometry (including both spatial surfaces and other holograms).</span></span> <span data-ttu-id="01867-307">In diesem Fall wird die Ebene am ehesten entsprechen der Benutzer alle Ebenen weiter, occluding werden also GPU Zeit Rendern dieser mehr entfernten Stufen verschwendet wird.</span><span class="sxs-lookup"><span data-stu-id="01867-307">In this case, the layer nearest to the user will be occluding any layers further away, so any GPU time spent rendering those more distant layers is wasted.</span></span>
   * <span data-ttu-id="01867-308">Um diese redundanter Arbeitsschritte auf dem GPU zu reduzieren, ist es hilfreich, um nicht transparente Oberflächen in der Reihenfolge von vorne nach hinten zu rendern (näher zu erste, mehr entfernte diejenigen letzte).</span><span class="sxs-lookup"><span data-stu-id="01867-308">To reduce this redundant work on the GPU, it helps to render opaque surfaces in front-to-back order (closer ones first, more distant ones last).</span></span> <span data-ttu-id="01867-309">Von "deckend" meinen wir Flächen, die für die die DepthWriteMask, zu einem in festgelegt ist Ihr [Status der tiefenschablone](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx).</span><span class="sxs-lookup"><span data-stu-id="01867-309">By 'opaque' we mean surfaces for which the DepthWriteMask is set to one in your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx).</span></span> <span data-ttu-id="01867-310">Wenn die nächsten Oberflächen gerendert werden, werden sie den Tiefenpuffer vorzubereiten, damit mehr entfernte Flächen auf der GPU effizienter vom Prozessor Pixel übersprungen werden.</span><span class="sxs-lookup"><span data-stu-id="01867-310">When the nearest surfaces are rendered, they will prime the depth buffer so that more distant surfaces are efficiently skipped by the pixel processor on the GPU.</span></span>

## <a name="mesh-processing"></a><span data-ttu-id="01867-311">Mesh-Verarbeitung</span><span class="sxs-lookup"><span data-stu-id="01867-311">Mesh Processing</span></span>

<span data-ttu-id="01867-312">Eine Anwendung ausführen möchten [verschiedene Vorgänge](spatial-mapping.md#mesh-processing) auf räumliche Oberfläche Gitter, an die individuellen Anforderungen anzupassen.</span><span class="sxs-lookup"><span data-stu-id="01867-312">An application may want to perform [various operations](spatial-mapping.md#mesh-processing) on spatial surface meshes to suit its needs.</span></span> <span data-ttu-id="01867-313">Die Index- und Vertexdaten Daten, die im Lieferumfang jedes räumlichen Oberfläche Gitter verwendet das gleiche vertraute Layout wie die [Vertex- und Indexpuffer](https://msdn.microsoft.com/library/windows/desktop/bb147325%28v=vs.85%29.aspx) , die für das Rendern von Dreieckgitter in allen modernen-Rendering-APIs verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="01867-313">The index and vertex data provided with each spatial surface mesh uses the same familiar layout as the [vertex and index buffers](https://msdn.microsoft.com/library/windows/desktop/bb147325%28v=vs.85%29.aspx) that are used for rendering triangle meshes in all modern rendering APIs.</span></span> <span data-ttu-id="01867-314">Eine wichtige Tatsache zu berücksichtigen ist jedoch, dass die räumliche Zuordnung Dreiecke haben eine **Front Uhrzeigersinn Wicklung Reihenfolge**.</span><span class="sxs-lookup"><span data-stu-id="01867-314">However, one key fact to be aware of is that spatial mapping triangles have a **front-clockwise winding order**.</span></span> <span data-ttu-id="01867-315">Jedes Dreiecks wird durch drei Vertex Indizes des Gitters Indexpuffer dargestellt, und diese Indizes erkennt die dreieckvertices in einer **im Uhrzeigersinn** Reihenfolge, wenn das Dreieck angezeigt wird, aus der **Front** Seite.</span><span class="sxs-lookup"><span data-stu-id="01867-315">Each triangle is represented by three vertex indices in the mesh's index buffer and these indices will identify the triangle's vertices in a **clockwise** order, when the triangle is viewed from the **front** side.</span></span> <span data-ttu-id="01867-316">Im Vordergrund Seite (oder außerhalb) von räumlichen Oberfläche Netzen entspricht, wie auf die Vorderseite der realen Welt Flächen (sichtbar gewünscht).</span><span class="sxs-lookup"><span data-stu-id="01867-316">The front side (or outside) of spatial surface meshes corresponds as you would expect to the front (visible) side of real world surfaces.</span></span>

<span data-ttu-id="01867-317">Anwendungen sollten nur ausführen, Mesh-Vereinfachung, ob die gröbsten Dreieck Dichte, die von der Oberfläche Beobachter bereitgestellten weiterhin unzureichend grob gehalten ist diese Arbeit sehr viel rechenleistung beanspruchen und von der Laufzeit zum Generieren der verschiedenen bereits ausgeführt wird Detailebenen wird bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="01867-317">Applications should only perform mesh simplification if the coarsest triangle density provided by the surface observer is still insufficiently coarse - this work is computationally expensive and already being performed by the runtime to generate the various provided levels of detail.</span></span>

<span data-ttu-id="01867-318">Da jede Oberfläche Beobachter mehrere unverbundene räumliche Flächen bereitstellen kann, einige Anwendungen möglicherweise möchten Sie diese räumliche clip-Oberfläche, Gitter für jede andere, klicken Sie dann Reißverschluss sie zusammen.</span><span class="sxs-lookup"><span data-stu-id="01867-318">Because each surface observer can provide multiple unconnected spatial surfaces, some applications may wish to clip these spatial surface meshes against each other, then zipper them together.</span></span> <span data-ttu-id="01867-319">Im Allgemeinen ist der Clipping-Schritt erforderlich ist, wie in der Nähe räumliche Oberfläche Gitter häufig etwas überlappen.</span><span class="sxs-lookup"><span data-stu-id="01867-319">In general, the clipping step is required, as nearby spatial surface meshes often overlap slightly.</span></span>

## <a name="raycasting-and-collision"></a><span data-ttu-id="01867-320">Feinheiten beim Raycasting und Kollisionserkennung</span><span class="sxs-lookup"><span data-stu-id="01867-320">Raycasting and Collision</span></span>

<span data-ttu-id="01867-321">In der Reihenfolge für eine Physik-API (z. B. [Havok](http://www.havok.com/)) um eine Anwendung mit den feinheiten beim Raycasting und kollisionserkennung Funktionen für räumliche Oberflächen zu gewährleisten, muss die Anwendung bereitstellen, räumliche Oberfläche vernetzt werden, um die Physik-API.</span><span class="sxs-lookup"><span data-stu-id="01867-321">In order for a physics API (such as [Havok](http://www.havok.com/)) to provide an application with raycasting and collision functionality for spatial surfaces, the application must provide spatial surface meshes to the physics API.</span></span> <span data-ttu-id="01867-322">Gitter, die häufig für Physik verwendet haben, die folgenden Eigenschaften:</span><span class="sxs-lookup"><span data-stu-id="01867-322">Meshes used for physics often have the following properties:</span></span>
* <span data-ttu-id="01867-323">Sie enthalten nur kleine Anzahl von Dreiecken.</span><span class="sxs-lookup"><span data-stu-id="01867-323">They contain only small numbers of triangles.</span></span> <span data-ttu-id="01867-324">Physik-Vorgänge sind mehr als Renderingvorgänge rechenintensiv.</span><span class="sxs-lookup"><span data-stu-id="01867-324">Physics operations are more computationally intensive than rendering operations.</span></span>
* <span data-ttu-id="01867-325">Sie sind "Water – strenge".</span><span class="sxs-lookup"><span data-stu-id="01867-325">They are 'water-tight'.</span></span> <span data-ttu-id="01867-326">Flächen, die als solid müssen nicht kleine aufweisen; sogar Löcher zu klein angezeigt werden, können Probleme verursachen.</span><span class="sxs-lookup"><span data-stu-id="01867-326">Surfaces intended to be solid should not have small holes in them; even holes too small to be visible can cause problems.</span></span>
* <span data-ttu-id="01867-327">Sie werden in konvexe Schälkleie konvertiert.</span><span class="sxs-lookup"><span data-stu-id="01867-327">They are converted into convex hulls.</span></span> <span data-ttu-id="01867-328">Konvexe Schälkleie haben einige Polygone und frei von Lücken, und sie sind viel besser rechnerisch effizient verarbeiten als unformatierte Dreieck Gitter.</span><span class="sxs-lookup"><span data-stu-id="01867-328">Convex hulls have few polygons and are free of holes, and they are much more computationally efficient to process than raw triangle meshes.</span></span>

<span data-ttu-id="01867-329">Bei der Durchführung Raycasts für räumliche Oberflächen, beachten Sie, dass diese Oberflächen häufig komplex sind, wie überladen Formen unübersichtliche kleinen Details - nur vollständige Helpdesk!</span><span class="sxs-lookup"><span data-stu-id="01867-329">When performing raycasts against spatial surfaces, bear in mind that these surfaces are often complex, cluttered shapes full of messy little details - just like your desk!</span></span> <span data-ttu-id="01867-330">Dies bedeutet, dass eine einzelne Raycast häufig nicht ausreichend, um Sie genügend Informationen zur Form der Fläche und die Form der freie Speicherplatz in der Nähe erteilen.</span><span class="sxs-lookup"><span data-stu-id="01867-330">This means that a single raycast is often insufficient to give you enough information about the shape of the surface and the shape of the empty space near it.</span></span> <span data-ttu-id="01867-331">Es ist daher in der Regel eine gute Idee, viele Raycasts in einem kleinen Bereich durchzuführen und die aggregierten Ergebnisse zu verwenden, um einen Überblick über die Oberfläche des zuverlässiger abgeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="01867-331">It is thus usually a good idea to perform many raycasts within a small area and to use the aggregate results to derive a more reliable understanding of the surface.</span></span> <span data-ttu-id="01867-332">Z. B. ergibt Guide – Hologramm Platzierung auf einer Oberfläche mit den Mittelwert der 10 Raycasts weit reibungslose und weniger "ganz nervös" Ergebnis mit nur einem einzigen Raycast.</span><span class="sxs-lookup"><span data-stu-id="01867-332">For example, using the average of 10 raycasts to guide hologram placement on a surface will yield a far smoother and less 'jittery' result that using just a single raycast.</span></span>

<span data-ttu-id="01867-333">Allerdings beachten Sie, dass jede Raycast hohe rechenleistung Kosten verwenden kann.</span><span class="sxs-lookup"><span data-stu-id="01867-333">However, bear in mind that each raycast can have a high computational cost.</span></span> <span data-ttu-id="01867-334">Also je nach Nutzungsszenario Sie sollten eine Abstimmung zwischen Rechenaufwand für zusätzliche Raycasts (jedes Einzelbild ausgeführt) für den Rechenaufwand für [mesh-Verarbeitung](spatial-mapping.md#mesh-processing) zu glätten und Entfernen von Lücken in räumlichen Oberflächen ( ausgeführt, wenn räumliche Gitter aktualisiert werden).</span><span class="sxs-lookup"><span data-stu-id="01867-334">Thus depending on your usage scenario you should trade off the computational cost of additional raycasts (performed every frame) against the computational cost of [mesh processing](spatial-mapping.md#mesh-processing) to smooth and remove holes in spatial surfaces (performed when spatial meshes are updated).</span></span>

## <a name="troubleshooting"></a><span data-ttu-id="01867-335">Problembehandlung</span><span class="sxs-lookup"><span data-stu-id="01867-335">Troubleshooting</span></span>
* <span data-ttu-id="01867-336">Damit für die Oberfläche Gitter ordnungsgemäß ausgerichtete werden kann muss jede "gameobject" aktiv sein, bevor sie an der SurfaceObeserver gesendet werden, die Gitter erstellt haben.</span><span class="sxs-lookup"><span data-stu-id="01867-336">In order for the surface meshes to be orientated correctly, each GameObject needs to be active before it is sent to the SurfaceObeserver to have its mesh constructed.</span></span> <span data-ttu-id="01867-337">Andernfalls werden die Gitter in Ihrem Bereich jedoch gedreht merkwürdige Winkel angezeigt.</span><span class="sxs-lookup"><span data-stu-id="01867-337">Otherwise, the meshes will show up in your space but rotated at weird angles.</span></span>
* <span data-ttu-id="01867-338">Das "gameobject", das führt das Skript, mit das kommuniziert mit dem SurfaceObserver muss an den Ursprung festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="01867-338">The GameObject that runs the script that communicates with the SurfaceObserver needs to be set to the origin.</span></span> <span data-ttu-id="01867-339">Andernfalls müssen alle "gameobjects", die Sie erstellen und Senden an der SurfaceObserver, damit ihre Gitter erstellt einen Offset, der gleich dem Offset des übergeordneten Objekts Spiel.</span><span class="sxs-lookup"><span data-stu-id="01867-339">Otherwise, all of GameObjects that you create and send to the SurfaceObserver to have their meshes constructed will have an offset equal to the offset of the Parent Game Object.</span></span> <span data-ttu-id="01867-340">Dadurch können Ihre Gitter, mehrere Zähler sofort wodurch es schwierig zu debuggen, was vor sich geht angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="01867-340">This can make your meshes show up several meters away which makes it very hard to debug what is going on.</span></span>

## <a name="see-also"></a><span data-ttu-id="01867-341">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="01867-341">See also</span></span>
* [<span data-ttu-id="01867-342">Koordinatensysteme</span><span class="sxs-lookup"><span data-stu-id="01867-342">Coordinate systems</span></span>](coordinate-systems.md)
* [<span data-ttu-id="01867-343">Räumliche Zuordnung in DirectX</span><span class="sxs-lookup"><span data-stu-id="01867-343">Spatial mapping in DirectX</span></span>](spatial-mapping-in-directx.md)
* [<span data-ttu-id="01867-344">Räumliche Zuordnung in Unity</span><span class="sxs-lookup"><span data-stu-id="01867-344">Spatial mapping in Unity</span></span>](spatial-mapping-in-unity.md)
* [<span data-ttu-id="01867-345">Räumliche Zuordnung entwerfen</span><span class="sxs-lookup"><span data-stu-id="01867-345">Spatial mapping design</span></span>](spatial-mapping-design.md)
* [<span data-ttu-id="01867-346">Fallstudie: Lücken in der Realität ansehen</span><span class="sxs-lookup"><span data-stu-id="01867-346">Case study - Looking through holes in your reality</span></span>](case-study-looking-through-holes-in-your-reality.md)
