---
title: Grundlegendes zur Leistung für gemischte Realität
description: Erweiterte Themen und Details zur Optimierung der Leistung für Windows Mixed Reality-apps
author: Troy-Ferrell
ms.author: trferrel
ms.date: 3/26/2019
ms.topic: article
keywords: Gemischte Windows-Realität, gemischte Realität, Virtual Reality, VR, Mr, Leistung, Optimierung, CPU, GPU
ms.openlocfilehash: ce59f9023c21dc7c981a2bb97d9fbd0c57622dbf
ms.sourcegitcommit: 915d3cc63a5571ba22ac4608589f3eca8da1bc81
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 04/24/2019
ms.locfileid: "63548841"
---
# <a name="understanding-performance-for-mixed-reality"></a><span data-ttu-id="a348f-104">Grundlegendes zur Leistung für gemischte Realität</span><span class="sxs-lookup"><span data-stu-id="a348f-104">Understanding performance for mixed reality</span></span>

<span data-ttu-id="a348f-105">Dieser Artikel ist eine Einführung in die Rationalisierung der Bedeutung der Leistung für ihre gemischte Reality-app.</span><span class="sxs-lookup"><span data-stu-id="a348f-105">This article is an introduction into rationalizing the significance of performance for your Mixed Reality app.</span></span>  <span data-ttu-id="a348f-106">Die Benutzer Leistung kann erheblich beeinträchtigt werden, wenn Ihre Anwendung nicht mit optimaler Framerate ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="a348f-106">User experience can be greatly degraded if your application does not run at optimal frame rate.</span></span> <span data-ttu-id="a348f-107">Holograms werden instabil angezeigt, und die Kopf Nachverfolgung der Umgebung ist ungenau, was zu einer mangelnden Benutzerumgebung führt.</span><span class="sxs-lookup"><span data-stu-id="a348f-107">Holograms will appear unstable and head tracking of the environment will be inaccurate leading to an poor experience for the user.</span></span> <span data-ttu-id="a348f-108">Tatsächlich muss die Leistung als First-Class-Feature für die Entwicklung gemischter Realität und nicht für eine Stabilisierung-, Ende-zu-Ende-Aufgabe angesehen werden.</span><span class="sxs-lookup"><span data-stu-id="a348f-108">Indeed, performance must be considered as a first class feature for Mixed Reality development and not a stabilization, end of cycle task.</span></span>

<span data-ttu-id="a348f-109">Zur Überprüfung werden die leistungsstarken Framerate-Werte für jede Zielplattform unten aufgeführt.</span><span class="sxs-lookup"><span data-stu-id="a348f-109">For review, the performant framerate values for each target platform are listed below.</span></span>

| <span data-ttu-id="a348f-110">Platform</span><span class="sxs-lookup"><span data-stu-id="a348f-110">Platform</span></span> | <span data-ttu-id="a348f-111">Zielframe Rate</span><span class="sxs-lookup"><span data-stu-id="a348f-111">Target Frame Rate</span></span> |
|----------|-------------------|
| [<span data-ttu-id="a348f-112">HoloLens</span><span class="sxs-lookup"><span data-stu-id="a348f-112">HoloLens</span></span>](hololens-hardware-details.md) | <span data-ttu-id="a348f-113">60 FPS</span><span class="sxs-lookup"><span data-stu-id="a348f-113">60 FPS</span></span> |
| [<span data-ttu-id="a348f-114">Windows Mixed Reality Ultra PCs</span><span class="sxs-lookup"><span data-stu-id="a348f-114">Windows Mixed Reality Ultra PCs</span></span>](immersive-headset-hardware-details.md) | <span data-ttu-id="a348f-115">90 FPS</span><span class="sxs-lookup"><span data-stu-id="a348f-115">90 FPS</span></span> |
| [<span data-ttu-id="a348f-116">Windows Mixed Reality-PCs</span><span class="sxs-lookup"><span data-stu-id="a348f-116">Windows Mixed Reality PCs</span></span>](immersive-headset-hardware-details.md) | <span data-ttu-id="a348f-117">60 FPS</span><span class="sxs-lookup"><span data-stu-id="a348f-117">60 FPS</span></span> |

<span data-ttu-id="a348f-118">Das unten stehende Framework bietet eine allgemeine Übersicht über bewährte Methoden und Erkenntnisse zum Erreichen von Ziel Frameraten.</span><span class="sxs-lookup"><span data-stu-id="a348f-118">The framework below gives a general outline for best practices and understandings towards hitting target frame rates.</span></span> <span data-ttu-id="a348f-119">Weitere Informationen zu den Details finden Sie im [Artikel Leistungs Empfehlungen für Unity](performance-recommendations-for-unity.md).</span><span class="sxs-lookup"><span data-stu-id="a348f-119">To dive further into details, consider reading the [performance recommendations for Unity article](performance-recommendations-for-unity.md).</span></span> <span data-ttu-id="a348f-120">Insbesondere wird in diesem Artikel erläutert, wie Sie die Framerate in ihrer Unity Windows Mixed Reality-App Messen und welche Schritte in der Unity-Umgebung ausgeführt werden müssen, um die Leistung zu verbessern.</span><span class="sxs-lookup"><span data-stu-id="a348f-120">In particular, this related article will discuss how to measure framerate in your Unity Windows Mixed Reality app as well as steps to take in the Unity environment to improve performance.</span></span>

## <a name="understanding-performance-bottlenecks"></a><span data-ttu-id="a348f-121">Grundlegendes zu Leistungs Engpässen</span><span class="sxs-lookup"><span data-stu-id="a348f-121">Understanding performance bottlenecks</span></span>

<span data-ttu-id="a348f-122">Wenn Ihre APP einen leistungsstarken Framerate hat, besteht der erste Schritt darin, zu analysieren und zu verstehen, wo Ihre Anwendung Rechen intensiv ist.</span><span class="sxs-lookup"><span data-stu-id="a348f-122">If your app has an underperforming framerate, the first step is to analyze and understand where your application is computationally intensive.</span></span> <span data-ttu-id="a348f-123">Es gibt zwei primäre Prozessoren, die für die Arbeit zum Rendering Ihrer Szene verantwortlich sind: die CPU und die GPU.</span><span class="sxs-lookup"><span data-stu-id="a348f-123">There are two primary processors responsible for the work to render your scene: the CPU and the GPU.</span></span> <span data-ttu-id="a348f-124">Jede dieser beiden Komponenten verarbeitet verschiedene Vorgänge und Phasen ihrer Mixed Reality-app.</span><span class="sxs-lookup"><span data-stu-id="a348f-124">Each of these two components handle different operations and stages of your Mixed Reality app.</span></span> <span data-ttu-id="a348f-125">Es gibt drei wichtige Orte, an denen Engpässe auftreten können.</span><span class="sxs-lookup"><span data-stu-id="a348f-125">There are three key places where bottlenecks may occur.</span></span> 

1. <span data-ttu-id="a348f-126">**App-Thread-CPU** : dieser Thread ist für Ihre APP-Logik verantwortlich.</span><span class="sxs-lookup"><span data-stu-id="a348f-126">**App Thread - CPU** - This thread is responsible for your app logic.</span></span> <span data-ttu-id="a348f-127">Dies umfasst die Verarbeitung von Eingaben, Animationen, Physik und anderen APP-Logik/-Zuständen.</span><span class="sxs-lookup"><span data-stu-id="a348f-127">This includes processing input, animations, physics, and other app logic/state</span></span>
2. <span data-ttu-id="a348f-128">**Thread-CPU zu GPU rentieren** : dieser Thread ist für das übermitteln der Draw-Aufrufe an die GPU verantwortlich.</span><span class="sxs-lookup"><span data-stu-id="a348f-128">**Render Thread - CPU to GPU** - This thread is responsible for submitting your draw calls to the GPU.</span></span> <span data-ttu-id="a348f-129">Wenn Ihre APP ein Objekt (z. b. einen Cube oder ein Modell) rendern möchte, sendet dieser Thread eine Anforderung an die GPU, die über eine für das Rendering optimierte Architektur verfügt, um diese Vorgänge auszuführen.</span><span class="sxs-lookup"><span data-stu-id="a348f-129">When your app wants to render an object such as a cube or model, this thread sends a request to the GPU, which has an architecture optimized for rendering, to perform these operations.</span></span>
3. <span data-ttu-id="a348f-130">**GPU** - 
    Dieser Prozessor verarbeitet am häufigsten die Grafik Pipeline Ihrer Anwendung, um 3D-Daten (Modelle, Texturen usw.) in Pixel umzuwandeln, und erzeugt schließlich ein 2D-Bild, das an den Bildschirm Ihres Geräts gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="a348f-130">**GPU** - 
 This processor most commonly handles the graphics pipeline of your application to transform 3D data (models, textures, etc) into pixels and ultimately produce a 2D image to submit to your device's screen.</span></span>

![Lebensdauer eines Frames](images/lifetime-of-a-frame.png)

<span data-ttu-id="a348f-132">Im Allgemeinen werden hololens-Anwendungen an GPU gebunden.</span><span class="sxs-lookup"><span data-stu-id="a348f-132">Generally, HoloLens applications will be GPU bounded.</span></span> <span data-ttu-id="a348f-133">Dies gilt jedoch nicht für jede Anwendung. Daher wird empfohlen, die Tools & Techniken unten zu verwenden, um die grundlegenden Informationen für Ihre APP zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="a348f-133">However, this does not hold true in every application and thus it is recommended to use the tools & techniques below to get to ground-truth for your particular app.</span></span>

## <a name="how-to-analyze-your-application"></a><span data-ttu-id="a348f-134">Analysieren der Anwendung</span><span class="sxs-lookup"><span data-stu-id="a348f-134">How to analyze your application</span></span>

<span data-ttu-id="a348f-135">Es gibt viele Tools, mit denen Sie als Entwickler das Leistungsprofil Ihrer gemischten Reality-Anwendung verstehen können.</span><span class="sxs-lookup"><span data-stu-id="a348f-135">There are many tools that allow you as a developer to understand the performance profile of your Mixed Reality application.</span></span> <span data-ttu-id="a348f-136">Diese ermöglichen es Ihnen, sowohl für Engpässe als auch für das Debuggen zu dienen.</span><span class="sxs-lookup"><span data-stu-id="a348f-136">These will enable you to both target where you have bottlenecks and how they are manifesting themselves to debug them.</span></span>

<span data-ttu-id="a348f-137">Dies ist eine Liste beliebter und leistungsfähiger Tools, mit denen Sie umfassende Profil Erstellungs Informationen für Ihre Anwendung erhalten.</span><span class="sxs-lookup"><span data-stu-id="a348f-137">This is a list of popular and powerful tools to gain deep profiling information for your application.</span></span>
- [<span data-ttu-id="a348f-138">Intel Graphics Performance Analyzer</span><span class="sxs-lookup"><span data-stu-id="a348f-138">Intel Graphics Performance Analyzers</span></span>](https://software.intel.com/gpa)
- [<span data-ttu-id="a348f-139">Visual Studio-Grafik-Debuggers</span><span class="sxs-lookup"><span data-stu-id="a348f-139">Visual Studio Graphics Debuggers</span></span>](https://docs.microsoft.com/visualstudio/debugger/graphics/visual-studio-graphics-diagnostics?view=vs-2017)
- [<span data-ttu-id="a348f-140">Unity-Profiler</span><span class="sxs-lookup"><span data-stu-id="a348f-140">Unity Profiler</span></span>](https://docs.unity3d.com/Manual/Profiler.html)
- [<span data-ttu-id="a348f-141">Unity-Frame Debugger</span><span class="sxs-lookup"><span data-stu-id="a348f-141">Unity Frame Debugger</span></span>](https://docs.unity3d.com/Manual/FrameDebugger.html)

### <a name="how-to-profile-in-any-environment"></a><span data-ttu-id="a348f-142">Profilerstellung in einer beliebigen Umgebung</span><span class="sxs-lookup"><span data-stu-id="a348f-142">How to profile in any environment</span></span>

<span data-ttu-id="a348f-143">Es gibt einen einfachen Test, mit dem Sie schnell feststellen können, ob Sie in Ihrer Anwendung wahrscheinlich eine GPU-Grenze oder eine CPU-Begrenzung</span><span class="sxs-lookup"><span data-stu-id="a348f-143">There is a simple test to quickly determine if you are likely GPU bounded or CPU bounded in your application.</span></span> <span data-ttu-id="a348f-144">Wenn Sie die Auflösung der Ausgabe des Renderziels verringern, sind weniger Pixel zu berechnen und somit weniger Arbeit, die die GPU zum renderingabbild ausführen muss.</span><span class="sxs-lookup"><span data-stu-id="a348f-144">If you decrease the resolution of the render target output, there are less pixels to calculate and thus, less work the GPU needs to perform to render an image.</span></span> <span data-ttu-id="a348f-145">Die viewportskalierung (Skalierung dynamischer Lösungen) ist die Vorgehensweise, das Bild in ein kleineres Renderziel zu rendern, und das Ausgabegerät kann angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="a348f-145">Viewport scaling (dynamic resolution scaling) is the practice of rendering your image to a smaller render target then your output device can display.</span></span> <span data-ttu-id="a348f-146">Das Gerät wird aus dem kleineren Satz von Pixeln hochskalieren, um das endgültige Bild anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="a348f-146">The device will up-sample from the smaller set of pixels to display your final image.</span></span>

<span data-ttu-id="a348f-147">Nach dem verringern der renderinglösung:</span><span class="sxs-lookup"><span data-stu-id="a348f-147">After decreasing rendering resolution, if:</span></span>
1) <span data-ttu-id="a348f-148">Anwendungs Framerate **erhöht**sich, dann ist die **GPU wahrscheinlich begrenzt**</span><span class="sxs-lookup"><span data-stu-id="a348f-148">Application framerate **increases**, then you are likely **GPU Bounded**</span></span>
1) <span data-ttu-id="a348f-149">Die Anwendungs Framerate ist **unverändert**, und Sie sind wahrscheinlich **CPU-gebunden** .</span><span class="sxs-lookup"><span data-stu-id="a348f-149">Application framerate **unchanged**, then you are likely **CPU Bounded**</span></span>

>[!NOTE]
><span data-ttu-id="a348f-150">Unity bietet die Möglichkeit, die renderzielauflösung Ihrer Anwendung zur Laufzeit mithilfe der *[xrsettings. renderviewportscale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* -Eigenschaft problemlos zu ändern.</span><span class="sxs-lookup"><span data-stu-id="a348f-150">Unity provides the ability to easily modify the render target resolution of your application at runtime through the *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* property.</span></span> <span data-ttu-id="a348f-151">Das endgültige Bild, das auf dem Gerät angezeigt wird, hat eine Fehlerbehebung.</span><span class="sxs-lookup"><span data-stu-id="a348f-151">The final image presented on device has a fixed resolution.</span></span> <span data-ttu-id="a348f-152">Die Plattform zeigt eine Stichprobe der Ausgabe mit niedrigerer Auflösung an, um ein höheres Auflösungs Bild für das Rendering in anzeigen zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="a348f-152">The platform will sample the lower resolution output to build a higher resolution image for rendering on displays.</span></span> 
>
>```CS
>UnityEngine.XR.XRSettings.renderScale = 0.7f;
>```

## <a name="how-to-improve-your-application"></a><span data-ttu-id="a348f-153">So verbessern Sie Ihre Anwendung</span><span class="sxs-lookup"><span data-stu-id="a348f-153">How to improve your application</span></span>

### <a name="cpu-performance-recommendations"></a><span data-ttu-id="a348f-154">Empfehlungen zur CPU-Leistung</span><span class="sxs-lookup"><span data-stu-id="a348f-154">CPU performance recommendations</span></span>

<span data-ttu-id="a348f-155">Im allgemeinen umfasst die meiste Arbeit in einer gemischten Reality-Anwendung auf der CPU das Ausführen der Simulation der Szene und die Verarbeitung umfangreicher eindeutiger Anwendungslogik.</span><span class="sxs-lookup"><span data-stu-id="a348f-155">Generally, most work in a mixed reality application on the CPU involves performing the "simulation" of the scene and processing extensive unique application logic.</span></span> <span data-ttu-id="a348f-156">Daher sind die folgenden Bereiche in der Regel für die Optimierung bestimmt.</span><span class="sxs-lookup"><span data-stu-id="a348f-156">Thus, the following areas are usually targeted for optimization.</span></span>

- <span data-ttu-id="a348f-157">Animationen</span><span class="sxs-lookup"><span data-stu-id="a348f-157">Animations</span></span>
- <span data-ttu-id="a348f-158">Vereinfachen der Physik</span><span class="sxs-lookup"><span data-stu-id="a348f-158">Simplify Physics</span></span>
- <span data-ttu-id="a348f-159">Speicher Belegungen</span><span class="sxs-lookup"><span data-stu-id="a348f-159">Memory allocations</span></span>
- <span data-ttu-id="a348f-160">Komplexe Algorithmen (d. h.</span><span class="sxs-lookup"><span data-stu-id="a348f-160">Complex algorithms (i.e</span></span> <span data-ttu-id="a348f-161">umgekehrte Kinematik, Pfad Suche)</span><span class="sxs-lookup"><span data-stu-id="a348f-161">inverse kinematics, path-finding)</span></span>

### <a name="gpu-performance-recommendations"></a><span data-ttu-id="a348f-162">Empfehlungen zur GPU-Leistung</span><span class="sxs-lookup"><span data-stu-id="a348f-162">GPU performance recommendations</span></span>

#### <a name="understanding-bandwidth-vs-fill-rate"></a><span data-ttu-id="a348f-163">Grundlegendes zur Bandbreiten Vergleich</span><span class="sxs-lookup"><span data-stu-id="a348f-163">Understanding bandwidth vs fill rate</span></span>
<span data-ttu-id="a348f-164">Wenn ein Frame auf der GPU gerendert wird, wird eine Anwendung im Allgemeinen entweder durch die Arbeitsspeicher Bandbreite oder die Füllrate begrenzt.</span><span class="sxs-lookup"><span data-stu-id="a348f-164">When rendering a frame on the GPU, an application is generally either bounded by memory bandwidth or fill rate.</span></span>

- <span data-ttu-id="a348f-165">Die Arbeits **Speicherbandbreite** ist die Rate der Lese-und Schreibvorgänge, die die GPU aus dem Arbeitsspeicher</span><span class="sxs-lookup"><span data-stu-id="a348f-165">**Memory bandwidth** is the rate of reads and writes the GPU can perform from memory</span></span>
    - <span data-ttu-id="a348f-166">Um Bandbreiten Einschränkungen zu identifizieren, verringern Sie die Texturqualität und überprüfen, ob Framerate verbessert wurde.</span><span class="sxs-lookup"><span data-stu-id="a348f-166">To identify bandwidth limitations, reduce texture quality and check if framerate improved.</span></span>
    - <span data-ttu-id="a348f-167">In Unity kann dies durch Ändern der **Texturqualität** in "**Projekteinstellungen** >  **Bearbeiten** > " **[Qualitätseinstellungen](https://docs.unity3d.com/Manual/class-QualitySettings.html)** geändert werden.</span><span class="sxs-lookup"><span data-stu-id="a348f-167">In Unity, this can be done by changing **Texture Quality** in **Edit** > **Project Settings** > **[Quality Settings](https://docs.unity3d.com/Manual/class-QualitySettings.html)**.</span></span>
- <span data-ttu-id="a348f-168">**Füllrate** bezieht sich auf den Durchsatz gerenderter Pixel, die pro Sekunde von der GPU gezeichnet werden können.</span><span class="sxs-lookup"><span data-stu-id="a348f-168">**Fill rate** refers to the throughput of rendered pixels that can be drawn per second by the GPU.</span></span>
    - <span data-ttu-id="a348f-169">Um die Einschränkungen der Füllrate zu identifizieren, verringern Sie die Bildschirmauflösung, und prüfen Sie, ob Framerate verbessert wurde</span><span class="sxs-lookup"><span data-stu-id="a348f-169">To identify fill rate limitations, decrease the display resolution and check if framerate improved.</span></span> 
    - <span data-ttu-id="a348f-170">In Unity kann dies über die *[xrsettings. renderviewportscale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* -Eigenschaft erfolgen.</span><span class="sxs-lookup"><span data-stu-id="a348f-170">In Unity, this can be done via the  *[XRSettings.renderViewportScale](https://docs.unity3d.com/ScriptReference/XR.XRSettings-renderViewportScale.html)* property</span></span>

<span data-ttu-id="a348f-171">Die Speicherbandbreite umfasst in der Regel Optimierungen für</span><span class="sxs-lookup"><span data-stu-id="a348f-171">Memory bandwidth generally involves optimizations to either</span></span>
1) <span data-ttu-id="a348f-172">Verkleinern von Textur Auflösungen</span><span class="sxs-lookup"><span data-stu-id="a348f-172">decrease texture resolutions</span></span>
2) <span data-ttu-id="a348f-173">weniger Texturen verwenden (d. h.</span><span class="sxs-lookup"><span data-stu-id="a348f-173">utilize less textures (i.e</span></span> <span data-ttu-id="a348f-174">normale, Glanz usw.)</span><span class="sxs-lookup"><span data-stu-id="a348f-174">normals, specular, etc)</span></span>

<span data-ttu-id="a348f-175">Die Füllrate konzentriert sich hauptsächlich auf das Reduzieren der Anzahl von Vorgängen, die für ein letztes gerendertes Pixel berechnet werden müssen.</span><span class="sxs-lookup"><span data-stu-id="a348f-175">Fill rate is primarily focused on reducing the number of operations that need to be computed for a final rendered pixel.</span></span> <span data-ttu-id="a348f-176">Beispiele hierfür liegen häufig in der Reduzierung von</span><span class="sxs-lookup"><span data-stu-id="a348f-176">Examples of this commonly fall into reducing</span></span>
1) <span data-ttu-id="a348f-177">Anzahl der zu Rendering/zu verarbeitenden Objekte</span><span class="sxs-lookup"><span data-stu-id="a348f-177">number of objects to render/process</span></span>
2) <span data-ttu-id="a348f-178">Anzahl von Vorgängen pro Shader</span><span class="sxs-lookup"><span data-stu-id="a348f-178">number of operations per shader</span></span>
3) <span data-ttu-id="a348f-179">Anzahl von GPU-Phasen bis zum Endergebnis (Geometry-Shader, nach Verarbeitungs Effekte usw.)</span><span class="sxs-lookup"><span data-stu-id="a348f-179">number of GPU stages to final result (geometry shaders, post-processing effects, etc)</span></span>
4) <span data-ttu-id="a348f-180">Anzahl der zu Rendering enden Pixel (d. h.</span><span class="sxs-lookup"><span data-stu-id="a348f-180">number of pixels to render (i.e</span></span> <span data-ttu-id="a348f-181">Anzeige Auflösung)</span><span class="sxs-lookup"><span data-stu-id="a348f-181">display resolution)</span></span>

#### <a name="reduce-poly-count"></a><span data-ttu-id="a348f-182">Reduzieren der polyzahl</span><span class="sxs-lookup"><span data-stu-id="a348f-182">Reduce poly count</span></span>
<span data-ttu-id="a348f-183">Höhere Polygon Zahlen führen zu mehr Vorgängen für die GPU, und das Reduzieren der Anzahl von Polygonen in der Szene verringert die Zeitspanne, die für das Rendering der Geometrie gilt.</span><span class="sxs-lookup"><span data-stu-id="a348f-183">Higher polygon counts result in more operations for the GPU and reducing the number of polygons in your scene will reduce the amount of time to render that geometry.</span></span> <span data-ttu-id="a348f-184">Es gibt auch andere Faktoren, die bei der Schattierung der Geometrie zu berücksichtigen sind, die noch teuer sein kann, aber die Polygon Anzahl ist die Basis Metrik, um zu bestimmen, wie teuer eine Szene sein wird.</span><span class="sxs-lookup"><span data-stu-id="a348f-184">There are other factors involved as well in shading the geometry that can still be expensive but polygon count is the base metric to determine how expensive a scene will be to render.</span></span>

#### <a name="limit-overdraw"></a><span data-ttu-id="a348f-185">Limit überzeichnen</span><span class="sxs-lookup"><span data-stu-id="a348f-185">Limit overdraw</span></span>

<span data-ttu-id="a348f-186">Eine hohe Überschreibung tritt auf, wenn mehrere Objekte gerendert werden, aber nicht auf dem Bildschirm ausgegeben werden, da Sie von einem anderen, in der Regel engeren, nicht aufgeblendeten Objekt</span><span class="sxs-lookup"><span data-stu-id="a348f-186">High overdraw occurs when multiple objects are rendered but not outputted to the screen as they are hidden by another, generally closer, occluding object.</span></span> <span data-ttu-id="a348f-187">Stellen Sie sich vor, dass Sie eine Wand sehen, die mehrere Räume und Geometrie dahinter enthielt.</span><span class="sxs-lookup"><span data-stu-id="a348f-187">Imagine looking at a wall that had multiple rooms and geometry behind it.</span></span> <span data-ttu-id="a348f-188">Die gesamte Geometrie würde zum Rendern verarbeitet, aber nur die nicht transparente Wand muss tatsächlich gerendert werden, da Sie die Ansicht aller anderen Inhalte verbleibt.</span><span class="sxs-lookup"><span data-stu-id="a348f-188">All of the geometry would be processed for rendering but only the opaque wall really needs to be rendered as it occludes the view of all other content.</span></span> <span data-ttu-id="a348f-189">Dies führt zu verschwenderischen Vorgängen, die für die aktuelle Ansicht nicht benötigt werden.</span><span class="sxs-lookup"><span data-stu-id="a348f-189">This results in wasteful operations that are not needed for the current view.</span></span>

#### <a name="shaders"></a><span data-ttu-id="a348f-190">Shader</span><span class="sxs-lookup"><span data-stu-id="a348f-190">Shaders</span></span>

<span data-ttu-id="a348f-191">Shader sind kleine Programme, die auf der GPU ausgeführt werden und im Allgemeinen zwei wichtige Schritte beim Rendering bestimmen:</span><span class="sxs-lookup"><span data-stu-id="a348f-191">Shaders are small programs that run on the GPU and generally determine two important steps in rendering:</span></span>
1) <span data-ttu-id="a348f-192">die Scheitel Punkte des Objekts, die auf dem Bildschirm gezeichnet werden sollen, und wo Sie sich auf dem Bildschirmbereich befinden (d.h.</span><span class="sxs-lookup"><span data-stu-id="a348f-192">which object's vertices should be drawn on the screen and where they are in screen space (i.e</span></span> <span data-ttu-id="a348f-193">der Vertex-Shader)</span><span class="sxs-lookup"><span data-stu-id="a348f-193">the Vertex shader)</span></span>
    - <span data-ttu-id="a348f-194">Der Vertex-Shader wird im allgemeinen pro Scheitelpunkt für jedes gameobject-Objekt ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="a348f-194">The Vertex shader is generally executed per vertex for every GameObject</span></span>
2) <span data-ttu-id="a348f-195">Farbe der Pixel (d. h.</span><span class="sxs-lookup"><span data-stu-id="a348f-195">what to color those pixels (i.e</span></span> <span data-ttu-id="a348f-196">der Pixelshader)</span><span class="sxs-lookup"><span data-stu-id="a348f-196">the Pixel shader)</span></span>
    - <span data-ttu-id="a348f-197">Der Pixelshader wird pro Pixel für die Textur ausgeführt, die für das Gerät gerendert wird.</span><span class="sxs-lookup"><span data-stu-id="a348f-197">The Pixel shader is executed per pixel for the texture being rendered for device present</span></span>

<span data-ttu-id="a348f-198">In der Regel führen Shader viele Transformationen und Beleuchtungsberechnungen durch.</span><span class="sxs-lookup"><span data-stu-id="a348f-198">Typically shaders perform many transformations and lighting calculations.</span></span> <span data-ttu-id="a348f-199">Obwohl komplexe Beleuchtungs Modelle, Schatten und andere Vorgänge tolle Ergebnisse erzeugen können, erhalten Sie auch einen Preis.</span><span class="sxs-lookup"><span data-stu-id="a348f-199">Although complex lighting models, shadows, and other operations can generate fantastic results, they also come with a price.</span></span> <span data-ttu-id="a348f-200">Durch das Reduzieren der Anzahl von Vorgängen, die in Shader berechnet werden, kann die Gesamtarbeit, die für eine GPU pro Frame erforderlich ist, erheblich reduziert werden.</span><span class="sxs-lookup"><span data-stu-id="a348f-200">Reducing the number of operations computed in shaders can greatly reduce the overall work needed to be done by a GPU per frame.</span></span>

##### <a name="shader-coding-recommendations"></a><span data-ttu-id="a348f-201">Codierungs Empfehlungen für Shader</span><span class="sxs-lookup"><span data-stu-id="a348f-201">Shader coding recommendations</span></span>

- <span data-ttu-id="a348f-202">Verwenden Sie nach Möglichkeit die bilineare Filterung</span><span class="sxs-lookup"><span data-stu-id="a348f-202">Use bilinear filtering whenever possible</span></span>
- <span data-ttu-id="a348f-203">Neuanordnung von Ausdrücken zur Verwendung von verrückten systeminternen Funktionen, um eine Multiplikation und ein hinzufügen gleichzeitig durchzuführen</span><span class="sxs-lookup"><span data-stu-id="a348f-203">Rearrange expressions to use MAD intrinsics in order to do a multiply and an add at the same time</span></span>
- <span data-ttu-id="a348f-204">So weit wie möglich auf der CPU vorab berechnen und als Konstanten an das Material übergeben</span><span class="sxs-lookup"><span data-stu-id="a348f-204">Precalculate as much as possible on the CPU and pass as constants to the material</span></span>
- <span data-ttu-id="a348f-205">**Verschieben von Vorgängen vom Pixelshader zum Vertex-Shader bevorzugen**</span><span class="sxs-lookup"><span data-stu-id="a348f-205">**Favor moving operations from the pixel shader to the vertex shader**</span></span>
    - <span data-ttu-id="a348f-206">Im Allgemeinen ist die Anzahl der Scheitel Punkte < < Anzahl von Pixeln (d. h.</span><span class="sxs-lookup"><span data-stu-id="a348f-206">Generally the # of vertices << # of pixels (i.e</span></span> <span data-ttu-id="a348f-207">720p = = 921.600 Pixel, 1080p = = 2.073.600 Pixel usw.)</span><span class="sxs-lookup"><span data-stu-id="a348f-207">720p == 921,600 pixels, 1080p == 2,073,600 pixels, etc)</span></span>

#### <a name="remove-gpu-stages"></a><span data-ttu-id="a348f-208">Entfernen von GPU-Stufen</span><span class="sxs-lookup"><span data-stu-id="a348f-208">Remove GPU stages</span></span>
<span data-ttu-id="a348f-209">Die Auswirkungen nach der Verarbeitung können sehr kostspielig sein und die Füllrate der Anwendung im allgemeinen behindern.</span><span class="sxs-lookup"><span data-stu-id="a348f-209">Post-processing effects can be very expensive and generally inhibit the fill rate of your application.</span></span> <span data-ttu-id="a348f-210">Dies umfasst auch Antialiasing-Techniken wie z. b. MSAA.</span><span class="sxs-lookup"><span data-stu-id="a348f-210">This also includes anti-aliasing techniques such as MSAA.</span></span> <span data-ttu-id="a348f-211">Bei hololens empfiehlt es sich, diese Techniken vollständig zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="a348f-211">On HoloLens, it is recommended to avoid these techniques entirely.</span></span> <span data-ttu-id="a348f-212">Darüber hinaus sollten weitere shaderphasen wie Geometrie, Hülle und Compute-Shader möglichst vermieden werden.</span><span class="sxs-lookup"><span data-stu-id="a348f-212">Furthermore, additional shader stages such as geometry, hull, and compute shaders should be avoided when possible.</span></span>

## <a name="memory-recommendations"></a><span data-ttu-id="a348f-213">Speicher Empfehlungen</span><span class="sxs-lookup"><span data-stu-id="a348f-213">Memory recommendations</span></span>
<span data-ttu-id="a348f-214">Eine übermäßige Speicher Belegung & Zuordnungs Vorgängen kann negative Auswirkungen auf Ihre Holographic-Anwendung haben, was zu inkonsistenter Leistung, fixierten Frames und anderem schädlichen Verhalten führt.</span><span class="sxs-lookup"><span data-stu-id="a348f-214">Excessive memory allocation & deallocation operations can have adverse effects on your holographic application resulting in inconsistent performance, frozen frames, and other detrimental behavior.</span></span> <span data-ttu-id="a348f-215">Es ist besonders wichtig, die Arbeitsspeicher Aspekte zu verstehen, wenn Sie in Unity entwickeln, da die Speicherverwaltung durch die Garbage Collector gesteuert wird.</span><span class="sxs-lookup"><span data-stu-id="a348f-215">It is especially important to understand memory considerations when developing in Unity since memory management is controlled by the garbage collector.</span></span>

#### <a name="object-pooling"></a><span data-ttu-id="a348f-216">Objekt Pooling</span><span class="sxs-lookup"><span data-stu-id="a348f-216">Object pooling</span></span>

<span data-ttu-id="a348f-217">Objekt Pooling ist eine gängige Methode, um die Kosten für fortlaufende Zuordnungen & die Zuordnung von Objekten zu reduzieren.</span><span class="sxs-lookup"><span data-stu-id="a348f-217">Object pooling is a popular technique to reduce the cost of continuous allocations & deallocations of objects.</span></span> <span data-ttu-id="a348f-218">Dies erfolgt durch Zuordnen eines großen Pools identischer Objekte und erneutes verwenden inaktiver, verfügbarer Instanzen aus diesem Pool, anstatt ständig Objekte im Zeitverlauf zu erzeugen und zu zerstören.</span><span class="sxs-lookup"><span data-stu-id="a348f-218">This is done by allocating a large pool of identical objects and re-using inactive, available instances from this pool instead of constantly spawning and destroying objects over time.</span></span> <span data-ttu-id="a348f-219">Objekt Pools eignen sich hervorragend für wiederverwendbare Komponenten, die während einer APP über eine Variablen Lebensdauer verfügen.</span><span class="sxs-lookup"><span data-stu-id="a348f-219">Object pools are great for re-useable components that have variable lifetime during an app.</span></span>

## <a name="see-also"></a><span data-ttu-id="a348f-220">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="a348f-220">See also</span></span>
- [<span data-ttu-id="a348f-221">Leistungsempfehlungen für Unity</span><span class="sxs-lookup"><span data-stu-id="a348f-221">Performance recommendations for Unity</span></span>](performance-recommendations-for-unity.md)
- [<span data-ttu-id="a348f-222">Empfohlene Einstellungen für Unity</span><span class="sxs-lookup"><span data-stu-id="a348f-222">Recommended settings for Unity</span></span>](recommended-settings-for-unity.md)
