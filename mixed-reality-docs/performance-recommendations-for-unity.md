---
title: Leistungsempfehlungen für Unity
description: Unity-spezifische Tipps zum Verbessern der Leistung bei Mixed Reality-Apps.
author: troy-ferrell
ms.author: trferrel
ms.date: 03/26/2019
ms.topic: article
keywords: Grafik, CPU, GPU, Rendering, Garbage Collection, Hololens
ms.localizationpriority: high
ms.openlocfilehash: c6c68a6dd6e8ba59bee983e158e210aed27d2b17
ms.sourcegitcommit: 4282d92e93869e4829338bdf7d981c3ee0260bfd
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 06/23/2020
ms.locfileid: "85216241"
---
# <a name="performance-recommendations-for-unity"></a><span data-ttu-id="f40a3-104">Leistungsempfehlungen für Unity</span><span class="sxs-lookup"><span data-stu-id="f40a3-104">Performance recommendations for Unity</span></span>

<span data-ttu-id="f40a3-105">Dieser Artikel baut auf der Diskussion auf, die in [Leistungsempfehlungen für Mixed Reality](understanding-performance-for-mixed-reality.md) beschrieben wird, legt den Schwerpunkt aber auf die für die Umgebung der Unity-Engine spezifischen Erkenntnisse.</span><span class="sxs-lookup"><span data-stu-id="f40a3-105">This article builds on the discussion outlined in [performance recommendations for mixed reality](understanding-performance-for-mixed-reality.md) but focuses on learnings specific to the Unity engine environment.</span></span>

## <a name="use-recommended-unity-project-settings"></a><span data-ttu-id="f40a3-106">Verwenden der empfohlenen Unity-Projekteinstellungen</span><span class="sxs-lookup"><span data-stu-id="f40a3-106">Use recommended Unity project settings</span></span>

<span data-ttu-id="f40a3-107">Der wichtigste erste Schritt beim Optimieren der Leistung von Mixed Reality-Apps in Unity besteht darin, sicherzustellen, dass Sie die [empfohlenen Umgebungseinstellungen für Unity](recommended-settings-for-unity.md) verwenden.</span><span class="sxs-lookup"><span data-stu-id="f40a3-107">The most important first step when optimizing performance of mixed reality apps in Unity is to be sure you are using the [recommended environment settings for Unity](recommended-settings-for-unity.md).</span></span> <span data-ttu-id="f40a3-108">Der betreffende Artikel enthält Inhalte mit einigen der wichtigsten Szenenkonfigurationen zum Entwickeln leistungsfähiger Mixed Reality-Apps.</span><span class="sxs-lookup"><span data-stu-id="f40a3-108">That article contains content with some of the most important scene configurations for building performant Mixed Reality apps.</span></span> <span data-ttu-id="f40a3-109">Einige dieser empfohlenen Einstellungen werden unten ebenfalls hervorgehoben.</span><span class="sxs-lookup"><span data-stu-id="f40a3-109">Some of these recommended settings are highlighted below, as well.</span></span>

## <a name="how-to-profile-with-unity"></a><span data-ttu-id="f40a3-110">So erstellen Sie ein Profil mit Unity</span><span class="sxs-lookup"><span data-stu-id="f40a3-110">How to profile with Unity</span></span>

<span data-ttu-id="f40a3-111">Unity bietet den integrierten **[Unity Profiler](https://docs.unity3d.com/Manual/Profiler.html)** , der eine hervorragende Ressource zum Sammeln wertvoller Einblicke zur Leistung für Ihre bestimmte App darstellt.</span><span class="sxs-lookup"><span data-stu-id="f40a3-111">Unity provides the **[Unity Profiler](https://docs.unity3d.com/Manual/Profiler.html)** built-in, which is a great resource to gather valuable performance insights for your particular app.</span></span> <span data-ttu-id="f40a3-112">Der Profiler kann zwar im Editor ausgeführt werden, diese Metriken stellen aber nicht die reale Laufzeitumgebung dar, daher sollten Ergebnisse aus diesen Profilerläufen umsichtig angewendet werden.</span><span class="sxs-lookup"><span data-stu-id="f40a3-112">Although one can run the profiler in-editor, these metrics do not represent the true runtime environment and thus, results from this should be used cautiously.</span></span> <span data-ttu-id="f40a3-113">Um besonders genaue und verwertbare Ergebnisse zu erhalten, empfiehlt es sich, das Profil Ihrer Anwendung remote während der Ausführung auf einem Gerät zu bestimmen.</span><span class="sxs-lookup"><span data-stu-id="f40a3-113">It is recommended to remotely profile your application while running on device for most accurate and actionable insights.</span></span> <span data-ttu-id="f40a3-114">Darüber hinaus stellt der [Frame Debugger](https://docs.unity3d.com/Manual/FrameDebugger.html) von Unity ebenfalls ein sehr leistungsstarkes Tool dar, mit dem sich Erkenntnisse gewinnen lassen.</span><span class="sxs-lookup"><span data-stu-id="f40a3-114">Further, Unity's [Frame Debugger](https://docs.unity3d.com/Manual/FrameDebugger.html) is also a very powerful and insight tool to utilize.</span></span>

<span data-ttu-id="f40a3-115">Unity bietet eine hervorragende Dokumentation zu diesen Punkten:</span><span class="sxs-lookup"><span data-stu-id="f40a3-115">Unity provides great documentation for:</span></span>
1) <span data-ttu-id="f40a3-116">Herstellen einer [Remoteverbindung zwischen dem Unity-Profiler und UWP-Anwendungen](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span><span class="sxs-lookup"><span data-stu-id="f40a3-116">How to connect the [Unity profiler to UWP applications remotely](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span></span>
2) <span data-ttu-id="f40a3-117">Effektive [Diagnose von Leistungsproblemen mit dem Unity Profiler](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span><span class="sxs-lookup"><span data-stu-id="f40a3-117">How to effectively [diagnose performance problems with the Unity Profiler](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span></span>

>[!NOTE]
> <span data-ttu-id="f40a3-118">Bei verbundenem Unity Profiler und nach dem Hinzufügen des GPU-Profilers (siehe dazu *Add Profiler* („Profiler hinzufügen“) in der oberen rechten Ecke) lässt sich in der Mitte des Profilers ablesen, wie viel Zeit für CPU bzw. GPU aufgewendet wird.</span><span class="sxs-lookup"><span data-stu-id="f40a3-118">With the Unity Profiler connected and after adding the GPU profiler (see *Add Profiler* in top right corner), one can see how much time is being spent on the CPU & GPU respectively in the middle of the profiler.</span></span> <span data-ttu-id="f40a3-119">Dadurch kann der Entwickler näherungsweise einschätzen, ob seine Anwendung CPU- oder GPU-lastig ist.</span><span class="sxs-lookup"><span data-stu-id="f40a3-119">This allows the developer to get a quick approximation if their application is CPU or GPU bounded.</span></span>
>
> ![Unity-CPU im Vergleich zu -GPU](images/unity-profiler-cpu-gpu.png)

## <a name="cpu-performance-recommendations"></a><span data-ttu-id="f40a3-121">CPU-Leistungsempfehlungen</span><span class="sxs-lookup"><span data-stu-id="f40a3-121">CPU performance recommendations</span></span>

<span data-ttu-id="f40a3-122">Die Inhalte unten befassen sich mit tiefgreifenden Praktiken zur Leistungsverbesserung, insbesondere für die Entwicklung mit Unity und C# bestimmt.</span><span class="sxs-lookup"><span data-stu-id="f40a3-122">The content below covers more in-depth performance practices, especially targeted for Unity & C# development.</span></span>

#### <a name="cache-references"></a><span data-ttu-id="f40a3-123">Zwischenspeichern von Verweisen</span><span class="sxs-lookup"><span data-stu-id="f40a3-123">Cache references</span></span>

<span data-ttu-id="f40a3-124">Es ist eine bewährte Methode, Verweise auf alle relevanten Komponenten und Spielobjekte bei der Initialisierung zwischenzuspeichern.</span><span class="sxs-lookup"><span data-stu-id="f40a3-124">It is best practice to cache references to all relevant components and GameObjects at initialization.</span></span> <span data-ttu-id="f40a3-125">Die hat den Grund, dass wiederholte Funktionsaufrufe wie etwa *[GetComponent\<T>()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* hinsichtlich des Arbeitsspeicherbedarfs erheblich teurer als das Speichern eines Zeigers sind.</span><span class="sxs-lookup"><span data-stu-id="f40a3-125">This is because repeating function calls such as *[GetComponent\<T>()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* are significantly more expensive relative to the memory cost to store a pointer.</span></span> <span data-ttu-id="f40a3-126">Dies gilt auch für das sehr gerne verwendete [Camera.main](https://docs.unity3d.com/ScriptReference/Camera-main.html).</span><span class="sxs-lookup"><span data-stu-id="f40a3-126">This also applies to to the very regularly used [Camera.main](https://docs.unity3d.com/ScriptReference/Camera-main.html).</span></span> <span data-ttu-id="f40a3-127">*Camera.main* basiert auf der zugrundeliegenden Funktion *[FindGameObjectsWithTag()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* , die aufwändig Ihre Szenendarstellung nach einem Kameraobjekt mit dem Tag *„MainCamera“* absucht.</span><span class="sxs-lookup"><span data-stu-id="f40a3-127">*Camera.main* actually just uses *[FindGameObjectsWithTag()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* underneath, which expensively searches your scene graph for a camera object with the *"MainCamera"* tag.</span></span>

```CS
using UnityEngine;
using System.Collections;

public class ExampleClass : MonoBehaviour
{
    private Camera cam;
    private CustomComponent comp;

    void Start() 
    {
        cam = Camera.main;
        comp = GetComponent<CustomComponent>();
    }

    void Update()
    {
        // Good
        this.transform.position = cam.transform.position + cam.transform.forward * 10.0f;

        // Bad
        this.transform.position = Camera.main.transform.position + Camera.main.transform.forward * 10.0f;

        // Good
        comp.DoSomethingAwesome();

        // Bad
        GetComponent<CustomComponent>().DoSomethingAwesome();
    }
}
```

>[!NOTE] 
> <span data-ttu-id="f40a3-128">Vermeiden von GetComponent(string)</span><span class="sxs-lookup"><span data-stu-id="f40a3-128">Avoid GetComponent(string)</span></span> <br/>
> <span data-ttu-id="f40a3-129">Beim Verwenden von *[GetComponent()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* haben Sie es mit einer handvoll verschiedener Überladungen zu tun.</span><span class="sxs-lookup"><span data-stu-id="f40a3-129">When using *[GetComponent()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)*, there are a handful of different overloads.</span></span> <span data-ttu-id="f40a3-130">Es ist wichtig, immer die typbasierten Implementierungen und nie die zeichenfolgenbasierte Suchüberladung zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="f40a3-130">It is important to always use the Type-based implementations and never the string-based searching overload.</span></span> <span data-ttu-id="f40a3-131">Die Suche nach der Zeichenfolge in Ihrer Szene ist erheblich teurer als die Suche nach dem Typ.</span><span class="sxs-lookup"><span data-stu-id="f40a3-131">Searching by string in your scene is significantly more costly than searching by Type.</span></span> <br/>
> <span data-ttu-id="f40a3-132">(Gut) Component GetComponent(Typ Typ)</span><span class="sxs-lookup"><span data-stu-id="f40a3-132">(Good) Component GetComponent(Type type)</span></span> <br/>
> <span data-ttu-id="f40a3-133">(Gut) T GetComponent\<T>()</span><span class="sxs-lookup"><span data-stu-id="f40a3-133">(Good) T GetComponent\<T>()</span></span> <br/>
> <span data-ttu-id="f40a3-134">(Schlecht) Component GetComponent(string)></span><span class="sxs-lookup"><span data-stu-id="f40a3-134">(Bad) Component GetComponent(string)></span></span> <br/>

#### <a name="avoid-expensive-operations"></a><span data-ttu-id="f40a3-135">Vermeiden aufwändiger Vorgänge</span><span class="sxs-lookup"><span data-stu-id="f40a3-135">Avoid expensive operations</span></span>

1) <span data-ttu-id="f40a3-136">**Vermeiden Sie die Verwendung von [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span><span class="sxs-lookup"><span data-stu-id="f40a3-136">**Avoid use of [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span></span>

    <span data-ttu-id="f40a3-137">Zwar kann LINQ sehr sauber, leicht zu lesen und zu schreiben sein, es erfordert aber allgemein sehr viel mehr Rechenleistung und insbesondere mehr Arbeitsspeicherressourcen als das manuelle Ausschreiben der Algorithmen.</span><span class="sxs-lookup"><span data-stu-id="f40a3-137">Although LINQ can be very clean and easy to read and write, it generally requires much more computation and particularly more memory allocation than writing the algorithm out manually.</span></span>

    ```CS
    // Example Code
    using System.Linq;

    List<int> data = new List<int>();
    data.Any(x => x > 10);

    var result = from x in data
                 where x > 10
                 select x;
    ```

2) <span data-ttu-id="f40a3-138">**Allgemeine Unity-APIs**</span><span class="sxs-lookup"><span data-stu-id="f40a3-138">**Common Unity APIs**</span></span>

    <span data-ttu-id="f40a3-139">Bestimmte Unity-APIs können zwar nützlich sein, sind in der Ausführung aber sehr kostspielig.</span><span class="sxs-lookup"><span data-stu-id="f40a3-139">Certain Unity APIs, although useful, can be very expensive to execute.</span></span> <span data-ttu-id="f40a3-140">Die meisten davon beinhalten das Durchsuchen Ihres gesamten Szenendarstellung nach einer Liste passender Spielobjekte.</span><span class="sxs-lookup"><span data-stu-id="f40a3-140">Most of these involve searching your entire scene graph for some matching list of GameObjects.</span></span> <span data-ttu-id="f40a3-141">Diese Vorgänge können im Allgemeinen durch das Zwischenspeichern von Verweisen oder das Implementieren einer Manager-Komponente für die betreffenden GameObjects vermieden werden, um die Verweise zur Laufzeit zu verfolgen.</span><span class="sxs-lookup"><span data-stu-id="f40a3-141">These operations can generally be avoided by caching references or implementing a manager component for the GameObjects in question to track the references at runtime.</span></span>

        GameObject.SendMessage()
        GameObject.BroadcastMessage()
        UnityEngine.Object.Find()
        UnityEngine.Object.FindWithTag()
        UnityEngine.Object.FindObjectOfType()
        UnityEngine.Object.FindObjectsOfType()
        UnityEngine.Object.FindGameObjectsWithTag()
        UnityEngine.Object.FindGameObjectsWithTag()

>[!NOTE]
> <span data-ttu-id="f40a3-142">*[SendMessage()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)* und *[BroadcastMessage()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* sollten unter allen Umständen entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="f40a3-142">*[SendMessage()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)* and *[BroadcastMessage()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* should be eliminated at all costs.</span></span> <span data-ttu-id="f40a3-143">Diese Funktionen können der Größenordnung nach 1000mal langsamer als direkte Funktionsaufrufe sein.</span><span class="sxs-lookup"><span data-stu-id="f40a3-143">These functions can be on the order of 1000x slower than direct function calls.</span></span>

3) <span data-ttu-id="f40a3-144">**Vermeiden von Boxing**</span><span class="sxs-lookup"><span data-stu-id="f40a3-144">**Beware of boxing**</span></span>

    <span data-ttu-id="f40a3-145">[Boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) ist ein Grundkonzept der C#- Sprache und ihrer Runtime.</span><span class="sxs-lookup"><span data-stu-id="f40a3-145">[Boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) is a core concept of the C# language and runtime.</span></span> <span data-ttu-id="f40a3-146">Dabei handelt es sich um den Prozess, Variablen eines Werttyps, wie etwa char, int, bool usw. mit Variablen vom Verweistyp zu umschließen.</span><span class="sxs-lookup"><span data-stu-id="f40a3-146">It is the process of wrapping value-typed variables such as char, int, bool, etc. into reference-typed variables.</span></span> <span data-ttu-id="f40a3-147">Wenn eine Variable eines Werttyps „geboxt“ ist, ist sie von einem System.Object umschlossen, das auf dem verwalteten Heap gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="f40a3-147">When a value-typed variable is "boxed", it is wrapped inside of a System.Object which is stored on the managed heap.</span></span> <span data-ttu-id="f40a3-148">Auf diese Weise wird Speicher zugewiesen, der gegebenenfalls beim Verwerfen vom Garbage Collector verarbeitet werden muss.</span><span class="sxs-lookup"><span data-stu-id="f40a3-148">Thus, memory is allocated and eventually when disposed must be processed by the garbage collector.</span></span> <span data-ttu-id="f40a3-149">Diese Zuweisungen und ihre Aufhebung bringen Leistungskosten mit sich und sind in vielen Szenarien unnötig oder können leicht durch preiswertere Alternativen ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="f40a3-149">These allocations and deallocations incur a performance cost and in many scenarios are unnecessary or can be easily replaced by a less expensive alternative.</span></span>

    <span data-ttu-id="f40a3-150">Eine der häufigsten Formen von Boxing in der Entwicklung ist die Verwendung von [Nullwerte zulassenden Typen](https://docs.microsoft.com//dotnet/csharp/programming-guide/nullable-types/).</span><span class="sxs-lookup"><span data-stu-id="f40a3-150">One of the most common forms of boxing in development is the use of [nullable value types](https://docs.microsoft.com//dotnet/csharp/programming-guide/nullable-types/).</span></span> <span data-ttu-id="f40a3-151">Der Wunsch nach der Möglichkeit, null für einen Werttyp in einer Funktion zurückgeben zu können, ist gängig, insbesondere, wenn der Vorgang beim Versuch fehlschlagen kann, den Wert abzurufen.</span><span class="sxs-lookup"><span data-stu-id="f40a3-151">It is common to want to be able to return null for a value type in a function, especially when the operation may fail trying to get the value.</span></span> <span data-ttu-id="f40a3-152">Das potenzielle Problem bei diesem Ansatz besteht darin, dass die Zuweisung jetzt auf dem Heap erfolgt und daher zu einem späteren Zeitpunkt Garbage Collection erforderlich macht.</span><span class="sxs-lookup"><span data-stu-id="f40a3-152">The potential problem with this approach is that allocation now occurs on the heap and consequently needs to be garbage collected later.</span></span>

    <span data-ttu-id="f40a3-153">**Beispiel für Boxing in C#**</span><span class="sxs-lookup"><span data-stu-id="f40a3-153">**Example of boxing in C#**</span></span>

    ```csharp
    // boolean value type is boxed into object boxedMyVar on the heap
    bool myVar = true;
    object boxedMyVar = myVar;
    ```

    <span data-ttu-id="f40a3-154">**Beispiel für problematisches Boxing in Form von Typen, die Null-Werte zulassen**</span><span class="sxs-lookup"><span data-stu-id="f40a3-154">**Example of problematic boxing via nullable value types**</span></span>

    <span data-ttu-id="f40a3-155">Dieser Code veranschaulicht eine Partikel-Dummyklasse, die sich in einem Unity-Projekt erstellen lässt.</span><span class="sxs-lookup"><span data-stu-id="f40a3-155">This code demonstrates a dummy particle class that one may create in a Unity project.</span></span> <span data-ttu-id="f40a3-156">Ein Aufruf von `TryGetSpeed()` bewirkt eine Objektzuordnung auf dem Heap, die zu einem späteren Zeitpunkt Garbage Collection erforderlich macht.</span><span class="sxs-lookup"><span data-stu-id="f40a3-156">A call to `TryGetSpeed()` will cause object allocation on the heap which will need to be garbage collected at a later point in time.</span></span> <span data-ttu-id="f40a3-157">Dieses Beispiel ist besonders problematisch, da es leicht 1.000 oder noch weit mehr Partikel in einer Szene geben kann, von denen jedes nach seiner aktuellen Geschwindigkeit gefragt wird.</span><span class="sxs-lookup"><span data-stu-id="f40a3-157">This example is particularly problematic as there may be 1000+ or many more particles in a scene, each being asked for their current speed.</span></span> <span data-ttu-id="f40a3-158">Auf diese Weise würden in jedem Frame 1000e Objekte zugewiesen und deren Zuweisung entsprechend wieder aufgehoben, was die Leistung stark herabsetzen würde.</span><span class="sxs-lookup"><span data-stu-id="f40a3-158">Thus, 1000's of objects would be allocated and consequently de-allocated every frame, which would greatly diminish performance.</span></span> <span data-ttu-id="f40a3-159">Ein Umschreiben der Funktion, sodass sie einen negativen Wert wie etwa -1 zurückgibt, um einen Fehler anzuzeigen, hätte das Problem vermieden und Arbeitsspeicher auf dem Stack gehalten.</span><span class="sxs-lookup"><span data-stu-id="f40a3-159">Re-writing the function to return a negative value such as -1 to indicate a failure would avoid this issue and keep memory on the stack.</span></span>

    ```csharp
        public class MyParticle
        {
            // Example of function returning nullable value type
            public int? TryGetSpeed()
            {
                // Returns current speed int value or null if fails
            }
        }
    ```

#### <a name="repeating-code-paths"></a><span data-ttu-id="f40a3-160">Wiederholte Codepfade</span><span class="sxs-lookup"><span data-stu-id="f40a3-160">Repeating code paths</span></span>

<span data-ttu-id="f40a3-161">Alle wiederholten Unity-Rückruf-Funktionen (d. h.</span><span class="sxs-lookup"><span data-stu-id="f40a3-161">Any repeating Unity callback functions (i.e</span></span> <span data-ttu-id="f40a3-162">Update), die mehrmals pro Sekunde und/oder Frame ausgeführt werden, sollten mit großer Sorgfalt geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="f40a3-162">Update) that are executed many times per second and/or frame should be written very carefully.</span></span> <span data-ttu-id="f40a3-163">Alle aufwändigen Vorgänge an dieser Stelle haben einen sehr großen und konsistenten Einfluss auf die Leistung.</span><span class="sxs-lookup"><span data-stu-id="f40a3-163">Any expensive operations here will have huge and consistent impact on performance.</span></span>

1) <span data-ttu-id="f40a3-164">**Leere Rückruffunktion**</span><span class="sxs-lookup"><span data-stu-id="f40a3-164">**Empty callback functions**</span></span>

    <span data-ttu-id="f40a3-165">Zwar mag der Code unten harmlos aussehen, und Sie neigen wohl dazu, ihn in Ihrer Anwendung zu belassen, vor allem, da sich jedes Unity-Skript automatisch mit diesem Codeblock initialisiert, diese leeren Rückrufe können aber tatsächlich sehr teuer werden.</span><span class="sxs-lookup"><span data-stu-id="f40a3-165">Although the code below may seem innocent to leave in your application, especially since every Unity script auto-initializes with this code block, these empty callbacks can actually become very expensive.</span></span> <span data-ttu-id="f40a3-166">Unity überquert bei der Arbeit ständig in beiden Richtungen eine Grenze zwischen verwaltetem und nicht verwaltetem Code, nämlich zwischen dem Code der UnityEngine und Ihrem Anwendungscode.</span><span class="sxs-lookup"><span data-stu-id="f40a3-166">Unity operates back and forth over an unmanaged/managed code boundary, between UnityEngine code and your application code.</span></span> <span data-ttu-id="f40a3-167">Der Kontextwechsel beim Überqueren dieser Grenze ist ziemlich teuer, auch dann, wenn es gar nichts auszuführen gibt.</span><span class="sxs-lookup"><span data-stu-id="f40a3-167">Context switching over this bridge is fairly expensive, even if there is nothing to execute.</span></span> <span data-ttu-id="f40a3-168">Dies wird besonders dann problematisch, wenn Ihre App über 100e von Spielobjekten verfügt, die ihrerseits wiederholte leere Unity-Rückrufe verwenden.</span><span class="sxs-lookup"><span data-stu-id="f40a3-168">This becomes especially problematic if your app has 100's of GameObjects with components that have empty repeating Unity callbacks.</span></span>

    ```CS
    void Update()
    {
    }
    ```

>[!NOTE]
> <span data-ttu-id="f40a3-169">Update () ist die gängigste Form dieses Leistungsproblems, aber andere sich wiederholende Unity-Rückrufe, wie z. B. die folgenden, können genauso schlecht sein, wenn nicht gar schlechter: FixedUpdate(), LateUpdate(), OnPostRender", OnPreRender(), OnRenderImage() usw.</span><span class="sxs-lookup"><span data-stu-id="f40a3-169">Update() is the most common manifestation of this performance issue but other repeating Unity callbacks, such as the following can be equally as bad, if not worse: FixedUpdate(), LateUpdate(), OnPostRender", OnPreRender(), OnRenderImage(), etc.</span></span> 

2) <span data-ttu-id="f40a3-170">**Vorgänge, die vorzugsweise einmal pro Frame ausgeführt werden sollten**</span><span class="sxs-lookup"><span data-stu-id="f40a3-170">**Operations to favor running once per frame**</span></span>

    <span data-ttu-id="f40a3-171">Die folgenden Unity-APIs stellen gängige Vorgänge für viele Holografie-Apps dar.</span><span class="sxs-lookup"><span data-stu-id="f40a3-171">The following Unity APIs are common operations for many Holographic Apps.</span></span> <span data-ttu-id="f40a3-172">Es ist zwar nicht immer möglich, aber sehr oft können die Ergebnisse dieser Funktionen einmal berechnet und dann für einen bestimmten Frame im gesamten Bereich der Anwendung wiederverwendet werden.</span><span class="sxs-lookup"><span data-stu-id="f40a3-172">Although not always possible, the results from these functions can very commonly be computed once and the results re-utilized across the application for a given frame.</span></span>

    <span data-ttu-id="f40a3-173">a) Im Allgemeinen ist es eine gute Praxis, eine dedizierte Singleton-Klasse oder einen Dienst einzusetzen, die bzw. der Ihren Raycast vom Anvisieren der Szene verarbeitet und dieses Ergebnis dann in allen anderen Szenekomponenten wiederzuverwenden, statt wiederholte und im Wesentlichen identische Raycastvorgänge für jede Komponente auszulösen.</span><span class="sxs-lookup"><span data-stu-id="f40a3-173">a) Generally it is good practice to have a dedicated Singleton class or service to handle your gaze Raycast into the scene and then re-use this result in all other scene components, instead of making repeated and essentially identical Raycast operations by each component.</span></span> <span data-ttu-id="f40a3-174">Natürlich sind in manchen Anwendungen möglicherweise Raycasts aus einem anderen Ursprung oder gegen andere [LayerMasks](https://docs.unity3d.com/ScriptReference/LayerMask.html) (Ebenenmasken) erforderlich.</span><span class="sxs-lookup"><span data-stu-id="f40a3-174">Of course, some applications may require raycasts from different origins or against different [LayerMasks](https://docs.unity3d.com/ScriptReference/LayerMask.html).</span></span>

        UnityEngine.Physics.Raycast()
        UnityEngine.Physics.RaycastAll()

    <span data-ttu-id="f40a3-175">b) Vermeiden Sie GetComponent()-Vorgänge in wiederholten Unity-Rückrufen wie Update(), indem Sie [Verweise zwischenspeichern](#cache-references): in Start() oder Awake()</span><span class="sxs-lookup"><span data-stu-id="f40a3-175">b) Avoid GetComponent() operations in repeated Unity callbacks like Update() by [caching references](#cache-references) in Start() or Awake()</span></span>

        UnityEngine.Object.GetComponent()

    <span data-ttu-id="f40a3-176">c) Es ist eine bewährte Methode, nach Möglichkeit alle Objekte bei der Initialisierung zu instanziieren und [Objektpooling](#object-pooling) zu verwenden, um die gesamte Laufzeit Ihrer Anwendung hindurch Spielobjekte zu recyceln und wiederzuverwenden</span><span class="sxs-lookup"><span data-stu-id="f40a3-176">c) It is good practice to instantiate all objects, if possible, at initialization and use [object pooling](#object-pooling) to recycle and re-use GameObjects throughout runtime of your application</span></span>

        UnityEngine.Object.Instantiate()

3) <span data-ttu-id="f40a3-177">**Vermeiden von Schnittstellen und virtuellen Konstrukten**</span><span class="sxs-lookup"><span data-stu-id="f40a3-177">**Avoid interfaces and virtual constructs**</span></span>

    <span data-ttu-id="f40a3-178">Das Aufrufen von Funktionsaufrufen über Schnittstellen im Gegensatz zu direkten Objekten oder dem Aufrufen von virtuellen Funktionen ist oftmals sehr viel kostspieliger als die Verwendung direkter Konstrukte oder direkter Funktionsaufrufe.</span><span class="sxs-lookup"><span data-stu-id="f40a3-178">Invoking function calls through interfaces vs direct objects or calling virtual functions can often times be much more expensive than utilizing direct constructs or direct function calls.</span></span> <span data-ttu-id="f40a3-179">Wenn die virtuelle Funktion oder Schnittstelle nicht benötigt wird, sollte sie entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="f40a3-179">If the virtual function or interface is unnecessary, then it should be removed.</span></span> <span data-ttu-id="f40a3-180">Der Leistungspreis für diese Ansätze spricht aber in der Regel für den Kompromiss, wenn ihre Verwendung die Zusammenarbeit bei der Entwicklung vereinfacht, die Lesebarkeit und die Wartbarkeit des Codes verbessert.</span><span class="sxs-lookup"><span data-stu-id="f40a3-180">However, the performance hit for these approaches are generally worth the trade-off if utilizing them simplifies development collaboration, code readability, and code maintainability.</span></span>

    <span data-ttu-id="f40a3-181">Im Allgemeinen wird empfohlen, Felder und Funktionen nicht als virtuell zu markieren, es sei denn, es gibt eine klare Annahme, dass das betreffende Element überschrieben werden muss.</span><span class="sxs-lookup"><span data-stu-id="f40a3-181">Generally, the recommendation is to not mark fields and functions as virtual unless there is a clear expectation that this member needs to be overwritten.</span></span> <span data-ttu-id="f40a3-182">Insbesondere im Umfeld stark frequentierter Codepfade, die mehrmals pro Frame oder auch nur einmal pro Frame aufgerufen werden, wie etwa eine `UpdateUI()`-Methode, sollten Sie vorsichtig sein.</span><span class="sxs-lookup"><span data-stu-id="f40a3-182">One should be especially careful around high-frequency code paths that are called many times per frame or even once per frame such as an `UpdateUI()` method.</span></span>

4) <span data-ttu-id="f40a3-183">**Vermeiden der Übergabe von Strukturen über den Wert**</span><span class="sxs-lookup"><span data-stu-id="f40a3-183">**Avoid passing structs by value**</span></span>

    <span data-ttu-id="f40a3-184">Im Gegensatz zu Klassen sind Strukturen Werttypen, und bei der direkten Übergabe an eine Funktion werden ihre Inhalte in eine neu erstellte Instanz kopiert.</span><span class="sxs-lookup"><span data-stu-id="f40a3-184">Unlike classes, structs are value-types and when passed directly to a function, their contents are copied into a newly created instance.</span></span> <span data-ttu-id="f40a3-185">Diese Kopie bewirkt höhere CPU-Kosten sowie zusätzlichen Speicherbedarf auf dem Stack.</span><span class="sxs-lookup"><span data-stu-id="f40a3-185">This copy adds CPU cost, as well as additional memory on the stack.</span></span> <span data-ttu-id="f40a3-186">Für kleine Strukturen ist der Effekt normalerweise minimal und daher akzeptabel.</span><span class="sxs-lookup"><span data-stu-id="f40a3-186">For small structs, the effect is usually very minimal and thus acceptable.</span></span> <span data-ttu-id="f40a3-187">Bei Funktionen, die in jedem Frame wiederholt aufgerufen werden, sowie bei Funktionen, die große Strukturen akzeptieren, ändern Sie nach Möglichkeit die Funktionsdefinition, um durch Verweis zu übergeben.</span><span class="sxs-lookup"><span data-stu-id="f40a3-187">However, for functions repeatedly invoked every frame as well as functions taking large structs, if possible modify the function definition to pass by reference.</span></span> [<span data-ttu-id="f40a3-188">Weitere Informationen finden Sie hier</span><span class="sxs-lookup"><span data-stu-id="f40a3-188">Learn more here</span></span>](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/how-to-know-the-difference-passing-a-struct-and-passing-a-class-to-a-method)

#### <a name="miscellaneous"></a><span data-ttu-id="f40a3-189">Verschiedenes</span><span class="sxs-lookup"><span data-stu-id="f40a3-189">Miscellaneous</span></span>

1) <span data-ttu-id="f40a3-190">**Physische Effekte**</span><span class="sxs-lookup"><span data-stu-id="f40a3-190">**Physics**</span></span>

    <span data-ttu-id="f40a3-191">a) Im Allgemeinen ist die einfachste Möglichkeit, die physischen Effekte zu verbessern, die Menge an Zeit oder die Anzahl der Iterationen pro Sekunde einzuschränken, die zu ihrer Berechnung aufgewendet wird.</span><span class="sxs-lookup"><span data-stu-id="f40a3-191">a) Generally, the easiest way to improve physics is to limit the amount of time spent on Physics or the number of iterations per second.</span></span> <span data-ttu-id="f40a3-192">Dadurch wird natürlich die Genauigkeit der Simulation reduziert.</span><span class="sxs-lookup"><span data-stu-id="f40a3-192">Of course, this will reduce simulation accuracy.</span></span> <span data-ttu-id="f40a3-193">Mehr dazu finden Sie unter [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) in Unity</span><span class="sxs-lookup"><span data-stu-id="f40a3-193">See [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) in Unity</span></span>

    <span data-ttu-id="f40a3-194">b) Die verschiedenen Collidertypen in Unity weisen stark unterschiedliche Leistungsmerkmale auf.</span><span class="sxs-lookup"><span data-stu-id="f40a3-194">b) The type of colliders in Unity have widely different performance characteristics.</span></span> <span data-ttu-id="f40a3-195">Der Auftrag unten listet Collider nach ihrer Leistungsfähigkeit auf, von den leistungsfähigsten links bis zu den am wenigsten leistungsfähigen Collidern rechts.</span><span class="sxs-lookup"><span data-stu-id="f40a3-195">The order below lists the most performant colliders to least performant colliders from left to right.</span></span> <span data-ttu-id="f40a3-196">Es ist sehr wichtig, Gittermodell-Collider zu meiden, die erheblich teurer sind als die primitiven Collider.</span><span class="sxs-lookup"><span data-stu-id="f40a3-196">It is most important to avoid Mesh Colliders, which are substantially more expensive than the primitive colliders.</span></span>

        Sphere < Capsule < Box <<< Mesh (Convex) < Mesh (non-Convex)

    <span data-ttu-id="f40a3-197">Weitere Informationen finden Sie unter [Unity Physics Best Practices](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) (Bewährte Methoden für physische Effekte in Unity).</span><span class="sxs-lookup"><span data-stu-id="f40a3-197">See [Unity Physics Best Practices](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) for more info</span></span>

2) <span data-ttu-id="f40a3-198">**Animationen**</span><span class="sxs-lookup"><span data-stu-id="f40a3-198">**Animations**</span></span>

    <span data-ttu-id="f40a3-199">Deaktivieren Sie Leerlaufanimationen, indem Sie die Animatorkomponente deaktivieren (das Deaktivieren des Spielobjekts hat nicht die gleiche Wirkung).</span><span class="sxs-lookup"><span data-stu-id="f40a3-199">Disable idle animations by disabling the Animator component (disabling the game object won't have the same effect).</span></span> <span data-ttu-id="f40a3-200">Vermeiden Sie Entwurfsmuster, bei denen ein Animator in einer Schleife sitzt und einen Wert ständig erneut festlegt.</span><span class="sxs-lookup"><span data-stu-id="f40a3-200">Avoid design patterns where an animator sits in a loop setting a value to the same thing.</span></span> <span data-ttu-id="f40a3-201">Diese Technik verursacht beträchtlichen Mehraufwand ohne positiven Effekt auf die Anwendung.</span><span class="sxs-lookup"><span data-stu-id="f40a3-201">There is considerable overhead for this technique, with no effect on the application.</span></span> [<span data-ttu-id="f40a3-202">Weitere Informationen finden Sie hier.</span><span class="sxs-lookup"><span data-stu-id="f40a3-202">Learn more here.</span></span>](https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html)

3) <span data-ttu-id="f40a3-203">**Komplexe Algorithmen**</span><span class="sxs-lookup"><span data-stu-id="f40a3-203">**Complex algorithms**</span></span>

    <span data-ttu-id="f40a3-204">Wenn Ihre Anwendung komplexe Algorithmen verwendet, wie z. B. inverse Kinematik, Pfadsuche usw., suchen Sie nach einem einfacheren Ansatz, oder passen Sie relevante Einstellungen leistungsbezogen an.</span><span class="sxs-lookup"><span data-stu-id="f40a3-204">If your application is using complex algorithms such as inverse kinematics, path finding, etc, look to find a simpler approach or adjust relevant settings for their performance</span></span>

## <a name="cpu-to-gpu-performance-recommendations"></a><span data-ttu-id="f40a3-205">CPU- im Vergleich mit GPU-Leistungsempfehlungen</span><span class="sxs-lookup"><span data-stu-id="f40a3-205">CPU-to-GPU performance recommendations</span></span>

<span data-ttu-id="f40a3-206">Im Allgemeinen lässt sich das Leistungsverhältnis zwischen CPU und GPU auf die **Zeichenaufrufe** reduzieren, die an die Grafikkarte übermittelt werden.</span><span class="sxs-lookup"><span data-stu-id="f40a3-206">Generally, CPU-to-GPU performance comes down to the **draw calls** submitted to the graphics card.</span></span> <span data-ttu-id="f40a3-207">Um die Leistung zu verbessern, müssen Zeichenaufrufe strategisch **a) verringert** oder **b) neu strukturiert** werden, um optimale Ergebnisse zu erzielen.</span><span class="sxs-lookup"><span data-stu-id="f40a3-207">To improve performance, draw calls need to be strategically **a) reduced** or **b) restructured** for optimal results.</span></span> <span data-ttu-id="f40a3-208">Da Zeichenaufrufe ihrerseits ressourcenintensiv sind, bewirkt ihre Verringerung auch eine Verringerung der insgesamt aufzuwendenden Arbeit.</span><span class="sxs-lookup"><span data-stu-id="f40a3-208">Since draw calls themselves are resource-intensive, reducing them will reduce overall work required.</span></span> <span data-ttu-id="f40a3-209">Ferner werden durch Statuswechsel zwischen Zeichenaufrufen aufwändige Schritte zur Validierung und Übersetzung im Grafiktreiber erforderlich, daher kann eine Neustrukturierung der Zeichenaufrufe Ihrer Anwendung mit dem Ziel, die Statuswechsel (d. h.</span><span class="sxs-lookup"><span data-stu-id="f40a3-209">Further, state changes between draw calls requires costly validation and translation steps in the graphics driver and thus, restructuring of your application's draw calls to limit state changes (i.e</span></span> <span data-ttu-id="f40a3-210">verschiedene Materialien usw.) zu verringern, die Leistung steigern.</span><span class="sxs-lookup"><span data-stu-id="f40a3-210">different materials, etc) can boost performance.</span></span>

<span data-ttu-id="f40a3-211">Unity bietet einen hervorragenden Artikel, der einen Überblick hierzu gibt und tief in die Batchverarbeitung von Zeichenaufrufen für die Unity-Plattform einsteigt.</span><span class="sxs-lookup"><span data-stu-id="f40a3-211">Unity has a great article that gives an overview and dives into batching draw calls for their platform.</span></span>
- [<span data-ttu-id="f40a3-212">Batchverarbeitung von Unity-Zeichenaufrufen</span><span class="sxs-lookup"><span data-stu-id="f40a3-212">Unity Draw Call Batching</span></span>](https://docs.unity3d.com/Manual/DrawCallBatching.html)

#### <a name="single-pass-instanced-rendering"></a><span data-ttu-id="f40a3-213">Single-Pass-Instanzrendering</span><span class="sxs-lookup"><span data-stu-id="f40a3-213">Single pass instanced rendering</span></span>

<span data-ttu-id="f40a3-214">Single-Pass-Instanzrendering in Unity ermöglicht es, die Zeichenaufrufe für jedes Auge auf einen instanziierten Zeichenaufruf zu reduzieren.</span><span class="sxs-lookup"><span data-stu-id="f40a3-214">Single Pass Instanced Rendering in Unity allows for draw calls for each eye to be reduced down to one instanced draw call.</span></span> <span data-ttu-id="f40a3-215">Aufgrund der Cachekohärenz zwischen zwei Zeichenaufrufen kommt es hier auch zu einer gewissen Leistungsverbesserung bei der GPU.</span><span class="sxs-lookup"><span data-stu-id="f40a3-215">Due to cache coherency between two draw calls, there is also some performance improvement on the GPU as well.</span></span>

<span data-ttu-id="f40a3-216">Aktivieren dieser Funktion in Ihrem Unity-Projekt</span><span class="sxs-lookup"><span data-stu-id="f40a3-216">To enable this feature in your Unity Project</span></span>
1)  <span data-ttu-id="f40a3-217">Öffnen Sie die **Player XR Settings** (Player XR-Einstellungen) (navigieren Sie zu **Edit** > **Project Settings** > **Player** > **XR Settings** („Bearbeiten > Projekteinstellungen > Player > XR-Einstellungen))</span><span class="sxs-lookup"><span data-stu-id="f40a3-217">Open **Player XR Settings** (go to **Edit** > **Project Settings** > **Player** > **XR Settings**)</span></span>
2) <span data-ttu-id="f40a3-218">Wählen Sie im Dropdownmenü **Stereo Rendering Method** (Stereo-Renderingmethode) **Single Pass Instanced** (Single-Pass-Instanz) aus (das Kontrollkästchen **Virtual Reality Supported** (Virtuelle Realität unterstützt) muss aktiviert sein)</span><span class="sxs-lookup"><span data-stu-id="f40a3-218">Select **Single Pass Instanced** from the **Stereo Rendering Method** drop-down menu (**Virtual Reality Supported** checkbox must be checked)</span></span>

<span data-ttu-id="f40a3-219">Details zu diesem Renderingansatz finden Sie in den folgenden Artikeln von Unity.</span><span class="sxs-lookup"><span data-stu-id="f40a3-219">Read the following articles from Unity for details with this rendering approach.</span></span>
- <span data-ttu-id="f40a3-220">[How to maximize AR and VR performance with advanced stereo rendering](https://blogs.unity3d.com/2017/11/21/how-to-maximize-ar-and-vr-performance-with-advanced-stereo-rendering/) (Maximieren der AR- und VR-Leistung mit erweitertem Stereorendering)</span><span class="sxs-lookup"><span data-stu-id="f40a3-220">[How to maximize AR and VR performance with advanced stereo rendering](https://blogs.unity3d.com/2017/11/21/how-to-maximize-ar-and-vr-performance-with-advanced-stereo-rendering/)</span></span>
- <span data-ttu-id="f40a3-221">[Single Pass Instancing](https://docs.unity3d.com/Manual/SinglePassInstancing.html) (Single-Pass-Instanziierung)</span><span class="sxs-lookup"><span data-stu-id="f40a3-221">[Single Pass Instancing](https://docs.unity3d.com/Manual/SinglePassInstancing.html)</span></span> 

>[!NOTE]
> <span data-ttu-id="f40a3-222">Ein häufiges Problem beim Single-Pass-Instanzrendering tritt auf, wenn Entwickler bereits vorhandene benutzerdefinierte Shader einsetzen, die noch nicht für die Instanziierung geschrieben wurden.</span><span class="sxs-lookup"><span data-stu-id="f40a3-222">One common issue with Single Pass Instanced Rendering occurs if developers already have existing custom shaders not written for instancing.</span></span> <span data-ttu-id="f40a3-223">Nach dem Aktivieren dieses Features stellen die Entwickler möglicherweise fest, dass manche Spielobjekte nur für ein Auge gerendert werden.</span><span class="sxs-lookup"><span data-stu-id="f40a3-223">After enabling this feature, developers may notice some GameObjects only render in one eye.</span></span> <span data-ttu-id="f40a3-224">Dies hat den Grund, dass die zugeordneten benutzerdefinierten Shader nicht die geeigneten Eigenschaften für die Instanziierung aufweisen.</span><span class="sxs-lookup"><span data-stu-id="f40a3-224">This is because the associated custom shaders do not have the appropriate properties for instancing.</span></span>
>
> <span data-ttu-id="f40a3-225">Informationen zum Beheben dieses Problems finden Sie unter [Single Pass Stereo Rendering for HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) (Single-Pass-Stereorendering für HoloLens) von Unity</span><span class="sxs-lookup"><span data-stu-id="f40a3-225">See [Single Pass Stereo Rendering for HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) from Unity for how to address this problem</span></span>

#### <a name="static-batching"></a><span data-ttu-id="f40a3-226">Statische Batchverarbeitung</span><span class="sxs-lookup"><span data-stu-id="f40a3-226">Static batching</span></span>

<span data-ttu-id="f40a3-227">Unity kann viele statische Objekte als Batch verarbeiten, um die Zeichenaufrufe an die GPU zu verringern.</span><span class="sxs-lookup"><span data-stu-id="f40a3-227">Unity is able to batch many static objects to reduce draw calls to the GPU.</span></span> <span data-ttu-id="f40a3-228">Die statische Batchverarbeitung funktioniert für die meisten [Rendererobjekte](https://docs.unity3d.com/ScriptReference/Renderer.html) in Unity, die **1) das Material gemeinsam haben** und **2) alle als *Static*** gekennzeichnet sind (Wählen Sie ein Objekt in Unity aus, und klicken Sie auf das Kontrollkästchen in der oberen rechten Ecke des Inspektors).</span><span class="sxs-lookup"><span data-stu-id="f40a3-228">Static Batching works for most [Renderer](https://docs.unity3d.com/ScriptReference/Renderer.html) objects in Unity that **1) share the same material** and **2) are all marked as *Static*** (Select an object in Unity and click the checkbox in the top right of the inspector).</span></span> <span data-ttu-id="f40a3-229">GameObjects, die als *Static* gekennzeichnet sind, können nicht durch die Runtime Ihrer Anwendung bewegt werden.</span><span class="sxs-lookup"><span data-stu-id="f40a3-229">GameObjects marked as *Static* cannot be moved throughout your application's runtime.</span></span> <span data-ttu-id="f40a3-230">Daher kann es schwierig sein, statische Batchverarbeitung für HoloLens zu nutzen, bei der praktisch jedes Objekt platziert, bewegt, skaliert usw. werden muss. Bei immersiven Headsets kann statische Batchverarbeitung die Anzahl der Zeichenaufrufe drastisch reduzieren und die Leistung so verbessern.</span><span class="sxs-lookup"><span data-stu-id="f40a3-230">Thus, static batching can be difficult to leverage on HoloLens where virtually every object needs to be placed, moved, scaled, etc. For immersive headsets, static batching can dramatically reduce draw calls and thus improve performance.</span></span>

<span data-ttu-id="f40a3-231">Weitere Details erfahren Sie unter *Static Batching* (Statische Batchverarbeitung) unter [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) (Batchverarbeitung von Zeichenaufrufen in Unity).</span><span class="sxs-lookup"><span data-stu-id="f40a3-231">Read *Static Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for more details.</span></span>

#### <a name="dynamic-batching"></a><span data-ttu-id="f40a3-232">Dynamische Batchverarbeitung</span><span class="sxs-lookup"><span data-stu-id="f40a3-232">Dynamic batching</span></span>

<span data-ttu-id="f40a3-233">Da es in der HoloLens-Entwicklung problematisch ist, Objekte als *Static* zu kennzeichnen, kann dynamische Batchverarbeitung ein hervorragendes Mittel darstellen, das Fehlen dieser Funktion zu kompensieren.</span><span class="sxs-lookup"><span data-stu-id="f40a3-233">Since it is problematic to mark objects as *Static* for HoloLens development, dynamic batching can be a great tool to compensate for this lacking feature.</span></span> <span data-ttu-id="f40a3-234">Natürlich kann es auch bei immersiven Headsets nützlich sein.</span><span class="sxs-lookup"><span data-stu-id="f40a3-234">Of course, it can also be useful on immersive headsets, as well.</span></span> <span data-ttu-id="f40a3-235">Die dynamische Batchverarbeitung in Unity kann aber schwierig zu aktivieren sein, da die GameObjects **a) das gleiche Material verwenden** und **b) eine lange Liste weiterer Kriterien erfüllen** müssen.</span><span class="sxs-lookup"><span data-stu-id="f40a3-235">However, dynamic batching in Unity can be difficult to enable because GameObjects must **a) share the same Material** and **b) meet a long list of other criteria**.</span></span>

<span data-ttu-id="f40a3-236">Die vollständige Liste finden Sie unter *Dynamic Batching* (Dynamische Batchverarbeitung) unter [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) (Batchverarbeitung von Zeichenaufrufen in Unity).</span><span class="sxs-lookup"><span data-stu-id="f40a3-236">Read *Dynamic Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for the full list.</span></span> <span data-ttu-id="f40a3-237">In den meisten Fällen wird die dynamische Batchverarbeitung von GameObjects ungültig, da die zugeordneten Gittermodelldaten nicht mehr als 300 Scheitelpunkte umfassen dürfen.</span><span class="sxs-lookup"><span data-stu-id="f40a3-237">Most commonly, GameObjects become invalid to be batched dynamically, because the associated mesh data can be no more than 300 vertices.</span></span>

#### <a name="other-techniques"></a><span data-ttu-id="f40a3-238">Andere Verfahren</span><span class="sxs-lookup"><span data-stu-id="f40a3-238">Other techniques</span></span>

<span data-ttu-id="f40a3-239">Batchverarbeitung kann nur erfolgen, wenn mehrere GameObjects gemeinsam dasselbe Material verwenden können.</span><span class="sxs-lookup"><span data-stu-id="f40a3-239">Batching can only occur if multiple GameObjects are able to share the same material.</span></span> <span data-ttu-id="f40a3-240">Normalerweise steht dem das Erfordernis gegenüber, dass GameObjects eine eindeutige Textur für ihr jeweiliges Material besitzen müssen.</span><span class="sxs-lookup"><span data-stu-id="f40a3-240">Typically, this will be blocked by the need for GameObjects to have a unique texture for their respective Material.</span></span> <span data-ttu-id="f40a3-241">Es ist üblich, Texturen in einer großen Textur zusammenzufassen, eine Methode, die als [Texture Atlasing](https://en.wikipedia.org/wiki/Texture_atlas) bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="f40a3-241">It is common to combine Textures into one big Texture, a method known as [Texture Atlasing](https://en.wikipedia.org/wiki/Texture_atlas).</span></span>

<span data-ttu-id="f40a3-242">Darüber hinaus ist es im allgemeinen vorzuziehen, Gittermodelle zu einem GameObject zu kombinieren, wo es möglich und vernünftig ist.</span><span class="sxs-lookup"><span data-stu-id="f40a3-242">Furthermore, it is generally preferable to combine meshes into one GameObject where possible and reasonable.</span></span> <span data-ttu-id="f40a3-243">Für jeden Renderer in Unity ist eine bestimmte Anzahl Zeichenaufrufe im Vergleich mit dem Übermitteln eines kombinierten Gittermodells unter einem Renderer typisch.</span><span class="sxs-lookup"><span data-stu-id="f40a3-243">Each Renderer in Unity will have its associated draw call(s) versus submitting a combined mesh under one Renderer.</span></span>

>[!NOTE]
> <span data-ttu-id="f40a3-244">Beim Ändern von Eigenschaften von „Renderer.material“ zur Laufzeit wird eine Kopie des Materials erstellt, was die Batchverarbeitung möglicherweise unmöglich macht.</span><span class="sxs-lookup"><span data-stu-id="f40a3-244">Modifying properties of Renderer.material at runtime will create a copy of the Material and thus potentially break batching.</span></span> <span data-ttu-id="f40a3-245">Verwenden Sie Renderer.sharedMaterial, um die mehreren GameObjects gemeinsamen Materialeigenschaften zu ändern.</span><span class="sxs-lookup"><span data-stu-id="f40a3-245">Use Renderer.sharedMaterial to modify shared material properties across GameObjects.</span></span>

## <a name="gpu-performance-recommendations"></a><span data-ttu-id="f40a3-246">GPU-Leistungsempfehlungen</span><span class="sxs-lookup"><span data-stu-id="f40a3-246">GPU performance recommendations</span></span>

<span data-ttu-id="f40a3-247">Weitere Informationen zum [Optimieren des Grafikrenderings in Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span><span class="sxs-lookup"><span data-stu-id="f40a3-247">Learn more about [optimizing graphics rendering in Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span></span>

### <a name="optimize-depth-buffer-sharing"></a><span data-ttu-id="f40a3-248">Optimieren der gemeinsamen Nutzung des Tiefenpuffers</span><span class="sxs-lookup"><span data-stu-id="f40a3-248">Optimize depth buffer sharing</span></span>

<span data-ttu-id="f40a3-249">Im Allgemeinen wird empfohlen, in den **Player XR-Einstellungen** die **Gemeinsame Nutzung des Tiefenpuffers** zu aktivieren, um die [Hologrammstabilität](Hologram-stability.md) zu optimieren.</span><span class="sxs-lookup"><span data-stu-id="f40a3-249">It is generally recommended to enable **Depth buffer sharing** under **Player XR Settings** to optimize for [hologram stability](Hologram-stability.md).</span></span> <span data-ttu-id="f40a3-250">Wenn die tiefenbasierte Neuprojektion in der Spätphase mit dieser Einstellung aktiviert wird, wird die Wahl des **16-Bit-Tiefenformats** anstelle des **24-Bit-Tiefenformats** empfohlen.</span><span class="sxs-lookup"><span data-stu-id="f40a3-250">When enabling depth-based late-stage reprojection with this setting however, it is recommended to select **16-bit depth format** instead of **24-bit depth format**.</span></span> <span data-ttu-id="f40a3-251">Die 16-Bit-Tiefenpuffer reduzieren die Bandbreite (und somit die erforderliche Leistung), die mit dem Tiefenpuffer-Datenverkehr einhergeht, drastisch.</span><span class="sxs-lookup"><span data-stu-id="f40a3-251">The 16-bit depth buffers will drastically reduce the bandwidth (and thus power) associated with depth buffer traffic.</span></span> <span data-ttu-id="f40a3-252">Dies kann sowohl für den Stromverbrauch als auch für die Leistungsverbesserung ein großer Gewinn sein.</span><span class="sxs-lookup"><span data-stu-id="f40a3-252">This can be a big win both in power reduction and performance improvement.</span></span> <span data-ttu-id="f40a3-253">Allerdings gibt es zwei mögliche negative Ergebnisse durch Einsatz des *16-Bit-Tiefenformats*.</span><span class="sxs-lookup"><span data-stu-id="f40a3-253">However, there are two possible negative outcomes by using *16-bit depth format*.</span></span>

<span data-ttu-id="f40a3-254">**Z-Fighting**</span><span class="sxs-lookup"><span data-stu-id="f40a3-254">**Z-Fighting**</span></span>

<span data-ttu-id="f40a3-255">Die verringerte Genauigkeit des Tiefenbereichs erhöht die Wahrscheinlichkeit von [Z-Fighting](https://en.wikipedia.org/wiki/Z-fighting) bei 16-Bit im Vergleich mit 24-Bit.</span><span class="sxs-lookup"><span data-stu-id="f40a3-255">The reduced depth range fidelity makes [z-fighting](https://en.wikipedia.org/wiki/Z-fighting) more likely to occur with 16-bit than 24-bit.</span></span> <span data-ttu-id="f40a3-256">Um diese Artefakte zu vermeiden, ändern Sie die Clippingebenen der [Unity-Kamera](https://docs.unity3d.com/Manual/class-Camera.html) für nah und fern, um der geringeren Genauigkeit Rechnung zu tragen.</span><span class="sxs-lookup"><span data-stu-id="f40a3-256">To avoid these artifacts, modify the near/far clip planes of the [Unity camera](https://docs.unity3d.com/Manual/class-Camera.html) to account for the lower precision.</span></span> <span data-ttu-id="f40a3-257">In HoloLens-basierten Anwendungen kann eine Clippingebene von 50 m anstelle des Unity-Standardwerts von 1000 m im Allgemeinen jegliches Z-Fighting beseitigen.</span><span class="sxs-lookup"><span data-stu-id="f40a3-257">For HoloLens-based applications, a far clip plane of 50m instead of the Unity default 1000m can generally eliminate any z-fighting.</span></span>

<span data-ttu-id="f40a3-258">**Deaktivierter Schablonenpuffer**</span><span class="sxs-lookup"><span data-stu-id="f40a3-258">**Disabled Stencil Buffer**</span></span>

<span data-ttu-id="f40a3-259">Wenn Unity eine [Rendertextur mit 16-Bit Tiefe](https://docs.unity3d.com/ScriptReference/RenderTexture-depth.html) erstellt, wird kein Schablonenpuffer erstellt.</span><span class="sxs-lookup"><span data-stu-id="f40a3-259">When Unity creates a [Render Texture with 16-bit depth](https://docs.unity3d.com/ScriptReference/RenderTexture-depth.html), there is no stencil buffer created.</span></span> <span data-ttu-id="f40a3-260">Beim Auswählen eines Formats mit 24-Bit Tiefe wird gemäß der Unity-Dokumentation ein 24-Bit-Z-Puffer erstellt sowie ein [8-Bit-Schablonenpuffer] (https://docs.unity3d.com/Manual/SL-Stencil.html) (wenn 32-Bit auf einem Gerät möglich sind, was aber allgemein der Fall ist, etwa bei HoloLens).</span><span class="sxs-lookup"><span data-stu-id="f40a3-260">Selecting 24-bit depth format, per Unity documentation, will create a 24-bit z-buffer, as well as an [8-bit stencil buffer] (https://docs.unity3d.com/Manual/SL-Stencil.html) (if 32-bit is applicable on a device, which is generally the case such as HoloLens).</span></span>

### <a name="avoid-full-screen-effects"></a><span data-ttu-id="f40a3-261">Vermeiden von Vollbildeffekten</span><span class="sxs-lookup"><span data-stu-id="f40a3-261">Avoid full-screen effects</span></span>

<span data-ttu-id="f40a3-262">Techniken, die im Vollbildmodus arbeiten, können ziemlich teuer sein, da sie die Größenordnung von Millionen von Vorgängen pro Frame erreichen.</span><span class="sxs-lookup"><span data-stu-id="f40a3-262">Techniques that operate on the full screen can be quite expensive since their order of magnitude is millions of operations every frame.</span></span> <span data-ttu-id="f40a3-263">Daher wird empfohlen, [Effekte der Nachbearbeitung](https://docs.unity3d.com/Manual/PostProcessingOverview.html) wie Antialiasing, Blooming und mehr zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="f40a3-263">Thus, it is recommended to avoid [post-processing effects](https://docs.unity3d.com/Manual/PostProcessingOverview.html) such as anti-aliasing, bloom, and more.</span></span>

### <a name="optimal-lighting-settings"></a><span data-ttu-id="f40a3-264">Optimale Beleuchtungseinstellungen</span><span class="sxs-lookup"><span data-stu-id="f40a3-264">Optimal lighting settings</span></span>

<span data-ttu-id="f40a3-265">Die [globale Beleuchtung in Echtzeit](https://docs.unity3d.com/Manual/GIIntro.html) in Unity kann herausragende visuelle Ergebnisse produzieren, bringt jedoch ziemlich umfangreiche Beleuchtungsberechnungen mit sich.</span><span class="sxs-lookup"><span data-stu-id="f40a3-265">[Real-time Global Illumination](https://docs.unity3d.com/Manual/GIIntro.html) in Unity can provide outstanding visual results but involves quite expensive lighting calculations.</span></span> <span data-ttu-id="f40a3-266">Es wird empfohlen, die globale Beleuchtung in Echtzeit für jede Unity-Szenendatei mit dieser Einstellung zu deaktivieren: **Window** > **Rendering** > **Lighting Settings** > Uncheck **Real-time Global Illumination** (Fenster > Rendering > Beleuchtungseinstellungen > Globale Beleuchtung in Echtzeit deaktivieren).</span><span class="sxs-lookup"><span data-stu-id="f40a3-266">It is recommended to disable Realtime Global Illumination for every Unity scene file via **Window** > **Rendering** > **Lighting Settings** > Uncheck **Real-time Global Illumination**.</span></span>

<span data-ttu-id="f40a3-267">Ferner wird empfohlen, jede Art von Schattenwurf zu deaktivieren, da dieser ebenfalls teure GPU-Durchgänge für eine Unity-Szene mit sich bringt.</span><span class="sxs-lookup"><span data-stu-id="f40a3-267">Furthermore, it is recommended to disable all shadow casting as these also add expensive GPU passes onto a Unity scene.</span></span> <span data-ttu-id="f40a3-268">Schatten können durch Licht deaktiviert werden, lassen sich über die Qualitätseinstellungen aber auch im Ganzen steuern.</span><span class="sxs-lookup"><span data-stu-id="f40a3-268">Shadows can be disable per light but can also be controlled holistically via Quality settings.</span></span>

<span data-ttu-id="f40a3-269">**Edit** > **Project Settings** (Bearbeiten > Projekteinstellungen), wählen Sie dann die Kategorie **Quality** (Qualität) aus > wählen Sie **Low Quality** (Niedrige Qualität) für die UWP-Plattform.</span><span class="sxs-lookup"><span data-stu-id="f40a3-269">**Edit** > **Project Settings**, then select the **Quality** category > Select **Low Quality** for the UWP Platform.</span></span> <span data-ttu-id="f40a3-270">Sie können auch einfach die **Shadows**-Eigenschaft (Schatten) auf **Disable Shadows** (Schatten deaktivieren) festlegen.</span><span class="sxs-lookup"><span data-stu-id="f40a3-270">One can also just set the **Shadows** property to **Disable Shadows**.</span></span>

<span data-ttu-id="f40a3-271">Es empfiehlt sich, für Ihre Modelle in Unity „Baked Lighting“ (vorab gerenderte Lichtdetails) zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="f40a3-271">It is recommended that you use baked lighting with your models in Unity.</span></span>

### <a name="reduce-poly-count"></a><span data-ttu-id="f40a3-272">Reduzieren der Polygonanzahl</span><span class="sxs-lookup"><span data-stu-id="f40a3-272">Reduce poly count</span></span>

<span data-ttu-id="f40a3-273">Das Reduzieren der Polygonanzahl wird normalerweise durch eins dieser Verfahren erreicht</span><span class="sxs-lookup"><span data-stu-id="f40a3-273">Polygon count is usually reduced by either</span></span>
1) <span data-ttu-id="f40a3-274">Entfernen von Objekten aus einer Szene</span><span class="sxs-lookup"><span data-stu-id="f40a3-274">Removing objects from a scene</span></span>
2) <span data-ttu-id="f40a3-275">Starke Herabsetzung der Medienobjekte, wodurch sich die Anzahl der Polygone für ein bestimmtes Gittermodell reduziert</span><span class="sxs-lookup"><span data-stu-id="f40a3-275">Asset decimation which reduces the number of polygons for a given mesh</span></span>
3) <span data-ttu-id="f40a3-276">Implementieren eines [Level of Detail (LOD) System](https://docs.unity3d.com/Manual/LevelOfDetail.html) (Detailstufensystems) in Ihrer Anwendung, bei der weit entfernte Objekte mit einer aus weniger Polygonen bestehenden Version der gleichen Geometrie gerendert werden</span><span class="sxs-lookup"><span data-stu-id="f40a3-276">Implementing a [Level of Detail (LOD) System](https://docs.unity3d.com/Manual/LevelOfDetail.html) into your application which renders far away objects with lower-polygon version of the same geometry</span></span>

### <a name="understanding-shaders-in-unity"></a><span data-ttu-id="f40a3-277">Grundlegendes zu Shadern in Unity</span><span class="sxs-lookup"><span data-stu-id="f40a3-277">Understanding shaders in Unity</span></span>

<span data-ttu-id="f40a3-278">Eine einfache Annäherung für den Leistungsvergleich von Shadern besteht darin, die durchschnittliche Anzahl der Vorgänge zu bestimmen, die jeder zur Laufzeit ausführt.</span><span class="sxs-lookup"><span data-stu-id="f40a3-278">An easy approximation to compare shaders in performance is to identify the average number of operations each executes at runtime.</span></span> <span data-ttu-id="f40a3-279">Dies kann in Unity sehr einfach erfolgen.</span><span class="sxs-lookup"><span data-stu-id="f40a3-279">This can be done easily in Unity.</span></span>

1) <span data-ttu-id="f40a3-280">Wählen Sie Ihr Shadermedienobjekt oder ein Material aus, und wählen Sie dann in der oberen rechten Ecke des Inspektorfensters das Zahnradsymbol aus, gefolgt von **„Select Shader“** (Shader auswählen)</span><span class="sxs-lookup"><span data-stu-id="f40a3-280">Select your shader asset or select a material, then in the top right corner of the inspector window, select the gear icon followed by **"Select Shader"**</span></span>

    ![Auswählen eines Shaders in Unity](images/Select-shader-unity.png)
2) <span data-ttu-id="f40a3-282">Klicken Sie bei ausgewähltem Shadermedienobjekt auf die Schaltfläche **„Compile and show code“** (Compilieren und Code anzeigen) unter dem Inspektorfenster</span><span class="sxs-lookup"><span data-stu-id="f40a3-282">With the shader asset selected, click the **"Compile and show code"** button under the inspector window</span></span>

    ![Kompilieren von Shadercode in Unity](images/compile-shader-code-unity.PNG)

3) <span data-ttu-id="f40a3-284">Suchen Sie nach dem Compilieren nach dem Statistikabschnitt in den Ergebnissen mit der Anzahl der verschiedenen Vorgänge sowohl für den Vertex- als auch für den Pixelshader (Hinweis: Pixelshader werden auch häufig als Fragmentshader bezeichnet)</span><span class="sxs-lookup"><span data-stu-id="f40a3-284">After compiling, look for the statistics section in the results with the number of different operations for both the vertex and pixel shader (Note: pixel shaders are often also called fragment shaders)</span></span>

    ![Standardshadervorgänge in Unity](images/unity-standard-shader-compilation.png)

#### <a name="optimize-pixel-shaders"></a><span data-ttu-id="f40a3-286">Optimieren von Pixelshadern</span><span class="sxs-lookup"><span data-stu-id="f40a3-286">Optimize pixel shaders</span></span>

<span data-ttu-id="f40a3-287">Beim Blick auf die compilierten Statistikergebnisse unter Verwendung der Methode oben zeigt sich, dass der [Fragmentshader](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) im Mittel mehr Vorgänge als der [Vertexshader](https://en.wikipedia.org/wiki/Shader#Vertex_shaders) ausführt.</span><span class="sxs-lookup"><span data-stu-id="f40a3-287">Looking at the compiled statistic results using the method above, the [fragment shader](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) will generally execute more operations than the [vertex shader](https://en.wikipedia.org/wiki/Shader#Vertex_shaders), on average.</span></span> <span data-ttu-id="f40a3-288">Der Fragmentshader, auch als Pixelshader bezeichnet, wird pro Pixel der Bildschirmausgabe ausgeführt, während der Vertexshader nur pro Scheitelpunkt aller Gittermodelle ausgeführt wird, die auf dem Bildschirm gezeichnet werden.</span><span class="sxs-lookup"><span data-stu-id="f40a3-288">The fragment shader, also known as the pixel shader, is executed per pixel on the screen output while the vertex shader is only executed per-vertex of all meshes being drawn to the screen.</span></span> 

<span data-ttu-id="f40a3-289">Daher weisen Fragmentshader aufgrund der vielen Beleuchtungsberechnungen nicht nur mehr Anweisungen auf, sie werden auch fast immer auf einem größeren Dataset ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="f40a3-289">Thus, not only do fragment shaders have more instructions than vertex shaders because of all the lighting calculations, fragment shaders are almost always executed on a larger dataset.</span></span> <span data-ttu-id="f40a3-290">Wenn die Bildschirmausgabe beispielsweise ein Bild mit 2.000 mal 2.000 Pixeln ist, kann der Fragmentshader 2.000\*2.000 = 4.000.000 Mal ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="f40a3-290">For example, if the screen output is a 2k by 2k image, then the fragment shader can get executed 2,000\*2,000 = 4,000,000 times.</span></span> <span data-ttu-id="f40a3-291">Wenn zwei Augen gerendert werden, verdoppelt sich diese Zahl, da zwei Bildschirme vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="f40a3-291">If rendering two eyes, this number doubles since there are two screens.</span></span> <span data-ttu-id="f40a3-292">Wenn eine Mixed Reality-Anwendung mehrere Durchgänge, Nachbearbeitungseffekte im Vollbildmodus und/oder Rendering mehrerer Gittermodelle für das gleiche Pixel aufweist, erhöht sich diese Zahl dramatisch.</span><span class="sxs-lookup"><span data-stu-id="f40a3-292">If a mixed reality application has multiple passes, full-screen post-processing effects, or rendering multiple meshes to the same pixel, this number will increase dramatically.</span></span> 

<span data-ttu-id="f40a3-293">Daher können mit dem Verringern der Zahl der Vorgänge im Fragmentshader im Allgemeinen viel größere Leistungssteigerungen als durch Optimierungen im Vertexshader erreicht werden.</span><span class="sxs-lookup"><span data-stu-id="f40a3-293">Therefore, reducing the number of operations in the fragment shader can generally give far greater performance gains over optimizations in the vertex shader.</span></span>

#### <a name="unity-standard-shader-alternatives"></a><span data-ttu-id="f40a3-294">Alternativen zu den Unity-Standardshadern</span><span class="sxs-lookup"><span data-stu-id="f40a3-294">Unity Standard shader alternatives</span></span>

<span data-ttu-id="f40a3-295">Anstatt ein physikalisch basiertes Rendering (PBR) oder einen anderen hochwertigen Shader zu verwenden, sollten Sie einen leistungsfähigeren und kostengünstigeren Shader nutzen.</span><span class="sxs-lookup"><span data-stu-id="f40a3-295">Instead of using a physically based rendering (PBR) or another high-quality shader, look at utilizing a more performant and cheaper shader.</span></span> <span data-ttu-id="f40a3-296">Im [Mixed Reality-Toolkit](https://github.com/Microsoft/MixedRealityToolkit-Unity) steht der [MRTK-Standardshader](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) bereit, der für Mixed Reality-Projekte optimiert wurde.</span><span class="sxs-lookup"><span data-stu-id="f40a3-296">The [Mixed Reality Toolkit](https://github.com/Microsoft/MixedRealityToolkit-Unity) provides the [MRTK standard shader](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) that has been optimized for mixed reality projects.</span></span>

<span data-ttu-id="f40a3-297">Unity bietet darüber hinaus unlit (nicht beleuchtet), vertex lit (nach Scheitelpunkten beleuchtet), diffuse (diffus), und weitere vereinfachte Shaderoptionen, die im Vergleich erheblich schneller arbeiten als der Unity-Standardshader.</span><span class="sxs-lookup"><span data-stu-id="f40a3-297">Unity also provides an unlit, vertex lit, diffuse, and other simplified shader options that are significantly faster compared to the Unity Standard shader.</span></span> <span data-ttu-id="f40a3-298">Detailliertere Informationen finden Sie unter [Usage and Performance of Built-in Shaders](https://docs.unity3d.com/Manual/shader-Performance.html) (Verwendung und Leistung der integrierten Shader).</span><span class="sxs-lookup"><span data-stu-id="f40a3-298">See [Usage and Performance of Built-in Shaders](https://docs.unity3d.com/Manual/shader-Performance.html) for more detailed information.</span></span>

#### <a name="shader-preloading"></a><span data-ttu-id="f40a3-299">Vorabladen der Shader</span><span class="sxs-lookup"><span data-stu-id="f40a3-299">Shader preloading</span></span>

<span data-ttu-id="f40a3-300">Verwenden Sie *Vorabladen der Shader* und andere Tricks, um die [Shaderladezeiten](https://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html) zu optimieren.</span><span class="sxs-lookup"><span data-stu-id="f40a3-300">Use *Shader preloading* and other tricks to optimize [shader load time](https://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html).</span></span> <span data-ttu-id="f40a3-301">Insbesondere bedeutet Vorabladen der Shader, dass kein Hängen aufgrund von Shadercompilierung zur Laufzeit sichtbar wird.</span><span class="sxs-lookup"><span data-stu-id="f40a3-301">In particular, shader preloading means you won't see any hitches due to runtime shader compilation.</span></span>

### <a name="limit-overdraw"></a><span data-ttu-id="f40a3-302">Einschränken des Überzeichnens</span><span class="sxs-lookup"><span data-stu-id="f40a3-302">Limit overdraw</span></span>

<span data-ttu-id="f40a3-303">In Unity kann Überzeichnung für eine Szene angezeigt werden, indem ein Wert im [**Zeichenmodusmenü**](https://docs.unity3d.com/Manual/ViewModes.html) in der oberen linken Ecke der **Szenenansicht** auf **Overdraw** (Überzeichnung) umgeschaltet wird.</span><span class="sxs-lookup"><span data-stu-id="f40a3-303">In Unity, one can display overdraw for their scene, by toggling the [**draw mode menu**](https://docs.unity3d.com/Manual/ViewModes.html) in the top-left corner of the **Scene view** and selecting **Overdraw**.</span></span>

<span data-ttu-id="f40a3-304">Im Allgemeinen kann Überzeichnung durch rechtzeitiges Culling (Entfernen der Rückseiten) von Objekten abgemildert werden, bevor sie an die GPU gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="f40a3-304">Generally, overdraw can be mitigated by culling objects ahead of time before they are sent to the GPU.</span></span> <span data-ttu-id="f40a3-305">Unity bietet ausführliche Informationen zum Implementieren von [Occlusion Culling](https://docs.unity3d.com/Manual/OcclusionCulling.html) (Verdeckungs-Culling) für ihre Engine.</span><span class="sxs-lookup"><span data-stu-id="f40a3-305">Unity provides details on implementing [Occlusion Culling](https://docs.unity3d.com/Manual/OcclusionCulling.html) for their engine.</span></span>

## <a name="memory-recommendations"></a><span data-ttu-id="f40a3-306">Empfehlungen zum Arbeitsspeicher</span><span class="sxs-lookup"><span data-stu-id="f40a3-306">Memory recommendations</span></span>

<span data-ttu-id="f40a3-307">Exzessive Zuweisungsvorgänge von Arbeitsspeicher und deren Aufhebung können in Ihrer Holografieanwendung negative Effekte zeigen, die zu inkonsistenter Leistung, eingefrorenen Frames und anderem abträglichem Verhalten führen.</span><span class="sxs-lookup"><span data-stu-id="f40a3-307">Excessive memory allocation & deallocation operations can have adverse effects on your holographic application, resulting in inconsistent performance, frozen frames, and other detrimental behavior.</span></span> <span data-ttu-id="f40a3-308">Das Verstehen der Arbeitsspeicheraspekte ist beim Entwickeln in Unity besonders wichtig, da die Arbeitsspeicherverwaltung vom Garbage Collector gesteuert wird.</span><span class="sxs-lookup"><span data-stu-id="f40a3-308">It is especially important to understand memory considerations when developing in Unity since memory management is controlled by the garbage collector.</span></span>

#### <a name="garbage-collection"></a><span data-ttu-id="f40a3-309">Garbage Collection</span><span class="sxs-lookup"><span data-stu-id="f40a3-309">Garbage collection</span></span>

<span data-ttu-id="f40a3-310">Holografie-Apps verlieren Prozessorzeit an den Garbage Collector (GC), wenn der GC aktiviert wird, um Objekte zu analysieren, die sich während der Ausführung nicht mehr im Bereich befinden und deren Arbeitsspeicher freigegeben werden muss, damit er für die Wiederverwendung zur Verfügung steht.</span><span class="sxs-lookup"><span data-stu-id="f40a3-310">Holographic apps will lose processing compute time to the garbage collector (GC) when the GC is activated to analyze objects that are no longer in scope during execution and their memory needs to be released, so it can be made available for re-use.</span></span> <span data-ttu-id="f40a3-311">Ständiges Zuweisen und Freigeben macht häufigere Läufe des Garbage Collectors erforderlich, was Leistung und Benutzererfahrung beeinträchtigt.</span><span class="sxs-lookup"><span data-stu-id="f40a3-311">Constant allocations and de-allocations will generally require the garbage collector to run more frequently, thus hurting performance and user experience.</span></span>

<span data-ttu-id="f40a3-312">Unity hat eine hervorragende Seite zur Verfügung gestellt, auf der die Arbeitsweise des Garbage Collectors detailliert beschrieben ist und Tipps zum Schreiben von – im Hinblick auf die Speicherverwaltung – effizienterem Code gegeben werden.</span><span class="sxs-lookup"><span data-stu-id="f40a3-312">Unity has provided an excellent page that explains in detail how the garbage collector works and tips to write more efficient code in regards to memory management.</span></span>
- [<span data-ttu-id="f40a3-313">Optimieren der Garbage Collection in Unity-Spielen</span><span class="sxs-lookup"><span data-stu-id="f40a3-313">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)

<span data-ttu-id="f40a3-314">Eine der gängigsten Methoden, die zu einer übermäßigen Garbage Collection führt, besteht darin, in der Unity-Entwicklung keine Verweise auf Komponenten und Klassen zwischenzuspeichern.</span><span class="sxs-lookup"><span data-stu-id="f40a3-314">One of the most common practices that leads to excessive garbage collection is not caching references to components and classes in Unity development.</span></span> <span data-ttu-id="f40a3-315">Alle Verweise sollten während Start() oder Awake() erfasst und in späteren Funktionen wie Update() oder LateUpdate() wiederverwendet werden.</span><span class="sxs-lookup"><span data-stu-id="f40a3-315">Any references should be captured during Start() or Awake() and re-used in later functions such as Update() or LateUpdate().</span></span>

<span data-ttu-id="f40a3-316">Weitere schnelle Tipps:</span><span class="sxs-lookup"><span data-stu-id="f40a3-316">Other quick tips:</span></span>
- <span data-ttu-id="f40a3-317">Verwenden Sie die [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2)-Klasse von C#, um dynamisch zur Laufzeit komplexe Zeichenfolgen zu generieren</span><span class="sxs-lookup"><span data-stu-id="f40a3-317">Use the [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2) C# class to dynamically build complex strings at runtime</span></span>
- <span data-ttu-id="f40a3-318">Entfernen Sie Aufrufe von Debug.Log(), wenn sie nicht mehr erforderlich sind, da sie in allen Buildversionen einer App trotzdem noch ausgeführt werden</span><span class="sxs-lookup"><span data-stu-id="f40a3-318">Remove calls to Debug.Log() when no longer needed, as they still execute in all build versions of an app</span></span>
- <span data-ttu-id="f40a3-319">Wenn Ihre Holografie-App allgemein viel Arbeitsspeicher erfordert, erwägen Sie das Aufrufen von [_**System.GC.Collect()**_](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2) in Ladephasen etwa beim Anzeigen eines Lade- oder Übergangsbildschirms</span><span class="sxs-lookup"><span data-stu-id="f40a3-319">If your holographic app generally requires lots of memory, consider calling  [_**System.GC.Collect()**_](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2) during loading phases such as when presenting a loading or transition screen</span></span>

#### <a name="object-pooling"></a><span data-ttu-id="f40a3-320">Objektpooling</span><span class="sxs-lookup"><span data-stu-id="f40a3-320">Object pooling</span></span>

<span data-ttu-id="f40a3-321">Objektpooling ist eine gängige Methode, um die Kosten für fortlaufende Zuordnungen von Objekten und deren Aufhebung zu reduzieren.</span><span class="sxs-lookup"><span data-stu-id="f40a3-321">Object pooling is a popular technique to reduce the cost of continuous allocations & deallocations of objects.</span></span> <span data-ttu-id="f40a3-322">Dies erfolgt durch Zuordnen eines großen Pools identischer Objekte und Wiederverwendung inaktiver, verfügbarer Instanzen aus diesem Pool, statt im Lauf der Zeit ständig neue Objekte zu erstellen und zu entfernen.</span><span class="sxs-lookup"><span data-stu-id="f40a3-322">This is done by allocating a large pool of identical objects and re-using inactive, available instances from this pool instead of constantly spawning and destroying objects over time.</span></span> <span data-ttu-id="f40a3-323">Objektpools eignen sich hervorragend für wiederverwendbare Komponenten, die im Rahmen einer App eine variable Lebensdauer haben.</span><span class="sxs-lookup"><span data-stu-id="f40a3-323">Object pools are great for re-useable components that have variable lifetime during an app.</span></span>

- [<span data-ttu-id="f40a3-324">Tutorial zum Objektpooling in Unity</span><span class="sxs-lookup"><span data-stu-id="f40a3-324">Object Pooling Tutorial in Unity</span></span>](https://unity3d.com/learn/tutorials/topics/scripting/object-pooling) 

## <a name="startup-performance"></a><span data-ttu-id="f40a3-325">Startleistung</span><span class="sxs-lookup"><span data-stu-id="f40a3-325">Startup performance</span></span>

<span data-ttu-id="f40a3-326">Sie sollten erwägen, Ihre App mit einer kleineren Szene zu starten und dann *[SceneManager.LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* zu verwenden, um den Rest der Szene zu laden.</span><span class="sxs-lookup"><span data-stu-id="f40a3-326">You should consider starting your app with a smaller scene, then using *[SceneManager.LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* to load the rest of the scene.</span></span> <span data-ttu-id="f40a3-327">Dadurch kann Ihre App so schnell wie möglich in einen interaktiven Zustand gelangen.</span><span class="sxs-lookup"><span data-stu-id="f40a3-327">This allows your app to get to an interactive state as fast as possible.</span></span> <span data-ttu-id="f40a3-328">Beachten Sie, dass es beim Aktivieren der neuen Szene zu einer großen CPU-Spitze kommen kann, und dass alle gerenderten Inhalte möglicherweise stockend oder hängend ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="f40a3-328">Be aware that there may be a large CPU spike while the new scene is being activated and that any rendered content might stutter or hitch.</span></span> <span data-ttu-id="f40a3-329">Eine Möglichkeit, dies zu umgehen, besteht darin, die AsyncOperation.allowSceneActivation-Eigenschaft für die zu ladende Szene auf „false“ festzulegen, das Laden der Szene abzuwarten, den Bildschirm auf schwarz zu setzen und den Wert der Eigenschaft dann wieder auf „true“ festzulegen, um die Szenenaktivierung abzuschließen.</span><span class="sxs-lookup"><span data-stu-id="f40a3-329">One way to work around this is to set the AsyncOperation.allowSceneActivation property to "false" on the scene being loaded, wait for the scene to load, clear the screen to black, and then set it back to "true" to complete the scene activation.</span></span>

<span data-ttu-id="f40a3-330">Beachten Sie, dass während des Ladens der Startszene für den Benutzer der holografische Begrüßungsbildschirm angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="f40a3-330">Remember that while the startup scene is loading, the holographic splash screen will be displayed to the user.</span></span>

## <a name="see-also"></a><span data-ttu-id="f40a3-331">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="f40a3-331">See also</span></span>
- [<span data-ttu-id="f40a3-332">Optimieren des Grafikrenderings in Unity-Spielen</span><span class="sxs-lookup"><span data-stu-id="f40a3-332">Optimizing graphics rendering in Unity games</span></span>](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games?playlist=44069)
- [<span data-ttu-id="f40a3-333">Optimieren der Garbage Collection in Unity-Spielen</span><span class="sxs-lookup"><span data-stu-id="f40a3-333">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)
- <span data-ttu-id="f40a3-334">[Bewährte Methoden für die Physische Effekte [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span><span class="sxs-lookup"><span data-stu-id="f40a3-334">[Physics Best Practices [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span></span>
- <span data-ttu-id="f40a3-335">[Optimieren von Skripts [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span><span class="sxs-lookup"><span data-stu-id="f40a3-335">[Optimizing Scripts [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span></span>
