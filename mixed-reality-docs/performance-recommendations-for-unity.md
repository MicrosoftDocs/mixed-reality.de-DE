---
title: Empfehlungen zur Leistung für Unity
description: Unity-spezifische Tipps zum Verbessern der Leistung in mixed Reality-apps.
author: Troy-Ferrell
ms.author: trferrel
ms.date: 03/26/2019
ms.topic: article
keywords: Grafiken, cpu, Gpu, rendering und Garbagecollection hololens
ms.openlocfilehash: b0821f07184bff8630f6b6af0d0fc461f6fcd133
ms.sourcegitcommit: 8f3ff9738397d9b9fdf4703b14b89d416f0186a5
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 07/12/2019
ms.locfileid: "67843332"
---
# <a name="performance-recommendations-for-unity"></a><span data-ttu-id="25484-104">Empfehlungen zur Leistung für Unity</span><span class="sxs-lookup"><span data-stu-id="25484-104">Performance recommendations for Unity</span></span>

<span data-ttu-id="25484-105">Dieser Artikel baut auf die Diskussion, die in beschriebenen [Empfehlungen zur Leistung für mixed Reality](understanding-performance-for-mixed-reality.md) aber konzentriert sich auf Erkenntnisse, die spezifisch für die Unity-Engine-Umgebung.</span><span class="sxs-lookup"><span data-stu-id="25484-105">This article builds on the discussion outlined in [performance recommendations for mixed reality](understanding-performance-for-mixed-reality.md) but focuses on learnings specific to the Unity engine environment.</span></span>

<span data-ttu-id="25484-106">Es ist auch dringend empfohlen, dass Entwickler die [umgebungseinstellungen für die Unity-Artikel empfohlen](Recommended-settings-for-unity.md).</span><span class="sxs-lookup"><span data-stu-id="25484-106">It is also highly advisable that developers review the [recommended environment settings for Unity article](Recommended-settings-for-unity.md).</span></span> <span data-ttu-id="25484-107">Dieser Artikel enthält Inhalt, mit einigen der wichtigsten Szene Konfigurationen im Hinblick auf Leistung Mixed Reality-apps zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="25484-107">This article has content with some of the most important scene configurations in regards to building performant Mixed Reality apps.</span></span> <span data-ttu-id="25484-108">Einige dieser empfohlenen Einstellungen werden auch hervorgehoben.</span><span class="sxs-lookup"><span data-stu-id="25484-108">Some of these recommended settings are highlighted below as well.</span></span>

## <a name="how-to-profile-with-unity"></a><span data-ttu-id="25484-109">Wie Sie ein Profil mit Unity</span><span class="sxs-lookup"><span data-stu-id="25484-109">How to profile with Unity</span></span>

<span data-ttu-id="25484-110">Unity bietet die **[Unity-Profiler](https://docs.unity3d.com/Manual/Profiler.html)** integrierte handelt es sich hervorragend zum Sammeln von wertvollen Performance Insights für Ihre spezielle app.</span><span class="sxs-lookup"><span data-stu-id="25484-110">Unity provides the **[Unity Profiler](https://docs.unity3d.com/Manual/Profiler.html)** built-in which is a great resource to gather valuable performance insights for your particular app.</span></span> <span data-ttu-id="25484-111">Auch wenn eine der Profiler im Editor ausgeführt werden kann, diese Metriken entsprechen nicht den true-Laufzeitumgebung und daher Ergebnisse aus dieser sollte verwendet werden mit Vorsicht.</span><span class="sxs-lookup"><span data-stu-id="25484-111">Although one can run the profiler in-editor, these metrics do not represent the true runtime environment and thus, results from this should be used cautiously.</span></span> <span data-ttu-id="25484-112">Es wird die für die genaue und verfolgbare Einblicke auf Gerät ausgeführte Anwendung Remote-Profil empfohlen.</span><span class="sxs-lookup"><span data-stu-id="25484-112">It is recommended to remotely profile your application while running on device for most accurate and actionable insights.</span></span> <span data-ttu-id="25484-113">Darüber hinaus von Unity [Frame Debugger](https://docs.unity3d.com/Manual/FrameDebugger.html) ist auch eine sehr leistungsfähige und Insight-Tool verwenden.</span><span class="sxs-lookup"><span data-stu-id="25484-113">Further, Unity's [Frame Debugger](https://docs.unity3d.com/Manual/FrameDebugger.html)  is also a very powerful and insight tool to utilize.</span></span>

<span data-ttu-id="25484-114">Unity bietet hervorragenden Dokumentation:</span><span class="sxs-lookup"><span data-stu-id="25484-114">Unity provides great documentation for:</span></span>
1) <span data-ttu-id="25484-115">Herstellen einer Verbindung die [Unity-Profiler für UWP-Anwendungen per Remotezugriff](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span><span class="sxs-lookup"><span data-stu-id="25484-115">How to connect the [Unity profiler to UWP applications remotely](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span></span>
2) <span data-ttu-id="25484-116">Wie effektiv [Diagnostizieren von Leistungsproblemen im Zusammenhang mit der Unity-Profiler](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span><span class="sxs-lookup"><span data-stu-id="25484-116">How to effectively [diagnose performance problems with the Unity Profiler](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span></span>

>[!NOTE]
> <span data-ttu-id="25484-117">Mit der Unity-Profiler verbunden und nach dem Hinzufügen des GPU-Profilers (finden Sie unter *hinzufügen Profiler* in oberen rechten Ecke), sehen, wie viel Zeit für die CPU und GPU bzw. in der Mitte des Profilers aufgewendet wird.</span><span class="sxs-lookup"><span data-stu-id="25484-117">With the Unity Profiler connected and after adding the GPU profiler (see *Add Profiler* in top right corner), one can see how much time is being spent on the CPU & GPU respectively in the middle of the profiler.</span></span> <span data-ttu-id="25484-118">Dies kann der Entwickler eine schnelle Schätzung zu erhalten, wenn ihre Anwendung CPU oder GPU-gebunden ist.</span><span class="sxs-lookup"><span data-stu-id="25484-118">This allows the developer to get a quick approximation if their application is CPU or GPU bounded.</span></span>
>
> ![Unity CPU und GPU](images/unity-profiler-cpu-gpu.png)

## <a name="cpu-performance-recommendations"></a><span data-ttu-id="25484-120">Empfehlungen zur CPU-Leistung</span><span class="sxs-lookup"><span data-stu-id="25484-120">CPU performance recommendations</span></span>

<span data-ttu-id="25484-121">Der Inhalt weiter unten enthält weitere detaillierte Verfahren für die Leistung, insbesondere von gezielten für Unity & C# Entwicklung.</span><span class="sxs-lookup"><span data-stu-id="25484-121">The content below covers more in-depth performance practices, especially targeted for Unity & C# development.</span></span>

#### <a name="cache-references"></a><span data-ttu-id="25484-122">Cacheverweise</span><span class="sxs-lookup"><span data-stu-id="25484-122">Cache references</span></span>

<span data-ttu-id="25484-123">Es ist empfehlenswert, Cacheverweise auf alle relevanten Komponenten und "gameobjects" bei der Initialisierung.</span><span class="sxs-lookup"><span data-stu-id="25484-123">It is best practice to cache references to all relevant components and GameObjects at initialization.</span></span> <span data-ttu-id="25484-124">Dies ist, da die Funktionsaufrufe wiederholen, wie z. B. *[GetComponent\<T > ()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* sind deutlich teurer relativ zu den Arbeitsspeicher, die Kosten um einen Zeiger zu speichern.</span><span class="sxs-lookup"><span data-stu-id="25484-124">This is because repeating function calls such as *[GetComponent\<T>()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* are significantly more expensive relative to the memory cost to store a pointer.</span></span> <span data-ttu-id="25484-125">Dies gilt auch für die sehr, regelmäßig verwendete [Camera.main](https://docs.unity3d.com/ScriptReference/Camera-main.html).</span><span class="sxs-lookup"><span data-stu-id="25484-125">This also applies to to the very, regularly used [Camera.main](https://docs.unity3d.com/ScriptReference/Camera-main.html).</span></span> <span data-ttu-id="25484-126">*Camera.Main* verwendet tatsächlich nur *[FindGameObjectsWithTag()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* unterhalb der Prüfungsvorgänge Ihre szenengraph für ein Kameraobjekt mit sucht die *"MainCamera"*  Tag.</span><span class="sxs-lookup"><span data-stu-id="25484-126">*Camera.main* actually just uses *[FindGameObjectsWithTag()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* underneath which expensively searches your scene graph for a camera object with the *"MainCamera"* tag.</span></span>

```CS
using UnityEngine;
using System.Collections;

public class ExampleClass : MonoBehaviour
{
    private Camera cam;
    private CustomComponent comp;

    void Start() 
    {
        cam = Camera.main;
        comp = GetComponent<CustomComponent>();
    }

    void Update()
    {
        // Good
        this.transform.position = cam.transform.position + cam.transform.forward * 10.0f;

        // Bad
        this.transform.position = Camera.main.transform.position + Camera.main.transform.forward * 10.0f;

        // Good
        comp.DoSomethingAwesome();

        // Bad
        GetComponent<CustomComponent>().DoSomethingAwesome();
    }
}
```

>[!NOTE] 
> <span data-ttu-id="25484-127">Vermeiden Sie GetComponent(string)</span><span class="sxs-lookup"><span data-stu-id="25484-127">Avoid GetComponent(string)</span></span> <br/>
> <span data-ttu-id="25484-128">Bei Verwendung  *[GetComponent()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* , es gibt eine Reihe verschiedener Überladungen.</span><span class="sxs-lookup"><span data-stu-id="25484-128">When using *[GetComponent()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)*, there are a handful of different overloads.</span></span> <span data-ttu-id="25484-129">Es ist wichtig, immer die Implementierungen der Typ basiert, und nie die zeichenfolgenbasierte Suche Überladung zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="25484-129">It is important to always use the Type based implementations and never the string-based searching overload.</span></span> <span data-ttu-id="25484-130">Suchen nach der Zeichenfolge in der Szene ist deutlich teurer als bei der Suche nach Typ.</span><span class="sxs-lookup"><span data-stu-id="25484-130">Searching by string in your scene is significantly more costly than searching by Type.</span></span> <br/>
> <span data-ttu-id="25484-131">(Gut) Komponente GetComponent (Typ Type)</span><span class="sxs-lookup"><span data-stu-id="25484-131">(Good) Component GetComponent(Type type)</span></span> <br/>
> <span data-ttu-id="25484-132">(Gut) T GetComponent\<T >)</span><span class="sxs-lookup"><span data-stu-id="25484-132">(Good) T GetComponent\<T>()</span></span> <br/>
> <span data-ttu-id="25484-133">(Negativen) Komponente GetComponent(string) ></span><span class="sxs-lookup"><span data-stu-id="25484-133">(Bad) Component GetComponent(string)></span></span> <br/>

#### <a name="avoid-expensive-operations"></a><span data-ttu-id="25484-134">Vermeiden Sie teure Vorgänge</span><span class="sxs-lookup"><span data-stu-id="25484-134">Avoid expensive operations</span></span>

1) <span data-ttu-id="25484-135">**Vermeiden Sie die Verwendung von [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span><span class="sxs-lookup"><span data-stu-id="25484-135">**Avoid use of [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span></span>

    <span data-ttu-id="25484-136">Obwohl LINQ sehr übersichtlich und leicht zu lesen und Schreiben von sein kann, erfordert es im Allgemeinen wesentlich umfangreichere Berechnungen und insbesondere Weitere speicherbelegung als manuell den Algorithmus schreiben.</span><span class="sxs-lookup"><span data-stu-id="25484-136">Although LINQ can be very clean and easy to read and write, it generally requires much more computation and particularly more memory allocation than writing the algorithm out manually.</span></span>

    ```CS
    // Example Code
    using System.Linq;

    List<int> data = new List<int>();
    data.Any(x => x > 10);

    var result = from x in data
                 where x > 10
                 select x;
    ```

2) <span data-ttu-id="25484-137">**Allgemeine Unity-APIs**</span><span class="sxs-lookup"><span data-stu-id="25484-137">**Common Unity APIs**</span></span>

    <span data-ttu-id="25484-138">Bestimmte Unity-APIs kann zwar nützlich, zum Ausführen sehr teuer sein.</span><span class="sxs-lookup"><span data-stu-id="25484-138">Certain Unity APIs, although useful, can be very expensive to execute.</span></span> <span data-ttu-id="25484-139">Die meisten dieser umfassen Ihre gesamte szenengraph für eine passende Liste mit "gameobjects" suchen.</span><span class="sxs-lookup"><span data-stu-id="25484-139">Most of these involve searching your entire scene graph for some matching list of GameObjects.</span></span> <span data-ttu-id="25484-140">Diese Vorgänge können durch Zwischenspeichern der Verweise oder implementieren eine Manager-Komponente für die "gameobjects" betreffende um die Verweise zur Laufzeit zu verfolgen, in der Regel vermieden werden.</span><span class="sxs-lookup"><span data-stu-id="25484-140">These operations can generally be avoided by caching references or implementing a manager component for the GameObjects in question to track the references at runtime.</span></span>

        GameObject.SendMessage()
        GameObject.BroadcastMessage()
        UnityEngine.Object.Find()
        UnityEngine.Object.FindWithTag()
        UnityEngine.Object.FindObjectOfType()
        UnityEngine.Object.FindObjectsOfType()
        UnityEngine.Object.FindGameObjectsWithTag()
        UnityEngine.Object.FindGameObjectsWithTag()

>[!NOTE]
> <span data-ttu-id="25484-141">*[SendMessage()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)*  und *[BroadcastMessage()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* unter allen Umständen gelöscht werden soll.</span><span class="sxs-lookup"><span data-stu-id="25484-141">*[SendMessage()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)* and *[BroadcastMessage()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* should be eliminated at all costs.</span></span> <span data-ttu-id="25484-142">Diese Funktionen können Größenordnung von 1000 X langsamer als direkte Funktionsaufrufe sein.</span><span class="sxs-lookup"><span data-stu-id="25484-142">These functions can be on the order of 1000x slower than direct function calls.</span></span>

3) <span data-ttu-id="25484-143">**Beachten Sie, dass von boxing**</span><span class="sxs-lookup"><span data-stu-id="25484-143">**Beware of boxing**</span></span>

    <span data-ttu-id="25484-144">[Boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) ist ein Kernkonzept von der C# Sprach- und Runtime.</span><span class="sxs-lookup"><span data-stu-id="25484-144">[Boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) is a core concept of the C# language and runtime.</span></span> <span data-ttu-id="25484-145">Es ist der Prozess der wrapping Wert typisierte Variablen wie Char "," Int "," Bool "," usw. in der Referenz typisierte Variablen.</span><span class="sxs-lookup"><span data-stu-id="25484-145">It is the process of wrapping value-typed variables such as char, int, bool, etc. into reference-typed variables.</span></span> <span data-ttu-id="25484-146">Wenn eine Variable Wert eingegeben "geschachtelt" wird, wird es in ein System.Object verwandelt umschlossen, der auf dem verwalteten Heap gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="25484-146">When a value-typed variable is "boxed", it is wrapped inside of a System.Object which is stored on the managed heap.</span></span> <span data-ttu-id="25484-147">Daher wird Arbeitsspeicher belegt und schließlich entfernt von der Garbage Collector verarbeitet werden müssen.</span><span class="sxs-lookup"><span data-stu-id="25484-147">Thus, memory is allocated and eventually when disposed must be processed by the garbage collector.</span></span> <span data-ttu-id="25484-148">Diese speicherzuordnungen und Aufhebungen fallen Kosten der Leistung in vielen Szenarios sind nicht erforderlich und können einfach durch eine kostengünstigere Alternative ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="25484-148">These allocations and deallocations incur a performance cost and in many scenarios are unnecessary or can be easily replaced by a less expensive alternative.</span></span>

#### <a name="repeating-code-paths"></a><span data-ttu-id="25484-149">Sich wiederholende Codepfade</span><span class="sxs-lookup"><span data-stu-id="25484-149">Repeating code paths</span></span>

<span data-ttu-id="25484-150">Alle wiederholten Rückruffunktionen für Unity (d.h.)</span><span class="sxs-lookup"><span data-stu-id="25484-150">Any repeating Unity callback functions (i.e</span></span> <span data-ttu-id="25484-151">Update), die mehrere Male pro Sekunde ausgeführt werden, und/oder Frame sehr sorgfältig geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="25484-151">Update) that are executed many times per second and/or frame should be written very carefully.</span></span> <span data-ttu-id="25484-152">Hier keine aufwändigen Vorgänge werden große und konsistent auf die Leistung auswirken.</span><span class="sxs-lookup"><span data-stu-id="25484-152">Any expensive operations here will have huge and consistent impact on performance.</span></span>

1) <span data-ttu-id="25484-153">**Leere Rückruffunktionen**</span><span class="sxs-lookup"><span data-stu-id="25484-153">**Empty callback functions**</span></span>

    <span data-ttu-id="25484-154">Obwohl der folgende Code mag harmlosen in Ihrer Anwendung, insbesondere da jeder Unity-Skript automatisch initialisiert mit diesem Codeblock ist verlassen können diese leere Rückrufe tatsächlich sehr teuer werden.</span><span class="sxs-lookup"><span data-stu-id="25484-154">Although the code below may seem innocent to leave in your application, especially since every Unity script auto-initializes with this code block, these empty callbacks can actually become very expensive.</span></span> <span data-ttu-id="25484-155">Unity wird hin-und über eine nicht verwaltete/verwaltete Code-Grenze zwischen UnityEngine und Ihrer Anwendungscode ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="25484-155">Unity operates back and forth over an unmanaged/managed code boundary, between UnityEngine code and your application code.</span></span> <span data-ttu-id="25484-156">Über diese Brücke zum Wechseln des Kontexts ist ziemlich teuer, selbst wenn nichts ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="25484-156">Context switching over this bridge is fairly expensive even if there is nothing to execute.</span></span> <span data-ttu-id="25484-157">Dies ist besonders problematisch, wenn Ihre app Hunderte "gameobjects" mit Komponenten verfügt, die leere wiederholten Unity-Rückrufe.</span><span class="sxs-lookup"><span data-stu-id="25484-157">This becomes especially problematic if your app has 100's of GameObjects with components that have empty repeating Unity callbacks.</span></span>

    ```CS
    void Update()
    {
    }
    ```

>[!NOTE]
> <span data-ttu-id="25484-158">Update() ist die häufigste Manifestation dieses Leistungsproblem zu beheben, aber andere sich wiederholende Unity-Rückrufe wie den folgenden können ebenso als fehlerhaft, wenn es nicht schlimmer sein: FixedUpdate(), LateUpdate(), OnPostRender", OnPreRender(), OnRenderImage(), etc.</span><span class="sxs-lookup"><span data-stu-id="25484-158">Update() is the most common manifestation of this performance issue but other repeating Unity callbacks such as the following can be equally as bad if not worse: FixedUpdate(), LateUpdate(), OnPostRender", OnPreRender(), OnRenderImage(), etc.</span></span> 

2) <span data-ttu-id="25484-159">**Vorgänge bevorzugt ausgeführt wird, einmal pro Frame**</span><span class="sxs-lookup"><span data-stu-id="25484-159">**Operations to favor running once per frame**</span></span>

    <span data-ttu-id="25484-160">Die folgenden Unity-APIs sind allgemeine Vorgänge für viele Apps, Holographic.</span><span class="sxs-lookup"><span data-stu-id="25484-160">The following Unity APIs are common operations for many Holographic Apps.</span></span> <span data-ttu-id="25484-161">Zwar nicht immer möglich, die Ergebnisse dieser Funktionen können sehr häufig einmal berechnet werden, und die Ergebnisse, die erneut für die Anwendung für einen bestimmten Frame verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="25484-161">Although not always possible, the results from these functions can very commonly be computed once and the results re-utilized across the application for a given frame.</span></span>

    <span data-ttu-id="25484-162">(a) im Allgemeinen ist es empfiehlt sich, eine dedizierte Singleton-Klasse oder ein Dienst zum Verarbeiten Ihrer Blicke Raycast in der Szene, und verwenden Sie dann erneut dieses Ergebnis in allen anderen Szene Komponenten, anstatt Sie wiederholte und im Wesentlichen identisch Raycast-Vorgänge von jedem Komponente.</span><span class="sxs-lookup"><span data-stu-id="25484-162">a) Generally it is good practice to have a dedicated Singleton class or service to handle your gaze Raycast into the scene and then re-use this result in all other scene components, instead of making repeated and essentially identical Raycast operations by each component.</span></span> <span data-ttu-id="25484-163">Natürlich können einige Anwendungen erfordern Raycasts verschiedener Herkunft oder für verschiedene [LayerMasks](https://docs.unity3d.com/ScriptReference/LayerMask.html).</span><span class="sxs-lookup"><span data-stu-id="25484-163">Of course, some applications may require raycasts from different origins or against different [LayerMasks](https://docs.unity3d.com/ScriptReference/LayerMask.html).</span></span>

        UnityEngine.Physics.Raycast()
        UnityEngine.Physics.RaycastAll()

    <span data-ttu-id="25484-164">(b) vermeiden Sie GetComponent() Vorgänge im wiederholten Unity-Rückrufe wie Update() von [Zwischenspeichern Verweise](#cache-references) Start() oder Awake()</span><span class="sxs-lookup"><span data-stu-id="25484-164">b) Avoid GetComponent() operations in repeated Unity callbacks like Update() by [caching references](#cache-references) in Start() or Awake()</span></span>

        UnityEngine.Object.GetComponent()

    <span data-ttu-id="25484-165">(c) Es wird empfohlen, alle Objekte, wenn möglich, Initialisierung und Verwendung instanziiert [Objektpooling](#object-pooling) wiederverwenden, und verwenden "gameobjects" erneut in der gesamten Laufzeit der Anwendung</span><span class="sxs-lookup"><span data-stu-id="25484-165">c) It is good practice to instantiate all objects, if possible, at initialization and use [object pooling](#object-pooling) to recycle and re-use GameObjects throughout runtime of your application</span></span>

        UnityEngine.Object.Instantiate()

3) <span data-ttu-id="25484-166">**Schnittstellen und virtuelle Konstrukte zu vermeiden**</span><span class="sxs-lookup"><span data-stu-id="25484-166">**Avoid interfaces and virtual constructs**</span></span>

    <span data-ttu-id="25484-167">Aufrufen von Funktionsaufrufe über Schnittstellen Vs Verzeichnisobjekte oder das Aufrufen von virtuellen Funktionen können oft viel teurer als die Verwendung direkter Konstrukte oder direkte Funktionsaufrufe sein.</span><span class="sxs-lookup"><span data-stu-id="25484-167">Invoking function calls through interfaces vs direct objects or calling virtual functions can often times be much more expensive than utilizing direct constructs or direct function calls.</span></span> <span data-ttu-id="25484-168">Wenn die virtuelle Funktion oder die Schnittstelle nicht erforderlich ist, sollte er entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="25484-168">If the virtual function or interface is unnecessary, then it should be removed.</span></span> <span data-ttu-id="25484-169">Diese Ansätze für die Beeinträchtigung der serverleistung sind jedoch im Allgemeinen sollte einen Kompromiss Wenn nutzen diese Entwicklung Zusammenarbeit, Lesbarkeit des Codes und codeverwaltbarkeit von vereinfacht.</span><span class="sxs-lookup"><span data-stu-id="25484-169">However, the performance hit for these approaches are generally worth the trade-off if utilizing them simplifies development collaboration, code readability, and code maintainability.</span></span> 

4) <span data-ttu-id="25484-170">**Vermeiden Sie nach Wert übergeben von Strukturen**</span><span class="sxs-lookup"><span data-stu-id="25484-170">**Avoid passing structs by value**</span></span>

    <span data-ttu-id="25484-171">Im Gegensatz zu Klassen Strukturen sind Werttypen, und wenn direkt an eine Funktion übergeben, deren Inhalt in eine neu erstellte Instanz kopiert.</span><span class="sxs-lookup"><span data-stu-id="25484-171">Unlike classes, structs are value-types and when passed directly to a function, their contents are copied into a newly created instance.</span></span> <span data-ttu-id="25484-172">Diese Kopie wird die CPU-Kosten sowie zusätzlichen Arbeitsspeicher auf dem Stapel hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="25484-172">This copy adds CPU cost as well as additional memory on the stack.</span></span> <span data-ttu-id="25484-173">Bei kleinen Strukturen ist der Effekt in der Regel nur sehr geringe und somit akzeptabel.</span><span class="sxs-lookup"><span data-stu-id="25484-173">For small structs, the effect is usually very minimal and thus acceptable.</span></span> <span data-ttu-id="25484-174">Allerdings für Funktionen wiederholt jedes Bild aufgerufen, als auch für Funktionen mit großer Strukturen ggf. Ändern der Definition der Funktion zur Übergabe als Verweis.</span><span class="sxs-lookup"><span data-stu-id="25484-174">However, for functions repeatedly invoked every frame as well as functions taking large structs, if possible modify the function definition to pass by reference.</span></span> [<span data-ttu-id="25484-175">Hier erfahren Sie mehr</span><span class="sxs-lookup"><span data-stu-id="25484-175">Learn more here</span></span>](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/how-to-know-the-difference-passing-a-struct-and-passing-a-class-to-a-method)

#### <a name="miscellaneous"></a><span data-ttu-id="25484-176">Sonstiges</span><span class="sxs-lookup"><span data-stu-id="25484-176">Miscellaneous</span></span>

1) <span data-ttu-id="25484-177">**Physik**</span><span class="sxs-lookup"><span data-stu-id="25484-177">**Physics**</span></span>

    <span data-ttu-id="25484-178">(a) in der Regel ist einfachste Möglichkeit zur Verbesserung der Physik die Zeitspanne, die auf physikalische Eigenschaften oder die Anzahl der Iterationen, die pro Sekunde beschränken.</span><span class="sxs-lookup"><span data-stu-id="25484-178">a) Generally, easiest way to improve physics is to limit the amount of time spent on Physics or the number of iterations per second.</span></span> <span data-ttu-id="25484-179">Natürlich verringert das Simulation Genauigkeit.</span><span class="sxs-lookup"><span data-stu-id="25484-179">Of course, this will reduce simulation accuracy.</span></span> <span data-ttu-id="25484-180">Finden Sie unter [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) in Unity</span><span class="sxs-lookup"><span data-stu-id="25484-180">See [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) in Unity</span></span>

    <span data-ttu-id="25484-181">(b) der Typ der collider in Unity haben häufig unterschiedliche Leistungsmerkmale.</span><span class="sxs-lookup"><span data-stu-id="25484-181">b) The type of colliders in Unity have widely different performance characteristics.</span></span> <span data-ttu-id="25484-182">Die folgenden Reihenfolge aufgeführt, die meisten leistungsfähigen collider, mindestens leistungsfähigen collider von links nach rechts.</span><span class="sxs-lookup"><span data-stu-id="25484-182">The order below lists the most performant colliders to least performant colliders from left to right.</span></span> <span data-ttu-id="25484-183">Es ist am wichtigsten Collider Mesh zu vermeiden, die beträchtlich teurer als die primitiven collider sind.</span><span class="sxs-lookup"><span data-stu-id="25484-183">It is most important to avoid Mesh Colliders which are substantially more expensive than the primitive colliders.</span></span>

        Sphere < Capsule < Box <<< Mesh (Convex) < Mesh (non-Convex)

    <span data-ttu-id="25484-184">Finden Sie unter [bewährte Methoden für Unity Physik](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) für Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="25484-184">See [Unity Physics Best Practices](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) for more info</span></span>

2) <span data-ttu-id="25484-185">**Animationen**</span><span class="sxs-lookup"><span data-stu-id="25484-185">**Animations**</span></span>

    <span data-ttu-id="25484-186">Deaktivieren Sie im Leerlauf Animationen durch das Deaktivieren der Animator-Komponente (deaktivieren das spielobjekt muss nicht die gleiche Auswirkung).</span><span class="sxs-lookup"><span data-stu-id="25484-186">Disable idle animations by disabling the Animator component (disabling the game object won't have the same effect).</span></span> <span data-ttu-id="25484-187">Vermeiden Sie Entwurfsmuster, in denen ein Animator in einer Schleife, die eine Einstellung auf die gleiche Sache befindet.</span><span class="sxs-lookup"><span data-stu-id="25484-187">Avoid design patterns where an animator sits in a loop setting a value to the same thing.</span></span> <span data-ttu-id="25484-188">Es gibt viel Aufwand für dieses Verfahren hat keine Auswirkungen auf die Anwendung aus.</span><span class="sxs-lookup"><span data-stu-id="25484-188">There is considerable overhead for this technique, with no effect on the application.</span></span> [<span data-ttu-id="25484-189">Hier erfahren Sie mehr.</span><span class="sxs-lookup"><span data-stu-id="25484-189">Learn more here.</span></span>](https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html)

3) <span data-ttu-id="25484-190">**Komplexe Algorithmen**</span><span class="sxs-lookup"><span data-stu-id="25484-190">**Complex algorithms**</span></span>

    <span data-ttu-id="25484-191">Wenn Ihre Anwendung komplexe Algorithmen, z. B. inverse Kinematik, Pfad suchen usw. verwendet wird, suchen Sie, um einen einfacheren Ansatz suchen, oder passen die relevante Einstellungen für die Leistung</span><span class="sxs-lookup"><span data-stu-id="25484-191">If your application is using complex algorithms such as inverse kinematics, path finding, etc, look to find a simpler approach or adjust relevant settings for their performance</span></span>

## <a name="cpu-to-gpu-performance-recommendations"></a><span data-ttu-id="25484-192">Empfehlungen zur CPU, GPU Leistung</span><span class="sxs-lookup"><span data-stu-id="25484-192">CPU-to-GPU performance recommendations</span></span>

<span data-ttu-id="25484-193">Im Allgemeinen CPU-zu-GPU-Leistung wird nach unten, um die **zeichnen-Befehlen** an der Grafikkarte übermittelt.</span><span class="sxs-lookup"><span data-stu-id="25484-193">Generally, CPU-to-GPU performance comes down to the **draw calls** submitted to the graphics card.</span></span> <span data-ttu-id="25484-194">Zur Verbesserung der Leistung Draw-Aufrufe müssen strategisch **(a) reduziert** oder **(b) umstrukturiert** für optimale Ergebnisse zu erzielen.</span><span class="sxs-lookup"><span data-stu-id="25484-194">To improve performance, draw calls need to be strategically **a) reduced** or **b) restructured** for optimal results.</span></span> <span data-ttu-id="25484-195">Da zeichnen-Befehlen selbst ressourcenintensiv sind, werden insgesamt Arbeitsaufwand reduzieren verringert.</span><span class="sxs-lookup"><span data-stu-id="25484-195">Since draw calls themselves are resource-intensive, reducing them will reduce overall work required.</span></span> <span data-ttu-id="25484-196">Darüber hinaus Status Änderungen zwischen zeichnen-Befehlen ist erforderlich, teure Validierung und Übersetzung Schritte des Grafiktreibers und daher Umstrukturierung von Ihrer Anwendung zeichnen-Befehlen zum Einschränken von Änderungen des Ansichtszustands (d.h.)</span><span class="sxs-lookup"><span data-stu-id="25484-196">Further, state changes between draw calls requires costly validation and translation steps in the graphics driver and thus, restructuring of your application's draw calls to limit state changes(i.e</span></span> <span data-ttu-id="25484-197">andere Materialien, usw.) kann die Leistung gesteigert.</span><span class="sxs-lookup"><span data-stu-id="25484-197">different materials, etc) can boost performance.</span></span>

<span data-ttu-id="25484-198">Unity ist einen großartiger Artikel, der bietet einer Übersicht über die und Batchverarbeitung Draw-Aufrufe Ihrer eigenen Plattform behandelt.</span><span class="sxs-lookup"><span data-stu-id="25484-198">Unity has a great article that gives an overview and dives into batching draw calls for their platform.</span></span>
- [<span data-ttu-id="25484-199">Unity zeichnen Aufruf Batchverarbeitung</span><span class="sxs-lookup"><span data-stu-id="25484-199">Unity Draw Call Batching</span></span>](https://docs.unity3d.com/Manual/DrawCallBatching.html)

#### <a name="single-pass-instanced-rendering"></a><span data-ttu-id="25484-200">Durchlauf instanziierten rendering</span><span class="sxs-lookup"><span data-stu-id="25484-200">Single pass instanced rendering</span></span>

<span data-ttu-id="25484-201">Übergeben der einzelnen Instanced Rendering in Unity ermöglicht Draw-Aufrufe für jedes Auge auf einem instanziierten Draw-Aufruf reduziert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="25484-201">Single Pass Instanced Rendering in Unity allows for draw calls for each eye to be reduced down to one instanced draw call.</span></span> <span data-ttu-id="25484-202">Aufgrund der Cachekohärenz zwischen zwei zeichnen-Befehlen gibt es auch in der GPU sowie einige leistungsverbesserungen.</span><span class="sxs-lookup"><span data-stu-id="25484-202">Due to cache coherency between two draw calls, there is also some performance improvement on the GPU as well.</span></span>

<span data-ttu-id="25484-203">So aktivieren Sie dieses Feature in Ihrem Unity-Projekt</span><span class="sxs-lookup"><span data-stu-id="25484-203">To enable this feature in your Unity Project</span></span>
1)  <span data-ttu-id="25484-204">Open **XR Playereinstellungen** (Wechseln Sie zu **bearbeiten** > **Projekteinstellungen** > **Player**  >  **XR-Einstellungen**)</span><span class="sxs-lookup"><span data-stu-id="25484-204">Open **Player XR Settings** (go to **Edit** > **Project Settings** > **Player** > **XR Settings**)</span></span>
2) <span data-ttu-id="25484-205">Wählen Sie **einzelne Instanz übergeben** aus der **Stereo-Rendering-Methode** -Dropdownmenü (**virtuelle Realität unterstützt** Kontrollkästchen muss aktiviert sein)</span><span class="sxs-lookup"><span data-stu-id="25484-205">Select **Single Pass Instanced** from the **Stereo Rendering Method** drop-down menu (**Virtual Reality Supported** checkbox must be checked)</span></span>

<span data-ttu-id="25484-206">Lesen Sie die folgenden Artikeln aus Unity Informationen bei diesem Ansatz rendern.</span><span class="sxs-lookup"><span data-stu-id="25484-206">Read the following articles from Unity for details with this rendering approach.</span></span>
- [<span data-ttu-id="25484-207">Gewusst wie: Maximieren der Leistung von AR und VR mit erweiterten Stereo-rendering</span><span class="sxs-lookup"><span data-stu-id="25484-207">How to maximize AR and VR performance with advanced stereo rendering</span></span>](https://blogs.unity3d.com/2017/11/21/how-to-maximize-ar-and-vr-performance-with-advanced-stereo-rendering/)
- [<span data-ttu-id="25484-208">Übergeben Sie Single Instancing</span><span class="sxs-lookup"><span data-stu-id="25484-208">Single Pass Instancing</span></span>](https://docs.unity3d.com/Manual/SinglePassInstancing.html) 

>[!NOTE]
> <span data-ttu-id="25484-209">Ein verbreitetes Problem mit einzelnen Rendering Instanz übergeben tritt auf, wenn Entwickler bereits vorhandene benutzerdefinierte Shadern, die nicht für geschriebenen Instanziierung.</span><span class="sxs-lookup"><span data-stu-id="25484-209">One common issue with Single Pass Instanced Rendering occurs if developers already have existing custom shaders not written for instancing.</span></span> <span data-ttu-id="25484-210">Nach der Aktivierung dieser Option werden Entwicklern einige "gameobjects" nur das Rendering in ein Auge feststellen.</span><span class="sxs-lookup"><span data-stu-id="25484-210">After enabling this feature, developers may notice some GameObjects only render in one eye.</span></span> <span data-ttu-id="25484-211">Dies ist, da die zugeordneten benutzerdefinierten Shadern nicht die entsprechenden Eigenschaften für die Instanziierung.</span><span class="sxs-lookup"><span data-stu-id="25484-211">This is because the associated custom shaders do not have the appropriate properties for instancing.</span></span>
>
> <span data-ttu-id="25484-212">Finden Sie unter [einzelne übergeben Stereo Rendering für HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) von Unity für das dieses Problem zu beheben</span><span class="sxs-lookup"><span data-stu-id="25484-212">See [Single Pass Stereo Rendering for HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) from Unity for how to address this problem</span></span>

#### <a name="static-batching"></a><span data-ttu-id="25484-213">Statische Batchverarbeitung</span><span class="sxs-lookup"><span data-stu-id="25484-213">Static batching</span></span>

<span data-ttu-id="25484-214">Unity kann batch viele statische Objekte, um die Draw-Aufrufe an die GPU zu reduzieren.</span><span class="sxs-lookup"><span data-stu-id="25484-214">Unity is able to batch many static objects to reduce draw calls to the GPU.</span></span> <span data-ttu-id="25484-215">Statische Batchverarbeitung eignet sich für die meisten [Renderer](https://docs.unity3d.com/ScriptReference/Renderer.html) Objekte in Unity, **1) Geben Sie die gleiche Material** und **(2) sind alle markierten als *statische***  () Wählen Sie ein Objekt in Unity, und klicken Sie auf das Kontrollkästchen in der oberen rechten des Inspektors).</span><span class="sxs-lookup"><span data-stu-id="25484-215">Static Batching works for most [Renderer](https://docs.unity3d.com/ScriptReference/Renderer.html) objects in Unity that **1) share the same material** and **2) are all marked as *Static*** (Select an object in Unity and click the checkbox in the top right of the inspector).</span></span> <span data-ttu-id="25484-216">"Gameobjects" markiert, als *statische* kann nicht in Ihrer Anwendung Common Language Runtime verschoben werden.</span><span class="sxs-lookup"><span data-stu-id="25484-216">GameObjects marked as *Static* cannot be moved throughout your application's runtime.</span></span> <span data-ttu-id="25484-217">Daher kann statische Batchverarbeitung schwierig sein, auf HoloLens nutzen, in denen praktisch jedes Objekt platziert werden, verschoben, skalierte usw. muss. Für immersive Headsets statische Batchverarbeitung kann deutlich reduzieren, zeichnen-Befehlen und somit die Leistung verbessern.</span><span class="sxs-lookup"><span data-stu-id="25484-217">Thus, static batching can be difficult to leverage on HoloLens where virtually every object needs to be placed, moved, scaled, etc. For immersive headsets, static batching can dramatically reduce draw calls and thus improve performance.</span></span>

<span data-ttu-id="25484-218">Lesen *statische Batchverarbeitung* unter [zeichnen Batchverarbeitung aufrufen, in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) Weitere Details.</span><span class="sxs-lookup"><span data-stu-id="25484-218">Read *Static Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for more details.</span></span>

#### <a name="dynamic-batching"></a><span data-ttu-id="25484-219">Dynamische Batchverarbeitung</span><span class="sxs-lookup"><span data-stu-id="25484-219">Dynamic batching</span></span>

<span data-ttu-id="25484-220">Da dies problematisch ist, um Objekte markieren ist *statische* für die Entwicklung für HoloLens, dynamische Batchverarbeitung möglich ein großartiges Tool, um dies zu kompensieren fehlen, für die Funktion.</span><span class="sxs-lookup"><span data-stu-id="25484-220">Since it is problematic to mark objects as *Static* for HoloLens development, dynamic batching can be a great tool to compensate for this lacking feature.</span></span> <span data-ttu-id="25484-221">Es ist natürlich können auch auf auch immersive Headsets nützlich sein.</span><span class="sxs-lookup"><span data-stu-id="25484-221">Of course, it is can also be useful on immersive headsets as well.</span></span> <span data-ttu-id="25484-222">Dynamische Batchverarbeitung in Unity kann schwierig sein, jedoch zu aktivieren, da "gameobjects" muss **(a) Freigabe der gleichen Material** und **(b) eine lange Liste von anderen Kriterien zu erfüllen**.</span><span class="sxs-lookup"><span data-stu-id="25484-222">Dynamic batching in Unity can be difficult though to enable because GameObjects must **a) share the same Material** and **b) meet a long list of other criteria**.</span></span>

<span data-ttu-id="25484-223">Lesen *dynamische Batchverarbeitung* unter [zeichnen Batchverarbeitung aufrufen, in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) für die vollständige Liste.</span><span class="sxs-lookup"><span data-stu-id="25484-223">Read *Dynamic Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for the full list.</span></span> <span data-ttu-id="25484-224">"Gameobjects" werden in den meisten Fällen können nicht dynamisch zusammengefasst werden, da die zugeordnete Netzdaten nicht mehr als 300 Vertices werden können.</span><span class="sxs-lookup"><span data-stu-id="25484-224">Most commonly, GameObjects become invalid to be batched dynamically because the associated mesh data can be no more than 300 vertices.</span></span>

#### <a name="other-techniques"></a><span data-ttu-id="25484-225">andere Techniken</span><span class="sxs-lookup"><span data-stu-id="25484-225">Other techniques</span></span>

<span data-ttu-id="25484-226">Batchverarbeitung kann nur auftreten, wenn mehrere "gameobjects" auf das gleiche Material freigeben können.</span><span class="sxs-lookup"><span data-stu-id="25484-226">Batching can only occur if multiple GameObjects are able to share the same material.</span></span> <span data-ttu-id="25484-227">In der Regel wird dies durch die Notwendigkeit, "gameobjects", damit eine eindeutige Struktur für ihre jeweiligen Material blockiert werden.</span><span class="sxs-lookup"><span data-stu-id="25484-227">Typically this will be blocked by the need for GameObjects to have a unique texture for their respective Material.</span></span> <span data-ttu-id="25484-228">Es ist üblich, Texturen in einer großen Textur, eine Methode, die als bekannt kombinieren [Textur Atlasing](https://en.wikipedia.org/wiki/Texture_atlas).</span><span class="sxs-lookup"><span data-stu-id="25484-228">It is common to combine Textures into one big Texture, a method known as [Texture Atlasing](https://en.wikipedia.org/wiki/Texture_atlas).</span></span>

<span data-ttu-id="25484-229">Darüber hinaus ist es in der Regel besser, als die Gitter in einem "gameobject" zu kombinieren, soweit dies möglich und sinnvoll.</span><span class="sxs-lookup"><span data-stu-id="25484-229">Further, it is generally preferable to combine meshes into one GameObject where possible and reasonable.</span></span> <span data-ttu-id="25484-230">Jeder Renderer in Unity hat es verfügt über zugeordnete Draw API-Aufruf(e) im Vergleich zu einem kombinierten Mesh unter einem Renderer übermitteln.</span><span class="sxs-lookup"><span data-stu-id="25484-230">Each Renderer in Unity will have it's associated draw call(s) versus submitting a combined mesh under one Renderer.</span></span> 

>[!NOTE]
> <span data-ttu-id="25484-231">Ändern der Eigenschaften eines Renderer.material zur Laufzeit erstellt eine Kopie des Materials und somit zu schwerwiegenden Fehlern führen Batchverarbeitung.</span><span class="sxs-lookup"><span data-stu-id="25484-231">Modifying properties of Renderer.material at runtime will create a copy of the Material and thus potentially break batching.</span></span> <span data-ttu-id="25484-232">Verwenden Sie Renderer.sharedMaterial, um freigegebene Material-Eigenschaften für "gameobjects" zu ändern.</span><span class="sxs-lookup"><span data-stu-id="25484-232">Use Renderer.sharedMaterial to modify shared material properties across GameObjects.</span></span>

## <a name="gpu-performance-recommendations"></a><span data-ttu-id="25484-233">Empfehlungen zur GPU-Leistung</span><span class="sxs-lookup"><span data-stu-id="25484-233">GPU performance recommendations</span></span>

<span data-ttu-id="25484-234">Erfahren Sie mehr über [Grafiken Renderingoptimierung in Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span><span class="sxs-lookup"><span data-stu-id="25484-234">Learn more about [optimizing graphics rendering in Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span></span> 

### <a name="optimize-depth-buffer-sharing"></a><span data-ttu-id="25484-235">Optimieren Sie die Tiefe Puffer freigeben</span><span class="sxs-lookup"><span data-stu-id="25484-235">Optimize depth buffer sharing</span></span>

<span data-ttu-id="25484-236">Es wird allgemein empfohlen, aktivieren **Tiefe Puffer freigeben** unter **XR Playereinstellungen** Optimierung [– Hologramm Stabilität](Hologram-stability.md).</span><span class="sxs-lookup"><span data-stu-id="25484-236">It is generally recommended to enable **Depth buffer sharing** under **Player XR Settings** to optimize for [hologram stability](Hologram-stability.md).</span></span> <span data-ttu-id="25484-237">Wenn Tiefe basierende spät Phase Reprojection mit dieser Einstellung jedoch aktivieren, es wird empfohlen, wählen Sie **Tiefe von 16-Bit-Format** anstelle von **24-Bit-Tiefe Format**.</span><span class="sxs-lookup"><span data-stu-id="25484-237">When enabling depth-based late-stage reprojection with this setting however, it is recommended to select **16-bit depth format** instead of **24-bit depth format**.</span></span> <span data-ttu-id="25484-238">Die Tiefe von 16-Bit-Puffer wird drastisch reduziert die Bandbreite (und somit power) Tiefe Puffer Datenverkehr zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="25484-238">The 16-bit depth buffers will drastically reduces the bandwidth (and thus power) associated with depth buffer traffic.</span></span> <span data-ttu-id="25484-239">Dies kann ein großer Strom Gewinn, aber gilt nur für Umgebungen mit einem kleinen Tiefe Bereich als [Z-fighting](https://en.wikipedia.org/wiki/Z-fighting) werden eher mit 16-Bit-als 24-Bit-auftreten.</span><span class="sxs-lookup"><span data-stu-id="25484-239">This can be a big power win, but is only applicable for experiences with a small depth range as [z-fighting](https://en.wikipedia.org/wiki/Z-fighting) is more likely to occur with 16-bit than 24-bit.</span></span> <span data-ttu-id="25484-240">Um diese Artefakte zu vermeiden, ändern Sie die in der Nähe/hinteren Ebenen des der [Unity Kamera](https://docs.unity3d.com/Manual/class-Camera.html) der geringeren Genauigkeit berücksichtigen.</span><span class="sxs-lookup"><span data-stu-id="25484-240">To avoid these artifacts, modify the near/far clip planes of the [Unity camera](https://docs.unity3d.com/Manual/class-Camera.html) to account for the lower precision.</span></span> <span data-ttu-id="25484-241">Für HoloLens-basierte Anwendungen kann eine hinteren Clippingebene von 50 Millionen anstelle des standardmäßigen Unity 1000m in der Regel alle Z-fighting vermeiden.</span><span class="sxs-lookup"><span data-stu-id="25484-241">For HoloLens-based applications, a far clip plane of 50m instead of the Unity default 1000m can generally eliminate any z-fighting.</span></span>

### <a name="reduce-poly-count"></a><span data-ttu-id="25484-242">Reduzieren Sie Poly-Anzahl</span><span class="sxs-lookup"><span data-stu-id="25484-242">Reduce poly count</span></span>

<span data-ttu-id="25484-243">Polygonzahl wird in der Regel entweder reduziert.</span><span class="sxs-lookup"><span data-stu-id="25484-243">Polygon count is usually reduced by either</span></span>
1) <span data-ttu-id="25484-244">Entfernen von Objekten aus einer Szene</span><span class="sxs-lookup"><span data-stu-id="25484-244">Removing objects from a scene</span></span>
2) <span data-ttu-id="25484-245">Asset-Decimation dadurch die Anzahl von Polygonen, die für einen bestimmten Netz</span><span class="sxs-lookup"><span data-stu-id="25484-245">Asset decimation which reduces the number of polygons for a given mesh</span></span>
3) <span data-ttu-id="25484-246">Implementieren einer [Ebene von Details (LOD) System](https://docs.unity3d.com/Manual/LevelOfDetail.html) in Ihre Anwendung das weit entfernt Objekte mit niedrigerer-Polygon-Version der gleichen Geometrie gerendert wird</span><span class="sxs-lookup"><span data-stu-id="25484-246">Implementing a [Level of Detail (LOD) System](https://docs.unity3d.com/Manual/LevelOfDetail.html) into your application which renders far away objects with lower-polygon version of the same geometry</span></span>

### <a name="understanding-shaders-in-unity"></a><span data-ttu-id="25484-247">Grundlegendes zu Shader in Unity</span><span class="sxs-lookup"><span data-stu-id="25484-247">Understanding shaders in Unity</span></span>

<span data-ttu-id="25484-248">Eine einfache Annäherung, Shadern in Bezug auf Leistung verglichen werden soll. ist, identifizieren Sie die durchschnittliche Anzahl der einzelnen Vorgänge zur Laufzeit ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="25484-248">An easy approximation to compare shaders in performance is to identify the average number of operations each executes at runtime.</span></span> <span data-ttu-id="25484-249">Dies kann problemlos in Unity erfolgen.</span><span class="sxs-lookup"><span data-stu-id="25484-249">This can be done easily in Unity.</span></span>

1) <span data-ttu-id="25484-250">Wählen Sie Ihr Medienobjekt Shader Material, und anschließend oben rechts im Inspektorfenster, wählen Sie das Zahnradsymbol und dann **"Shader auswählen"**</span><span class="sxs-lookup"><span data-stu-id="25484-250">Select your shader asset or select a material, then in top right corner of the inspector window, select the gear icon and then **"Select Shader"**</span></span>

    ![Wählen Sie in Unity shader](images/Select-shader-unity.png)
2) <span data-ttu-id="25484-252">Der Shader-Ressource ausgewählt haben, und klicken Sie auf die **"Kompilieren und Code anzeigen"** Schaltfläche unter Inspektor-Fenster</span><span class="sxs-lookup"><span data-stu-id="25484-252">With the shader asset selected, click the **"Compile and show code"** button under the inspector window</span></span>

    ![Kompilieren von Shadercode in Unity](images/compile-shader-code-unity.PNG)

3) <span data-ttu-id="25484-254">Nach dem Kompilieren, suchen Sie nach dem Abschnitt in den Ergebnissen und die Anzahl der verschiedenen Vorgänge für den Scheitelpunkt und den Pixel-Shader (Hinweis: Pixel-Shader werden häufig auch als Fragment Shader bezeichnet)</span><span class="sxs-lookup"><span data-stu-id="25484-254">After compiling, look for the statistics section in the results with the number of different operations for both the vertex and pixel shader (Note: pixel shaders are often also called fragment shaders)</span></span>

    ![Unity-Standard-Shader-Vorgänge](images/unity-standard-shader-compilation.png)

#### <a name="optmize-pixel-shaders"></a><span data-ttu-id="25484-256">Optmize-Pixel-Shader</span><span class="sxs-lookup"><span data-stu-id="25484-256">Optmize pixel shaders</span></span>

<span data-ttu-id="25484-257">Betrachten die kompilierten Statistik Ergebnisse mithilfe der oben genannten Methode die [fragment Shader](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) führt im Allgemeinen mehr Vorgänge als die [Vertex-Shader](https://en.wikipedia.org/wiki/Shader#Vertex_shaders) durchschnittlich.</span><span class="sxs-lookup"><span data-stu-id="25484-257">Looking at the compiled statistic results using the method above, the [fragment shader](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) will generally execute more operations than the [vertex shader](https://en.wikipedia.org/wiki/Shader#Vertex_shaders) on average.</span></span> <span data-ttu-id="25484-258">Pro Pixel auf dem Bildschirm ausgegeben werden, während der Vertex-Shader nur ausgeführte pro-Vertex von allen Netzen, die gerade auf dem Bildschirm gezeichnet wird, wird die fragmentshader, auch bekannt als der Pixel-Shader, ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="25484-258">The fragment shader, also known as the pixel shader, is executed per pixel on the screen output while the vertex shader is only executed per-vertex of all meshes being drawn to the screen.</span></span> 

<span data-ttu-id="25484-259">Daher nicht nur die Fragment-Shader verfügen mehrere Anweisungen als Vertex-Shader da alle beleuchtungsberechnungen, die Fragment-Shader auf ein größeres Dataset fast immer ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="25484-259">Thus, not only do fragment shaders have more instructions than vertex shaders because of all the lighting calculations, fragment shaders are almost always executed on a larger dataset.</span></span> <span data-ttu-id="25484-260">Z. B. wenn auf dem Bildschirm eine 2 k 2 k-Image ist, klicken Sie dann die fragmentshader erhalten ausgeführt, 2, 000 \* 2, 000 = 4,000,000 Zeiten.</span><span class="sxs-lookup"><span data-stu-id="25484-260">For example, if the screen output is a 2k by 2k image, then the fragment shader can get executed 2,000\*2,000 = 4,000,000 times.</span></span> <span data-ttu-id="25484-261">Wenn zwei Augen zu rendern, wird diese Zahl verdoppelt, da es sich um zwei Bildschirme.</span><span class="sxs-lookup"><span data-stu-id="25484-261">If rendering two eyes, this number doubles since there are two screens.</span></span> <span data-ttu-id="25484-262">Verfügt eine mixed Reality-Anwendung, mehrere übergibt, Vollbild-Nachbearbeitung Effekte oder mehrere Gitter hinzuzufügen, um dasselbe Pixel zu rendern, wird diese Anzahl deutlich steigern.</span><span class="sxs-lookup"><span data-stu-id="25484-262">If a mixed reality application has multiple passes, full-screen post-processing effects, or rendering multiple meshes to the same pixel, this number will increase dramatically.</span></span> 

<span data-ttu-id="25484-263">Aus diesem Grund erhalten reduziert die Anzahl der Vorgänge im fragmentshader in der Regel sehr viel größere Leistungssteigerungen über Optimierungen in den Vertex-Shader.</span><span class="sxs-lookup"><span data-stu-id="25484-263">Therefore, reducing the number of operations in the fragment shader can generally give far greater performance gains over optimizations in the vertex shader.</span></span>

#### <a name="unity-standard-shader-alternatives"></a><span data-ttu-id="25484-264">Unity-Standard-Shader-alternativen</span><span class="sxs-lookup"><span data-stu-id="25484-264">Unity Standard shader alternatives</span></span>

<span data-ttu-id="25484-265">Anstatt ein physisch basierend Rendering (PBR) oder andere Shader qualitativ hochwertige, sehen Sie sich ein leistungsfähiger nutzen und kostengünstiger Shader.</span><span class="sxs-lookup"><span data-stu-id="25484-265">Instead of using a physically based rendering (PBR) or other high-quality shader, look at utilizing a more performant and cheaper shader.</span></span> <span data-ttu-id="25484-266">Die [Mixed Reality-Toolkit](https://github.com/Microsoft/MixedRealityToolkit-Unity) bietet die [MRTK standard-Shader](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) , die für mixed Reality-Projekten optimiert wurde.</span><span class="sxs-lookup"><span data-stu-id="25484-266">The [Mixed Reality Toolkit](https://github.com/Microsoft/MixedRealityToolkit-Unity) provides the [MRTK standard shader](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) that has been optimized for mixed reality projects.</span></span>

<span data-ttu-id="25484-267">Unity bietet auch eine Unbeleuchtete, Vertex leuchtet, diffusen und andere vereinfachten Shader-Optionen, die erheblich schneller verglichen werden, an dem Unity-Standard-Shader.</span><span class="sxs-lookup"><span data-stu-id="25484-267">Unity also provides an unlit, vertex lit, diffuse, and other simplified shader options that are significantly faster compared to the Unity Standard shader.</span></span> <span data-ttu-id="25484-268">Finden Sie unter [Nutzung und Leistung des integrierten Shader](https://docs.unity3d.com/Manual/shader-Performance.html) detailliertere Informationen.</span><span class="sxs-lookup"><span data-stu-id="25484-268">See [Usage and Performance of Built-in Shaders](https://docs.unity3d.com/Manual/shader-Performance.html) for more detailed information.</span></span>

#### <a name="shader-preloading"></a><span data-ttu-id="25484-269">Vorabladen von Shader</span><span class="sxs-lookup"><span data-stu-id="25484-269">Shader preloading</span></span>

<span data-ttu-id="25484-270">Verwendung *Shader Vorabladen* und andere Tricks zur Optimierung [Shader Ladezeit](http://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html).</span><span class="sxs-lookup"><span data-stu-id="25484-270">Use *Shader preloading* and other tricks to optimize [shader load time](http://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html).</span></span> <span data-ttu-id="25484-271">Das bedeutet insbesondere, Shader Vorabladen, dass Sie nicht sehen, dass Probleme aufgrund von Shader-Runtime-Kompilierung.</span><span class="sxs-lookup"><span data-stu-id="25484-271">In particular, shader preloading means you won't see any hitches due to runtime shader compilation.</span></span>

### <a name="limit-overdraw"></a><span data-ttu-id="25484-272">Limit-Elements zu überzeichnen</span><span class="sxs-lookup"><span data-stu-id="25484-272">Limit overdraw</span></span>

<span data-ttu-id="25484-273">In Unity, kann eine anzeigen-Elements zu überzeichnen für ihre Szene durch Umschalten der [ **zeichnen Modus im Menü** ](https://docs.unity3d.com/Manual/ViewModes.html) in der oberen linken Ecke des der **Szenenansicht** , und wählen **Alphablendings** .</span><span class="sxs-lookup"><span data-stu-id="25484-273">In Unity, one can display overdraw for their scene, by toggling the [**draw mode menu**](https://docs.unity3d.com/Manual/ViewModes.html) in the top left corner of the **Scene view** and selecting **Overdraw**.</span></span>

<span data-ttu-id="25484-274">Im Allgemeinen-Elements zu überzeichnen umgehen, indem die Auslese Objekte voraus, bevor sie an die GPU gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="25484-274">Generally, overdraw can be mitigated by culling objects ahead of time before they are sent to the GPU.</span></span> <span data-ttu-id="25484-275">Unity bietet Details zur Implementierung von [verschiedenen Culling](https://docs.unity3d.com/Manual/OcclusionCulling.html) für ihre-Engine.</span><span class="sxs-lookup"><span data-stu-id="25484-275">Unity provides details on implementing [Occlusion Culling](https://docs.unity3d.com/Manual/OcclusionCulling.html) for their engine.</span></span>

## <a name="memory-recommendations"></a><span data-ttu-id="25484-276">Speicherempfehlungen</span><span class="sxs-lookup"><span data-stu-id="25484-276">Memory recommendations</span></span>

<span data-ttu-id="25484-277">Eine übermäßige Speicheroperationen Zuordnung und Aufhebung der Zuordnung haben nachteilige Auswirkungen auf Ihre holographic Anwendung, was zu inkonsistenten Leistung, fixierte Frames und anderes Verhalten gleichzeitiger Aufrufe nachteilig auswirken.</span><span class="sxs-lookup"><span data-stu-id="25484-277">Excessive memory allocation & deallocation operations can have adverse effects on your holographic application resulting in inconsistent performance, frozen frames, and other detrimental behavior.</span></span> <span data-ttu-id="25484-278">Es ist besonders wichtig, Überlegungen zum Arbeitsspeicher zu, bei der Entwicklung in Unity, da die Verwaltung des Arbeitsspeichers durch den Garbage Collector gesteuert wird.</span><span class="sxs-lookup"><span data-stu-id="25484-278">It is especially important to understand memory considerations when developing in Unity since memory management is controlled by the garbage collector.</span></span>

#### <a name="garbage-collection"></a><span data-ttu-id="25484-279">Die automatische speicherbereinigung</span><span class="sxs-lookup"><span data-stu-id="25484-279">Garbage collection</span></span>

<span data-ttu-id="25484-280">Holographic apps werden Compute-Verarbeitungszeit der Garbage Collector (GC) verlieren, wenn der Garbage Collector aktiviert wird, um Objekte analysieren, die während der Ausführung nicht mehr im Gültigkeitsbereich befinden und deren Speicher muss freigegeben werden, damit es für die erneute Verwendung zur Verfügung gestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="25484-280">Holographic apps will loose processing compute time to the garbage collector (GC) when the GC is activated to analyze objects that are no longer in scope during execution and their memory needs to be released so it can be made available for re-use.</span></span> <span data-ttu-id="25484-281">Zuordnungen von Konstanten und Aufhebung von Zuordnungen benötigen daher beeinträchtigt die Leistung und benutzerfreundlichkeit eine häufigere Ausführung der Garbage Collector in der Regel.</span><span class="sxs-lookup"><span data-stu-id="25484-281">Constant allocations and de-allocations will generally require the garbage collector to run more frequently thus hurting performance and user experience.</span></span>

<span data-ttu-id="25484-282">Unity stellt eine ausgezeichnete Seite, die im Detail erläutert die Funktionsweise von der Garbage Collector und Tipps, effizienter Code im Hinblick auf die Verwaltung des Arbeitsspeichers zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="25484-282">Unity has provided an excellent page that explains in detail how the garbage collector works and tips to write more efficient code in regards to memory management.</span></span>
- [<span data-ttu-id="25484-283">Optimieren der Garbagecollection im Unity-Spiele</span><span class="sxs-lookup"><span data-stu-id="25484-283">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)

<span data-ttu-id="25484-284">Eines der am häufigsten verwendeten Praktiken, die auf eine übermäßige Garbagecollection führt das Verweise auf Komponenten und Klassen in der Unity-Entwicklung ist nicht zwischenspeichern.</span><span class="sxs-lookup"><span data-stu-id="25484-284">One of the most common practices that leads to excessive garbage collection is not caching references to components and classes in Unity development.</span></span> <span data-ttu-id="25484-285">Alle Verweise während Start() oder Awake() aufgezeichnet, und in späteren Funktionen z. B. Update() oder LateUpdate() erneut verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="25484-285">Any references should be captured during Start() or Awake() and re-used in later functions such as Update() or LateUpdate().</span></span>

<span data-ttu-id="25484-286">Weitere Tipps:</span><span class="sxs-lookup"><span data-stu-id="25484-286">Other quick tips:</span></span>
- <span data-ttu-id="25484-287">Verwenden der ["StringBuilder"](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2) C# Klasse, um komplexe Zeichenfolgen zur Laufzeit dynamisch erstellen</span><span class="sxs-lookup"><span data-stu-id="25484-287">Use the [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2) C# class to dynamically build complex strings at runtime</span></span>
- <span data-ttu-id="25484-288">Entfernen Sie Aufrufe von Debug.Log() wird nicht mehr benötigt wird, während der Ausführung immer noch in der alle Build-Versionen einer App</span><span class="sxs-lookup"><span data-stu-id="25484-288">Remove calls to Debug.Log() when no longer needed as they still execute in all build versions of an app</span></span>
- <span data-ttu-id="25484-289">Wenn Ihre holographic app in der Regel viel Arbeitsspeicher benötigt, sollten Sie aufrufen [ _**System.GC.Collect()**_ ](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2) während der Ladephase wie z. B. bei einem laden oder Transition-Bildschirm</span><span class="sxs-lookup"><span data-stu-id="25484-289">If your holographic app generally requires lots of memory, consider calling  [_**System.GC.Collect()**_](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2) during loading phases such as when presenting a loading or transition screen</span></span>

#### <a name="object-pooling"></a><span data-ttu-id="25484-290">Objektpooling</span><span class="sxs-lookup"><span data-stu-id="25484-290">Object pooling</span></span>

<span data-ttu-id="25484-291">Objektpooling ist ein beliebtes Verfahren, um die Kosten continuous speicherbelegungen und Aufhebungen von Objekten zu reduzieren.</span><span class="sxs-lookup"><span data-stu-id="25484-291">Object pooling is a popular technique to reduce the cost of continuous allocations & deallocations of objects.</span></span> <span data-ttu-id="25484-292">Dies erfolgt, indem Sie eine große Gruppe von identischen Objekte zuordnen und neu inaktive, verfügbare Instanzen aus diesem Pool anstatt ständig erstellen und Zerstören von Objekten im Laufe der Zeit.</span><span class="sxs-lookup"><span data-stu-id="25484-292">This is done by allocating a large pool of identical objects and re-using inactive, available instances from this pool instead of constantly spawning and destroying objects over time.</span></span> <span data-ttu-id="25484-293">Objektpools eignen sich hervorragend für aktionsentwicklung Komponenten, die die Lebensdauer der Variablen während einer app haben.</span><span class="sxs-lookup"><span data-stu-id="25484-293">Object pools are great for re-useable components that have variable lifetime during an app.</span></span>

- [<span data-ttu-id="25484-294">Objektpooling-Lernprogramm in Unity</span><span class="sxs-lookup"><span data-stu-id="25484-294">Object Pooling Tutorial in Unity</span></span>](https://unity3d.com/learn/tutorials/topics/scripting/object-pooling) 

## <a name="startup-performance"></a><span data-ttu-id="25484-295">Startleistung</span><span class="sxs-lookup"><span data-stu-id="25484-295">Startup performance</span></span>

<span data-ttu-id="25484-296">Berücksichtigen Sie Starten Ihrer app mit einer kleineren Szene, und klicken Sie dann mithilfe von *[SceneManager.LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* um den Rest der Szene zu laden.</span><span class="sxs-lookup"><span data-stu-id="25484-296">You should consider starting your app with a smaller scene, then using *[SceneManager.LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* to load the rest of the scene.</span></span> <span data-ttu-id="25484-297">Dies ermöglicht Ihrer app, um einen interaktiven Zustands so schnell wie möglich zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="25484-297">This allows your app to get to an interactive state as fast as possible.</span></span> <span data-ttu-id="25484-298">Beachten Sie, die es einer großen CPU-Spitze möglicherweise während die neue Szene aktiviert wird und alle gerenderten Inhalt ruckartig wiedergegeben werden kann oder Haken sein.</span><span class="sxs-lookup"><span data-stu-id="25484-298">Be aware that there may be a large CPU spike while the new scene is being activated and that any rendered content might stutter or hitch.</span></span> <span data-ttu-id="25484-299">Eine Möglichkeit zur Umgehung dieses Problems ist die AsyncOperation.allowSceneActivation-Eigenschaft auf "false" festlegen, in dem Bereich, der geladen wird, warten Sie, bis die Szene laden, deaktivieren Sie den Bildschirm auf Schwarz festgelegt, und legen Sie dann auf "true", zum Abschließen der Aktivierung der Szene zurück.</span><span class="sxs-lookup"><span data-stu-id="25484-299">One way to work around this is to set the AsyncOperation.allowSceneActivation property to false on the scene being loaded, wait for the scene to load, clear the screen to black, and then set back to true to complete the scene activation.</span></span>

<span data-ttu-id="25484-300">Denken Sie daran, dass beim Laden der startszene beim der holographic Splash-Bildschirm für den Benutzer angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="25484-300">Remember that while the startup scene is loading the holographic splash screen will be displayed to the user.</span></span>

## <a name="see-also"></a><span data-ttu-id="25484-301">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="25484-301">See also</span></span>
- [<span data-ttu-id="25484-302">Optimieren der Grafik-Rendering in Unity-Spiele</span><span class="sxs-lookup"><span data-stu-id="25484-302">Optimizing graphics rendering in Unity games</span></span>](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games?playlist=44069)
- [<span data-ttu-id="25484-303">Optimieren der Garbagecollection im Unity-Spiele</span><span class="sxs-lookup"><span data-stu-id="25484-303">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)
- <span data-ttu-id="25484-304">[Physik bewährte Methoden [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span><span class="sxs-lookup"><span data-stu-id="25484-304">[Physics Best Practices [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span></span>
- <span data-ttu-id="25484-305">[Optimieren von Skripts [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span><span class="sxs-lookup"><span data-stu-id="25484-305">[Optimizing Scripts [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span></span>
