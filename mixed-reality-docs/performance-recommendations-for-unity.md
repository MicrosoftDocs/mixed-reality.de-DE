---
title: Empfehlungen zur Leistung für Unity
description: Unity-spezifische Tipps zum Verbessern der Leistung mit Mixed Reality-apps.
author: Troy-Ferrell
ms.author: trferrel
ms.date: 03/26/2019
ms.topic: article
keywords: Grafiken, CPU, GPU, Rendering, Garbage Collection, hololens
ms.openlocfilehash: 724ec24408e70360fda07c59a4ca2ffc30b49c1f
ms.sourcegitcommit: 6bc6757b9b273a63f260f1716c944603dfa51151
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 11/01/2019
ms.locfileid: "73438128"
---
# <a name="performance-recommendations-for-unity"></a><span data-ttu-id="90b02-104">Empfehlungen zur Leistung für Unity</span><span class="sxs-lookup"><span data-stu-id="90b02-104">Performance recommendations for Unity</span></span>

<span data-ttu-id="90b02-105">Dieser Artikel baut auf der Erörterung der [Leistungs Empfehlungen für gemischtes Reality](understanding-performance-for-mixed-reality.md) auf, konzentriert sich jedoch auf die für die Unity-Engine-Umgebung spezifischen Erkenntnisse.</span><span class="sxs-lookup"><span data-stu-id="90b02-105">This article builds on the discussion outlined in [performance recommendations for mixed reality](understanding-performance-for-mixed-reality.md) but focuses on learnings specific to the Unity engine environment.</span></span>

<span data-ttu-id="90b02-106">Es ist außerdem sehr empfehlenswert, dass Entwickler die [empfohlenen Umgebungseinstellungen für den Unity-Artikel](Recommended-settings-for-unity.md)überprüfen.</span><span class="sxs-lookup"><span data-stu-id="90b02-106">It is also highly advisable that developers review the [recommended environment settings for Unity article](Recommended-settings-for-unity.md).</span></span> <span data-ttu-id="90b02-107">In diesem Artikel werden einige der wichtigsten Szenen Konfigurationen in Bezug auf das Entwickeln leistungsfähiger gemischter Reality-apps behandelt.</span><span class="sxs-lookup"><span data-stu-id="90b02-107">This article has content with some of the most important scene configurations in regards to building performant Mixed Reality apps.</span></span> <span data-ttu-id="90b02-108">Einige dieser empfohlenen Einstellungen sind auch unten hervorgehoben.</span><span class="sxs-lookup"><span data-stu-id="90b02-108">Some of these recommended settings are highlighted below as well.</span></span>

## <a name="how-to-profile-with-unity"></a><span data-ttu-id="90b02-109">So erstellen Sie ein Profil mit Unity</span><span class="sxs-lookup"><span data-stu-id="90b02-109">How to profile with Unity</span></span>

<span data-ttu-id="90b02-110">Unity bietet den integrierten **[Unity-Profiler](https://docs.unity3d.com/Manual/Profiler.html)** , der eine gute Ressource ist, um wertvolle Einblicke in die Leistung Ihrer APP zu erfassen.</span><span class="sxs-lookup"><span data-stu-id="90b02-110">Unity provides the **[Unity Profiler](https://docs.unity3d.com/Manual/Profiler.html)** built-in which is a great resource to gather valuable performance insights for your particular app.</span></span> <span data-ttu-id="90b02-111">Obwohl der Profiler im-Editor ausgeführt werden kann, stellen diese Metriken nicht die echte Laufzeitumgebung dar. Daher sollten die Ergebnisse aus diesem nicht vorsichtig verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="90b02-111">Although one can run the profiler in-editor, these metrics do not represent the true runtime environment and thus, results from this should be used cautiously.</span></span> <span data-ttu-id="90b02-112">Es wird empfohlen, eine Remote Profilerstellung für Ihre Anwendung während der Ausführung auf dem Gerät durchführen, um präzisere und verwertbare Erkenntnisse</span><span class="sxs-lookup"><span data-stu-id="90b02-112">It is recommended to remotely profile your application while running on device for most accurate and actionable insights.</span></span> <span data-ttu-id="90b02-113">Außerdem ist der [Frame Debugger](https://docs.unity3d.com/Manual/FrameDebugger.html) von Unity ein sehr leistungsfähiges Tool für die Verwendung.</span><span class="sxs-lookup"><span data-stu-id="90b02-113">Further, Unity's [Frame Debugger](https://docs.unity3d.com/Manual/FrameDebugger.html)  is also a very powerful and insight tool to utilize.</span></span>

<span data-ttu-id="90b02-114">Unity bietet eine gute Dokumentation für:</span><span class="sxs-lookup"><span data-stu-id="90b02-114">Unity provides great documentation for:</span></span>
1) <span data-ttu-id="90b02-115">Herstellen einer Remote Verbindung zwischen dem [Unity-Profiler und UWP-Anwendungen](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span><span class="sxs-lookup"><span data-stu-id="90b02-115">How to connect the [Unity profiler to UWP applications remotely](https://docs.unity3d.com/Manual/windowsstore-profiler.html)</span></span>
2) <span data-ttu-id="90b02-116">Effektive [Diagnose von Leistungsproblemen mit dem Unity-Profiler](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span><span class="sxs-lookup"><span data-stu-id="90b02-116">How to effectively [diagnose performance problems with the Unity Profiler](https://unity3d.com/learn/tutorials/temas/performance-optimization/diagnosing-performance-problems-using-profiler-window)</span></span>

>[!NOTE]
> <span data-ttu-id="90b02-117">Beim Herstellen einer Verbindung mit dem Unity-Profiler und nach dem Hinzufügen des GPU-Profilers (siehe *Hinzufügen von Profiler* in der oberen rechten Ecke) können Sie sehen, wie viel Zeit für die CPU-& GPU in der Mitte des Profilers aufgewendet wird.</span><span class="sxs-lookup"><span data-stu-id="90b02-117">With the Unity Profiler connected and after adding the GPU profiler (see *Add Profiler* in top right corner), one can see how much time is being spent on the CPU & GPU respectively in the middle of the profiler.</span></span> <span data-ttu-id="90b02-118">Dies ermöglicht es dem Entwickler, eine kurze Näherung zu erhalten, wenn die Anwendung CPU-oder GPU-gebunden ist.</span><span class="sxs-lookup"><span data-stu-id="90b02-118">This allows the developer to get a quick approximation if their application is CPU or GPU bounded.</span></span>
>
> ![Unity-CPU im Vergleich zu GPU](images/unity-profiler-cpu-gpu.png)

## <a name="cpu-performance-recommendations"></a><span data-ttu-id="90b02-120">Empfehlungen zur CPU-Leistung</span><span class="sxs-lookup"><span data-stu-id="90b02-120">CPU performance recommendations</span></span>

<span data-ttu-id="90b02-121">Der folgende Inhalt umfasst ausführlichere Leistungs Praktiken, insbesondere für die Entwicklung von Unity- C# &.</span><span class="sxs-lookup"><span data-stu-id="90b02-121">The content below covers more in-depth performance practices, especially targeted for Unity & C# development.</span></span>

#### <a name="cache-references"></a><span data-ttu-id="90b02-122">Cache Verweise</span><span class="sxs-lookup"><span data-stu-id="90b02-122">Cache references</span></span>

<span data-ttu-id="90b02-123">Es wird empfohlen, Verweise auf alle relevanten Komponenten und gameobjects bei der Initialisierung zwischenzuspeichern.</span><span class="sxs-lookup"><span data-stu-id="90b02-123">It is best practice to cache references to all relevant components and GameObjects at initialization.</span></span> <span data-ttu-id="90b02-124">Dies liegt daran, dass sich wiederholende Funktionsaufrufe, wie z. b. *[getComponent\<t > ()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* , relativ zu den Arbeitsspeicher Kosten zum Speichern eines Zeigers deutlich teurer sind.</span><span class="sxs-lookup"><span data-stu-id="90b02-124">This is because repeating function calls such as *[GetComponent\<T>()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* are significantly more expensive relative to the memory cost to store a pointer.</span></span> <span data-ttu-id="90b02-125">Dies gilt auch für die sehr regelmäßig verwendete [Kamera. Main](https://docs.unity3d.com/ScriptReference/Camera-main.html).</span><span class="sxs-lookup"><span data-stu-id="90b02-125">This also applies to to the very, regularly used [Camera.main](https://docs.unity3d.com/ScriptReference/Camera-main.html).</span></span> <span data-ttu-id="90b02-126">" *Camera. Main* " verwendet tatsächlich " *[findgameobjectwithtag ()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* ", unter dem Ihre Szenen Diagramme mit dem Tag *"maincamera"* nach einem Kamera Objekt durchsucht werden.</span><span class="sxs-lookup"><span data-stu-id="90b02-126">*Camera.main* actually just uses *[FindGameObjectsWithTag()](https://docs.unity3d.com/ScriptReference/GameObject.FindGameObjectsWithTag.html)* underneath which expensively searches your scene graph for a camera object with the *"MainCamera"* tag.</span></span>

```CS
using UnityEngine;
using System.Collections;

public class ExampleClass : MonoBehaviour
{
    private Camera cam;
    private CustomComponent comp;

    void Start() 
    {
        cam = Camera.main;
        comp = GetComponent<CustomComponent>();
    }

    void Update()
    {
        // Good
        this.transform.position = cam.transform.position + cam.transform.forward * 10.0f;

        // Bad
        this.transform.position = Camera.main.transform.position + Camera.main.transform.forward * 10.0f;

        // Good
        comp.DoSomethingAwesome();

        // Bad
        GetComponent<CustomComponent>().DoSomethingAwesome();
    }
}
```

>[!NOTE] 
> <span data-ttu-id="90b02-127">"GetComponent" (Zeichenfolge) vermeiden</span><span class="sxs-lookup"><span data-stu-id="90b02-127">Avoid GetComponent(string)</span></span> <br/>
> <span data-ttu-id="90b02-128">Bei der Verwendung von *[getComponent ()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)* gibt es eine Handvoll unterschiedlicher über Ladungen.</span><span class="sxs-lookup"><span data-stu-id="90b02-128">When using *[GetComponent()](https://docs.unity3d.com/ScriptReference/GameObject.GetComponent.html)*, there are a handful of different overloads.</span></span> <span data-ttu-id="90b02-129">Es ist wichtig, immer die typbasierten Implementierungen und nie die Zeichen folgen basierte Such Überladung zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="90b02-129">It is important to always use the Type based implementations and never the string-based searching overload.</span></span> <span data-ttu-id="90b02-130">Das Suchen nach Zeichen folgen in Ihrer Szene ist deutlich teurer als die Suche nach Typ.</span><span class="sxs-lookup"><span data-stu-id="90b02-130">Searching by string in your scene is significantly more costly than searching by Type.</span></span> <br/>
> <span data-ttu-id="90b02-131">Glück Komponente getComponent (Type-Typ)</span><span class="sxs-lookup"><span data-stu-id="90b02-131">(Good) Component GetComponent(Type type)</span></span> <br/>
> <span data-ttu-id="90b02-132">Glück T getComponent\<t > ()</span><span class="sxs-lookup"><span data-stu-id="90b02-132">(Good) T GetComponent\<T>()</span></span> <br/>
> <span data-ttu-id="90b02-133">Schlechtem Komponente getComponent (String) ></span><span class="sxs-lookup"><span data-stu-id="90b02-133">(Bad) Component GetComponent(string)></span></span> <br/>

#### <a name="avoid-expensive-operations"></a><span data-ttu-id="90b02-134">Vermeiden kostspieliger Vorgänge</span><span class="sxs-lookup"><span data-stu-id="90b02-134">Avoid expensive operations</span></span>

1) <span data-ttu-id="90b02-135">**Vermeiden der Verwendung von [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span><span class="sxs-lookup"><span data-stu-id="90b02-135">**Avoid use of [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/getting-started-with-linq)**</span></span>

    <span data-ttu-id="90b02-136">Obwohl LINQ sehr sauber und leicht zu lesen und zu schreiben sein kann, erfordert es im allgemeinen weitaus mehr Berechnungen und besonders mehr Speicher Belegung, als den Algorithmus manuell zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="90b02-136">Although LINQ can be very clean and easy to read and write, it generally requires much more computation and particularly more memory allocation than writing the algorithm out manually.</span></span>

    ```CS
    // Example Code
    using System.Linq;

    List<int> data = new List<int>();
    data.Any(x => x > 10);

    var result = from x in data
                 where x > 10
                 select x;
    ```

2) <span data-ttu-id="90b02-137">**Allgemeine Unity-APIs**</span><span class="sxs-lookup"><span data-stu-id="90b02-137">**Common Unity APIs**</span></span>

    <span data-ttu-id="90b02-138">Bestimmte Unity-APIs, auch wenn Sie nützlich sind, können für die Ausführung sehr kostspielig sein.</span><span class="sxs-lookup"><span data-stu-id="90b02-138">Certain Unity APIs, although useful, can be very expensive to execute.</span></span> <span data-ttu-id="90b02-139">In den meisten Fällen ist das Durchsuchen des gesamten Szenen Diagramms nach einer passenden Liste von gameobjects verbunden.</span><span class="sxs-lookup"><span data-stu-id="90b02-139">Most of these involve searching your entire scene graph for some matching list of GameObjects.</span></span> <span data-ttu-id="90b02-140">Diese Vorgänge können im Allgemeinen durch das Zwischenspeichern von verweisen oder das Implementieren einer Manager-Komponente für die betreffenden gameobjects vermieden werden, um die Verweise zur Laufzeit zu verfolgen.</span><span class="sxs-lookup"><span data-stu-id="90b02-140">These operations can generally be avoided by caching references or implementing a manager component for the GameObjects in question to track the references at runtime.</span></span>

        GameObject.SendMessage()
        GameObject.BroadcastMessage()
        UnityEngine.Object.Find()
        UnityEngine.Object.FindWithTag()
        UnityEngine.Object.FindObjectOfType()
        UnityEngine.Object.FindObjectsOfType()
        UnityEngine.Object.FindGameObjectsWithTag()
        UnityEngine.Object.FindGameObjectsWithTag()

>[!NOTE]
> <span data-ttu-id="90b02-141">*[SendMessage ()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)* und *[broadcastmessage ()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* sollten zu allen Kosten entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="90b02-141">*[SendMessage()](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)* and *[BroadcastMessage()](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)* should be eliminated at all costs.</span></span> <span data-ttu-id="90b02-142">Diese Funktionen können in der Reihenfolge von 1000 x langsamer als bei direkten Funktionsaufrufen vorliegen.</span><span class="sxs-lookup"><span data-stu-id="90b02-142">These functions can be on the order of 1000x slower than direct function calls.</span></span>

3) <span data-ttu-id="90b02-143">**Vor Boxing**</span><span class="sxs-lookup"><span data-stu-id="90b02-143">**Beware of boxing**</span></span>

    <span data-ttu-id="90b02-144">[Boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) ist ein Grundkonzept der C# Sprache und Laufzeit.</span><span class="sxs-lookup"><span data-stu-id="90b02-144">[Boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing) is a core concept of the C# language and runtime.</span></span> <span data-ttu-id="90b02-145">Dabei handelt es sich um den Prozess, bei dem Werte typisierte Variablen wie char, int, bool usw. in Verweis typisierte Variablen umwickelt werden.</span><span class="sxs-lookup"><span data-stu-id="90b02-145">It is the process of wrapping value-typed variables such as char, int, bool, etc. into reference-typed variables.</span></span> <span data-ttu-id="90b02-146">Wenn eine Wert typisierte Variable "geschachtelt" ist, wird Sie in ein System. Object umgeschrieben, das auf dem verwalteten Heap gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="90b02-146">When a value-typed variable is "boxed", it is wrapped inside of a System.Object which is stored on the managed heap.</span></span> <span data-ttu-id="90b02-147">Daher wird der Arbeitsspeicher zugeordnet, und schließlich muss der Speicherplatz verworfen werden, wenn er vom Garbage Collector verarbeitet wird.</span><span class="sxs-lookup"><span data-stu-id="90b02-147">Thus, memory is allocated and eventually when disposed must be processed by the garbage collector.</span></span> <span data-ttu-id="90b02-148">Diese Zuordnungen und Aufhebungen verursachen einen Leistungs Aufwand, und in vielen Szenarien sind Sie unnötig oder können einfach durch eine kostengünstigere Alternative ersetzt werden.</span><span class="sxs-lookup"><span data-stu-id="90b02-148">These allocations and deallocations incur a performance cost and in many scenarios are unnecessary or can be easily replaced by a less expensive alternative.</span></span>

    <span data-ttu-id="90b02-149">Eine der gängigsten Formen des Boxens in der Entwicklung ist die Verwendung von [Werttypen](https://docs.microsoft.com//dotnet/csharp/programming-guide/nullable-types/), die NULL-Werte zulassen.</span><span class="sxs-lookup"><span data-stu-id="90b02-149">One of the most common forms of boxing in development is the use of [nullable value types](https://docs.microsoft.com//dotnet/csharp/programming-guide/nullable-types/).</span></span> <span data-ttu-id="90b02-150">Es ist üblich, dass Sie in der Lage sein möchten, NULL für einen Werttyp in einer Funktion zurückzugeben, insbesondere dann, wenn der Vorgang möglicherweise nicht versucht, den Wert zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="90b02-150">It is common to want to be able to return null for a value type in a function especially when the operation may fail trying to get the value.</span></span> <span data-ttu-id="90b02-151">Das potenzielle Problem bei diesem Ansatz besteht darin, dass die Zuordnung jetzt auf dem Heap erfolgt und daher später eine Garbage Collection durchgeführt werden muss.</span><span class="sxs-lookup"><span data-stu-id="90b02-151">The potential problem with this approach is that allocation now occur on the heap and consequently need to be garbage collected later.</span></span>

    <span data-ttu-id="90b02-152">**Beispiel für Boxing inC#**</span><span class="sxs-lookup"><span data-stu-id="90b02-152">**Example of boxing in C#**</span></span>

    ```csharp
    // boolean value type is boxed into object boxedMyVar on the heap
    bool myVar = true;
    object boxedMyVar = myVar;
    ```

    <span data-ttu-id="90b02-153">**Beispiel für problematischen Boxing über Werttypen, die NULL-Werte zulassen**</span><span class="sxs-lookup"><span data-stu-id="90b02-153">**Example of problematic boxing via nullable value types**</span></span>

    <span data-ttu-id="90b02-154">Dieser Code veranschaulicht eine Dummy-Partikel Klasse, die in einem Unity-Projekt erstellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="90b02-154">This code demonstrates a dummy particle class that one may create in a Unity project.</span></span> <span data-ttu-id="90b02-155">Ein Aufruf von `TryGetSpeed()` bewirkt, dass die Objekt Zuordnung auf dem Heap erfolgt, der zu einem späteren Zeitpunkt in den Garbage Collector aufgenommen werden muss.</span><span class="sxs-lookup"><span data-stu-id="90b02-155">A call to `TryGetSpeed()` will cause object allocation on the heap which will need to be garbage collected at a later point in time.</span></span> <span data-ttu-id="90b02-156">Dieses Beispiel ist besonders problematisch, da in einer Szene 1000 oder mehr Partikel vorhanden sein können, die jeweils zur aktuellen Geschwindigkeit aufgefordert werden.</span><span class="sxs-lookup"><span data-stu-id="90b02-156">This example is particularly problematic as there may be 1000+ or many more particles in a scene, each being asked for their current speed.</span></span> <span data-ttu-id="90b02-157">Folglich würden 1000 von Objekten zugeordnet und folglich die Zuordnung jedes Frames aufgehoben, wodurch die Leistung erheblich beeinträchtigt wird.</span><span class="sxs-lookup"><span data-stu-id="90b02-157">Thus, 1000's of objects would be allocated and consequently de-allocated every frame which would greatly diminish performance.</span></span> <span data-ttu-id="90b02-158">Wenn Sie die Funktion so umschreiben, dass ein negativer Wert, wie z. b.-1, zurückgegeben wird, um einen Fehler anzugeben, wird dieses Problem vermieden, und der Arbeitsspeicher</span><span class="sxs-lookup"><span data-stu-id="90b02-158">Re-writing the function to return a negative value such as -1 to indicate a failure would avoid this issue and keep memory on the stack.</span></span>

    ```csharp
        public class MyParticle
        {
            // Example of function returning nullable value type
            public int? TryGetSpeed()
            {
                // Returns current speed int value or null if fails
            }
        }
    ```

#### <a name="repeating-code-paths"></a><span data-ttu-id="90b02-159">Wiederholte Codepfade</span><span class="sxs-lookup"><span data-stu-id="90b02-159">Repeating code paths</span></span>

<span data-ttu-id="90b02-160">Alle wiederholten Unity-Rückruf Funktionen (d. h.</span><span class="sxs-lookup"><span data-stu-id="90b02-160">Any repeating Unity callback functions (i.e</span></span> <span data-ttu-id="90b02-161">Update), die mehrmals pro Sekunde und/oder Frame ausgeführt werden, sollten sehr sorgfältig geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="90b02-161">Update) that are executed many times per second and/or frame should be written very carefully.</span></span> <span data-ttu-id="90b02-162">Alle teuren Vorgänge hier haben eine enorme und konsistente Auswirkung auf die Leistung.</span><span class="sxs-lookup"><span data-stu-id="90b02-162">Any expensive operations here will have huge and consistent impact on performance.</span></span>

1) <span data-ttu-id="90b02-163">**Leere Rückruf Funktionen**</span><span class="sxs-lookup"><span data-stu-id="90b02-163">**Empty callback functions**</span></span>

    <span data-ttu-id="90b02-164">Obwohl der nachfolgende Code in der Anwendung unaktiviert erscheinen mag, insbesondere, da jedes Unity-Skript automatisch mit diesem Codeblock initialisiert wird, können diese leeren Rückrufe tatsächlich sehr kostspielig werden.</span><span class="sxs-lookup"><span data-stu-id="90b02-164">Although the code below may seem innocent to leave in your application, especially since every Unity script auto-initializes with this code block, these empty callbacks can actually become very expensive.</span></span> <span data-ttu-id="90b02-165">Unity arbeitet über eine nicht verwaltete/verwaltete Code Grenze zwischen unityengine-Code und dem Anwendungscode hin und her.</span><span class="sxs-lookup"><span data-stu-id="90b02-165">Unity operates back and forth over an unmanaged/managed code boundary, between UnityEngine code and your application code.</span></span> <span data-ttu-id="90b02-166">Der Kontextwechsel über diese Bridge ist auch dann recht aufwendig, wenn nichts ausgeführt werden muss.</span><span class="sxs-lookup"><span data-stu-id="90b02-166">Context switching over this bridge is fairly expensive even if there is nothing to execute.</span></span> <span data-ttu-id="90b02-167">Dies wird besonders problematisch, wenn Ihre APP über 100 gameobjects-Objekte mit Komponenten verfügt, die sich wiederholende Unity-Rückrufe befinden.</span><span class="sxs-lookup"><span data-stu-id="90b02-167">This becomes especially problematic if your app has 100's of GameObjects with components that have empty repeating Unity callbacks.</span></span>

    ```CS
    void Update()
    {
    }
    ```

>[!NOTE]
> <span data-ttu-id="90b02-168">Update () ist die häufigste Erscheinung dieses Leistungs Problems, aber andere sich wiederholende Unity-Rückrufe wie die folgenden können gleichermaßen schlecht sein, wenn Sie nicht schlechter sind: fixedupdate (), lateupdate (), onpostranender ", OnPreRender (), onrenderimage () usw.</span><span class="sxs-lookup"><span data-stu-id="90b02-168">Update() is the most common manifestation of this performance issue but other repeating Unity callbacks such as the following can be equally as bad if not worse: FixedUpdate(), LateUpdate(), OnPostRender", OnPreRender(), OnRenderImage(), etc.</span></span> 

2) <span data-ttu-id="90b02-169">**Vorgänge, die eine einmalige Ausführung pro Frame bevorzugen**</span><span class="sxs-lookup"><span data-stu-id="90b02-169">**Operations to favor running once per frame**</span></span>

    <span data-ttu-id="90b02-170">Die folgenden Unity-APIs sind gängige Vorgänge für viele Holographic-apps.</span><span class="sxs-lookup"><span data-stu-id="90b02-170">The following Unity APIs are common operations for many Holographic Apps.</span></span> <span data-ttu-id="90b02-171">Obwohl dies nicht immer möglich ist, können die Ergebnisse dieser Funktionen sehr häufig einmal berechnet werden, und die Ergebnisse werden in der gesamten Anwendung für einen bestimmten Frame wieder verwendet.</span><span class="sxs-lookup"><span data-stu-id="90b02-171">Although not always possible, the results from these functions can very commonly be computed once and the results re-utilized across the application for a given frame.</span></span>

    <span data-ttu-id="90b02-172">a) in der Regel empfiehlt es sich, eine dedizierte Singleton-Klasse oder einen dedizierten Dienst zu verwenden, um Ihren Blick in die Szene zu verarbeiten und dieses Ergebnis dann in allen anderen Szenen Komponenten wieder zu verwenden, anstatt wiederholt und im Wesentlichen identische raycast Vorgänge durchzuführen. Zulieferern.</span><span class="sxs-lookup"><span data-stu-id="90b02-172">a) Generally it is good practice to have a dedicated Singleton class or service to handle your gaze Raycast into the scene and then re-use this result in all other scene components, instead of making repeated and essentially identical Raycast operations by each component.</span></span> <span data-ttu-id="90b02-173">Natürlich erfordern einige Anwendungen möglicherweise Raycasts aus unterschiedlichen Ursprüngen oder mit unterschiedlichen [layermasken](https://docs.unity3d.com/ScriptReference/LayerMask.html).</span><span class="sxs-lookup"><span data-stu-id="90b02-173">Of course, some applications may require raycasts from different origins or against different [LayerMasks](https://docs.unity3d.com/ScriptReference/LayerMask.html).</span></span>

        UnityEngine.Physics.Raycast()
        UnityEngine.Physics.RaycastAll()

    <span data-ttu-id="90b02-174">b) vermeiden von getComponent ()-Vorgängen in wiederholten Unity-Rückrufen wie Update () durch zwischen [Speichern von verweisen](#cache-references) in Start () oder Awake ()</span><span class="sxs-lookup"><span data-stu-id="90b02-174">b) Avoid GetComponent() operations in repeated Unity callbacks like Update() by [caching references](#cache-references) in Start() or Awake()</span></span>

        UnityEngine.Object.GetComponent()

    <span data-ttu-id="90b02-175">c) Es empfiehlt sich, nach Möglichkeit alle Objekte bei der Initialisierung zu instanziieren und das [Objekt Pooling](#object-pooling) zu verwenden, um gameobjects während der Laufzeit der Anwendung wiederzuverwenden.</span><span class="sxs-lookup"><span data-stu-id="90b02-175">c) It is good practice to instantiate all objects, if possible, at initialization and use [object pooling](#object-pooling) to recycle and re-use GameObjects throughout runtime of your application</span></span>

        UnityEngine.Object.Instantiate()

3) <span data-ttu-id="90b02-176">**Vermeiden von Schnittstellen und virtuellen Konstrukten**</span><span class="sxs-lookup"><span data-stu-id="90b02-176">**Avoid interfaces and virtual constructs**</span></span>

    <span data-ttu-id="90b02-177">Das Aufrufen von Funktionsaufrufen über Schnittstellen im Vergleich zu direkten Objekten oder Aufrufen von virtuellen Funktionen kann häufig sehr viel teurer sein als die Verwendung von direkten Konstrukten oder direkten Funktionsaufrufen.</span><span class="sxs-lookup"><span data-stu-id="90b02-177">Invoking function calls through interfaces vs direct objects or calling virtual functions can often times be much more expensive than utilizing direct constructs or direct function calls.</span></span> <span data-ttu-id="90b02-178">Wenn die virtuelle Funktion oder Schnittstelle unnötig ist, sollte Sie entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="90b02-178">If the virtual function or interface is unnecessary, then it should be removed.</span></span> <span data-ttu-id="90b02-179">Die Leistungseinbußen, die für diese Ansätze erzielt werden, sind jedoch in der Regel der Kompromiss, wenn Sie die Entwicklung, die Lesbarkeit von Code und die Verwaltbarkeit des Codes vereinfachen.</span><span class="sxs-lookup"><span data-stu-id="90b02-179">However, the performance hit for these approaches are generally worth the trade-off if utilizing them simplifies development collaboration, code readability, and code maintainability.</span></span>

    <span data-ttu-id="90b02-180">Im Allgemeinen wird empfohlen, Felder und Funktionen nicht als virtuell zu markieren, es sei denn, es gibt eine klare Annahme, dass dieser Member überschrieben werden muss.</span><span class="sxs-lookup"><span data-stu-id="90b02-180">Generally, the recommendation is to not mark fields and functions as virtual unless there is a clear expectation that this member needs to be overwritten.</span></span> <span data-ttu-id="90b02-181">Sie sollten vor allem bei hochfrequenten Codepfade vorsichtig sein, die mehrmals pro Frame oder sogar einmal pro Frame aufgerufen werden, wie z. b. eine `UpdateUI()` Methode.</span><span class="sxs-lookup"><span data-stu-id="90b02-181">One should be especially careful around high-frequency code paths that are called many times per frame or even once per frame such as an `UpdateUI()` method.</span></span>

4) <span data-ttu-id="90b02-182">**Vermeiden Sie das Übergeben von Strukturen nach Wert.**</span><span class="sxs-lookup"><span data-stu-id="90b02-182">**Avoid passing structs by value**</span></span>

    <span data-ttu-id="90b02-183">Im Unterschied zu Klassen sind Strukturen Werttypen. Wenn Sie direkt an eine Funktion geleitet werden, werden Ihre Inhalte in eine neu erstellte-Instanz kopiert.</span><span class="sxs-lookup"><span data-stu-id="90b02-183">Unlike classes, structs are value-types and when passed directly to a function, their contents are copied into a newly created instance.</span></span> <span data-ttu-id="90b02-184">Mit dieser Kopie werden CPU-Kosten und zusätzlicher Arbeitsspeicher im Stapel hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="90b02-184">This copy adds CPU cost as well as additional memory on the stack.</span></span> <span data-ttu-id="90b02-185">Bei kleinen Strukturen ist der Effekt in der Regel sehr minimal und somit akzeptabel.</span><span class="sxs-lookup"><span data-stu-id="90b02-185">For small structs, the effect is usually very minimal and thus acceptable.</span></span> <span data-ttu-id="90b02-186">Bei Funktionen, die von jedem Frame wiederholt aufgerufen werden, sowie von Funktionen, die große Strukturen übernehmen, sollten Sie, wenn möglich, die Funktionsdefinition als Verweis übergeben.</span><span class="sxs-lookup"><span data-stu-id="90b02-186">However, for functions repeatedly invoked every frame as well as functions taking large structs, if possible modify the function definition to pass by reference.</span></span> [<span data-ttu-id="90b02-187">Weitere Informationen finden Sie hier</span><span class="sxs-lookup"><span data-stu-id="90b02-187">Learn more here</span></span>](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/how-to-know-the-difference-passing-a-struct-and-passing-a-class-to-a-method)

#### <a name="miscellaneous"></a><span data-ttu-id="90b02-188">Sonstiges</span><span class="sxs-lookup"><span data-stu-id="90b02-188">Miscellaneous</span></span>

1) <span data-ttu-id="90b02-189">**Mikro**</span><span class="sxs-lookup"><span data-stu-id="90b02-189">**Physics**</span></span>

    <span data-ttu-id="90b02-190">a) im Allgemeinen ist es am einfachsten, die Physik zu verbessern, indem die für die Physik und die Anzahl der Iterationen pro Sekunde aufgewendet Zeit beschränkt wird.</span><span class="sxs-lookup"><span data-stu-id="90b02-190">a) Generally, easiest way to improve physics is to limit the amount of time spent on Physics or the number of iterations per second.</span></span> <span data-ttu-id="90b02-191">Dadurch wird natürlich die Simulations Genauigkeit reduziert.</span><span class="sxs-lookup"><span data-stu-id="90b02-191">Of course, this will reduce simulation accuracy.</span></span> <span data-ttu-id="90b02-192">Siehe [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) in Unity</span><span class="sxs-lookup"><span data-stu-id="90b02-192">See [TimeManager](https://docs.unity3d.com/Manual/class-TimeManager.html) in Unity</span></span>

    <span data-ttu-id="90b02-193">b) der Typ von Kollisionen in Unity weist stark unterschiedliche Leistungsmerkmale auf.</span><span class="sxs-lookup"><span data-stu-id="90b02-193">b) The type of colliders in Unity have widely different performance characteristics.</span></span> <span data-ttu-id="90b02-194">In der folgenden Reihenfolge werden die leistungsfähigsten Kollisionen der am wenigsten leistungsfähigen Kollisionen von links nach rechts aufgeführt.</span><span class="sxs-lookup"><span data-stu-id="90b02-194">The order below lists the most performant colliders to least performant colliders from left to right.</span></span> <span data-ttu-id="90b02-195">Es ist am wichtigsten, Mesh-Kollisionen zu vermeiden, die wesentlich teurer als die primitiven Kollisionen sind.</span><span class="sxs-lookup"><span data-stu-id="90b02-195">It is most important to avoid Mesh Colliders which are substantially more expensive than the primitive colliders.</span></span>

        Sphere < Capsule < Box <<< Mesh (Convex) < Mesh (non-Convex)

    <span data-ttu-id="90b02-196">Weitere Informationen finden Sie unter [bewährte Methoden](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) für die Unity-Physik</span><span class="sxs-lookup"><span data-stu-id="90b02-196">See [Unity Physics Best Practices](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices) for more info</span></span>

2) <span data-ttu-id="90b02-197">**Taine**</span><span class="sxs-lookup"><span data-stu-id="90b02-197">**Animations**</span></span>

    <span data-ttu-id="90b02-198">Deaktivieren Sie die Animation im Leerlauf, indem Sie die animatorkomponente deaktivieren (die Deaktivierung des Spiel Objekts hat nicht denselben Effekt).</span><span class="sxs-lookup"><span data-stu-id="90b02-198">Disable idle animations by disabling the Animator component (disabling the game object won't have the same effect).</span></span> <span data-ttu-id="90b02-199">Vermeiden Sie Entwurfsmuster, bei denen sich ein Animator in einer Schleife befindet, in der ein Wert auf dieselbe Aktion festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="90b02-199">Avoid design patterns where an animator sits in a loop setting a value to the same thing.</span></span> <span data-ttu-id="90b02-200">Für diese Technik gibt es einen beträchtlichen Aufwand, ohne dass die Anwendung beeinträchtigt wird.</span><span class="sxs-lookup"><span data-stu-id="90b02-200">There is considerable overhead for this technique, with no effect on the application.</span></span> [<span data-ttu-id="90b02-201">Weitere Informationen finden Sie hier.</span><span class="sxs-lookup"><span data-stu-id="90b02-201">Learn more here.</span></span>](https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html)

3) <span data-ttu-id="90b02-202">**Komplexe Algorithmen**</span><span class="sxs-lookup"><span data-stu-id="90b02-202">**Complex algorithms**</span></span>

    <span data-ttu-id="90b02-203">Wenn Ihre Anwendung komplexe Algorithmen verwendet, wie z. b. umgekehrte Kinematik, Pfad Suche usw., suchen Sie nach einem einfacheren Ansatz, oder passen Sie relevante Einstellungen für Ihre Leistung an.</span><span class="sxs-lookup"><span data-stu-id="90b02-203">If your application is using complex algorithms such as inverse kinematics, path finding, etc, look to find a simpler approach or adjust relevant settings for their performance</span></span>

## <a name="cpu-to-gpu-performance-recommendations"></a><span data-ttu-id="90b02-204">Empfehlungen zur CPU-zu-GPU-Leistung</span><span class="sxs-lookup"><span data-stu-id="90b02-204">CPU-to-GPU performance recommendations</span></span>

<span data-ttu-id="90b02-205">Im Allgemeinen kommt die CPU-zu-GPU-Leistung auf die **Zeichnen-Aufrufe** an, die an die Grafikkarte übermittelt werden.</span><span class="sxs-lookup"><span data-stu-id="90b02-205">Generally, CPU-to-GPU performance comes down to the **draw calls** submitted to the graphics card.</span></span> <span data-ttu-id="90b02-206">Um die Leistung zu verbessern, müssen Draw-Aufrufe strategisch **a) reduziert** oder **b) umstrukturiert** werden, um optimale Ergebnisse zu erzielen.</span><span class="sxs-lookup"><span data-stu-id="90b02-206">To improve performance, draw calls need to be strategically **a) reduced** or **b) restructured** for optimal results.</span></span> <span data-ttu-id="90b02-207">Da zeichnen-Aufrufe selbst ressourcenintensiv sind, verringern Sie dadurch die insgesamt erforderliche Arbeit.</span><span class="sxs-lookup"><span data-stu-id="90b02-207">Since draw calls themselves are resource-intensive, reducing them will reduce overall work required.</span></span> <span data-ttu-id="90b02-208">Außerdem erfordert die Zustandsänderung zwischen zeichnen-aufrufen kostspielige Validierungs-und Übersetzungsschritte im Grafiktreiber und somit die Umstrukturierung der Draw-Aufrufe Ihrer Anwendung, um Zustandsänderungen einzuschränken (d. h.</span><span class="sxs-lookup"><span data-stu-id="90b02-208">Further, state changes between draw calls requires costly validation and translation steps in the graphics driver and thus, restructuring of your application's draw calls to limit state changes(i.e</span></span> <span data-ttu-id="90b02-209">verschiedene Materialien usw.) können die Leistung steigern.</span><span class="sxs-lookup"><span data-stu-id="90b02-209">different materials, etc) can boost performance.</span></span>

<span data-ttu-id="90b02-210">Unity bietet einen großartigen Artikel, der einen Überblick über die Batch Verarbeitung von Draw-aufrufen für Ihre Plattform bietet.</span><span class="sxs-lookup"><span data-stu-id="90b02-210">Unity has a great article that gives an overview and dives into batching draw calls for their platform.</span></span>
- [<span data-ttu-id="90b02-211">Batch Verarbeitung von Unity-zeichnen-aufrufen</span><span class="sxs-lookup"><span data-stu-id="90b02-211">Unity Draw Call Batching</span></span>](https://docs.unity3d.com/Manual/DrawCallBatching.html)

#### <a name="single-pass-instanced-rendering"></a><span data-ttu-id="90b02-212">Single Pass-instanziziertes Rendering</span><span class="sxs-lookup"><span data-stu-id="90b02-212">Single pass instanced rendering</span></span>

<span data-ttu-id="90b02-213">Bei einem Single Pass-instanziierten Rendering in Unity können zeichnen-Aufrufe für jedes Auge auf einen instanziierten Draw-Aufruf reduziert werden.</span><span class="sxs-lookup"><span data-stu-id="90b02-213">Single Pass Instanced Rendering in Unity allows for draw calls for each eye to be reduced down to one instanced draw call.</span></span> <span data-ttu-id="90b02-214">Aufgrund der Cache Kohärenz zwischen zwei Draw-aufrufen gibt es auch eine gewisse Leistungsverbesserung bei der GPU.</span><span class="sxs-lookup"><span data-stu-id="90b02-214">Due to cache coherency between two draw calls, there is also some performance improvement on the GPU as well.</span></span>

<span data-ttu-id="90b02-215">So aktivieren Sie dieses Feature in Ihrem Unity-Projekt</span><span class="sxs-lookup"><span data-stu-id="90b02-215">To enable this feature in your Unity Project</span></span>
1)  <span data-ttu-id="90b02-216">Öffnen Sie die **Player-XR-Einstellungen** (wechseln Sie zu **Edit** > **Project Settings** > **Player** > **XR-Einstellungen**)</span><span class="sxs-lookup"><span data-stu-id="90b02-216">Open **Player XR Settings** (go to **Edit** > **Project Settings** > **Player** > **XR Settings**)</span></span>
2) <span data-ttu-id="90b02-217">Wählen Sie im Dropdown Menü der **Stereo Renderingmethode** die Option **Single Pass-instanziierten** aus (Kontrollkästchen**Virtual Reality supported** muss aktiviert sein).</span><span class="sxs-lookup"><span data-stu-id="90b02-217">Select **Single Pass Instanced** from the **Stereo Rendering Method** drop-down menu (**Virtual Reality Supported** checkbox must be checked)</span></span>

<span data-ttu-id="90b02-218">Weitere Informationen zu diesem renderingansatz finden Sie in den folgenden Artikeln von Unity.</span><span class="sxs-lookup"><span data-stu-id="90b02-218">Read the following articles from Unity for details with this rendering approach.</span></span>
- [<span data-ttu-id="90b02-219">Maximieren der AR-und VR-Leistung mit dem erweiterten Stereo Rendering</span><span class="sxs-lookup"><span data-stu-id="90b02-219">How to maximize AR and VR performance with advanced stereo rendering</span></span>](https://blogs.unity3d.com/2017/11/21/how-to-maximize-ar-and-vr-performance-with-advanced-stereo-rendering/)
- [<span data-ttu-id="90b02-220">Einzelpass-Instanziierung</span><span class="sxs-lookup"><span data-stu-id="90b02-220">Single Pass Instancing</span></span>](https://docs.unity3d.com/Manual/SinglePassInstancing.html) 

>[!NOTE]
> <span data-ttu-id="90b02-221">Ein häufiges Problem mit einem einzelnen Pass-instanziierten Rendering tritt auf, wenn Entwickler bereits über vorhandene benutzerdefinierte Shader verfügen, die nicht für die Instanziierung</span><span class="sxs-lookup"><span data-stu-id="90b02-221">One common issue with Single Pass Instanced Rendering occurs if developers already have existing custom shaders not written for instancing.</span></span> <span data-ttu-id="90b02-222">Nachdem Sie diese Funktion aktiviert haben, bemerken Entwickler möglicherweise, dass einige gameobjects nur in einem Blick dargestellt werden.</span><span class="sxs-lookup"><span data-stu-id="90b02-222">After enabling this feature, developers may notice some GameObjects only render in one eye.</span></span> <span data-ttu-id="90b02-223">Dies liegt daran, dass die zugeordneten benutzerdefinierten Shader nicht über die entsprechenden Eigenschaften für die Instanziierung verfügen.</span><span class="sxs-lookup"><span data-stu-id="90b02-223">This is because the associated custom shaders do not have the appropriate properties for instancing.</span></span>
>
> <span data-ttu-id="90b02-224">Informationen zum Beheben dieses Problems finden Sie unter [Single Pass Stereo Rendering for hololens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) from Unity.</span><span class="sxs-lookup"><span data-stu-id="90b02-224">See [Single Pass Stereo Rendering for HoloLens](https://docs.unity3d.com/Manual/SinglePassStereoRenderingHoloLens.html) from Unity for how to address this problem</span></span>

#### <a name="static-batching"></a><span data-ttu-id="90b02-225">Statische Batch Verarbeitung</span><span class="sxs-lookup"><span data-stu-id="90b02-225">Static batching</span></span>

<span data-ttu-id="90b02-226">Unity kann viele statische Objekte in Batches erstellen, um Draw-Aufrufe an die GPU zu verringern.</span><span class="sxs-lookup"><span data-stu-id="90b02-226">Unity is able to batch many static objects to reduce draw calls to the GPU.</span></span> <span data-ttu-id="90b02-227">Die statische Batchverarbeitung funktioniert für die meisten [Renderer](https://docs.unity3d.com/ScriptReference/Renderer.html)-Objekte in Unity, die **dasselbe Material aufweisen** und **als *Static* markiert sind**. (Wählen Sie ein Objekt in Unity aus, und klicken Sie auf das Kontrollkästchen in der oberen rechten Ecke des Inspektors.)</span><span class="sxs-lookup"><span data-stu-id="90b02-227">Static Batching works for most [Renderer](https://docs.unity3d.com/ScriptReference/Renderer.html) objects in Unity that **1) share the same material** and **2) are all marked as *Static*** (Select an object in Unity and click the checkbox in the top right of the inspector).</span></span> <span data-ttu-id="90b02-228">Gameobjects, die als *statisch* gekennzeichnet sind, können nicht während der Laufzeit der Anwendung verschoben werden.</span><span class="sxs-lookup"><span data-stu-id="90b02-228">GameObjects marked as *Static* cannot be moved throughout your application's runtime.</span></span> <span data-ttu-id="90b02-229">Daher kann es schwierig sein, die statische Batch Verarbeitung auf hololens zu nutzen, bei dem praktisch jedes Objekt platziert, verschoben, skaliert usw. werden muss. Bei immersiven Headsets kann die statische Batch Verarbeitung zeichnen-Aufrufe drastisch reduzieren und somit die Leistung verbessern.</span><span class="sxs-lookup"><span data-stu-id="90b02-229">Thus, static batching can be difficult to leverage on HoloLens where virtually every object needs to be placed, moved, scaled, etc. For immersive headsets, static batching can dramatically reduce draw calls and thus improve performance.</span></span>

<span data-ttu-id="90b02-230">Ausführlichere Informationen *finden Sie unter* [Batch Verarbeitung in der Batch Verarbeitung in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) .</span><span class="sxs-lookup"><span data-stu-id="90b02-230">Read *Static Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for more details.</span></span>

#### <a name="dynamic-batching"></a><span data-ttu-id="90b02-231">Dynamische Batch Verarbeitung</span><span class="sxs-lookup"><span data-stu-id="90b02-231">Dynamic batching</span></span>

<span data-ttu-id="90b02-232">Da das Markieren von Objekten als *statisch* für die Entwicklung von hololens problematisch ist, kann die dynamische Batch Verarbeitung ein hervorragend Tool sein, um diese fehlende Funktion auszugleichen.</span><span class="sxs-lookup"><span data-stu-id="90b02-232">Since it is problematic to mark objects as *Static* for HoloLens development, dynamic batching can be a great tool to compensate for this lacking feature.</span></span> <span data-ttu-id="90b02-233">Natürlich kann es auch für immersive Headsets nützlich sein.</span><span class="sxs-lookup"><span data-stu-id="90b02-233">Of course, it is can also be useful on immersive headsets as well.</span></span> <span data-ttu-id="90b02-234">Die dynamische Batch Verarbeitung in Unity kann schwierig sein, um dies zu ermöglichen, weil gameobjects eine aufweisen muss **) dasselbe Material gemeinsam** verwenden und **b) eine lange Liste anderer Kriterien erfüllen**.</span><span class="sxs-lookup"><span data-stu-id="90b02-234">Dynamic batching in Unity can be difficult though to enable because GameObjects must **a) share the same Material** and **b) meet a long list of other criteria**.</span></span>

<span data-ttu-id="90b02-235">Lesen Sie die *dynamische Batch* Verarbeitung unter [Zeichnen von zeichnen-aufrufen in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) für die vollständige Liste.</span><span class="sxs-lookup"><span data-stu-id="90b02-235">Read *Dynamic Batching* under [Draw Call Batching in Unity](https://docs.unity3d.com/Manual/DrawCallBatching.html) for the full list.</span></span> <span data-ttu-id="90b02-236">In den meisten Fällen werden gameobjects ungültig, damit Sie in einem Batch zusammengefasst werden, da die zugeordneten Mesh-Daten nicht mehr als 300 Scheitel Punkte aufweisen können.</span><span class="sxs-lookup"><span data-stu-id="90b02-236">Most commonly, GameObjects become invalid to be batched dynamically because the associated mesh data can be no more than 300 vertices.</span></span>

#### <a name="other-techniques"></a><span data-ttu-id="90b02-237">Weitere Verfahren</span><span class="sxs-lookup"><span data-stu-id="90b02-237">Other techniques</span></span>

<span data-ttu-id="90b02-238">Die Batch Verarbeitung kann nur auftreten, wenn mehrere gameobjects dasselbe Material gemeinsam verwenden können.</span><span class="sxs-lookup"><span data-stu-id="90b02-238">Batching can only occur if multiple GameObjects are able to share the same material.</span></span> <span data-ttu-id="90b02-239">Dies wird in der Regel dadurch blockiert, dass gameobjects eine eindeutige Textur für das jeweilige Material aufweisen muss.</span><span class="sxs-lookup"><span data-stu-id="90b02-239">Typically this will be blocked by the need for GameObjects to have a unique texture for their respective Material.</span></span> <span data-ttu-id="90b02-240">Es ist üblich, Texturen in eine große Textur zu kombinieren, eine Methode, die als [Textur](https://en.wikipedia.org/wiki/Texture_atlas)Nachweis bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="90b02-240">It is common to combine Textures into one big Texture, a method known as [Texture Atlasing](https://en.wikipedia.org/wiki/Texture_atlas).</span></span>

<span data-ttu-id="90b02-241">Außerdem ist es in der Regel besser, nach Möglichkeit und vernünftig Nachrichten in einem gameobject zu kombinieren.</span><span class="sxs-lookup"><span data-stu-id="90b02-241">Further, it is generally preferable to combine meshes into one GameObject where possible and reasonable.</span></span> <span data-ttu-id="90b02-242">Jeder Renderer in Unity verfügt über einen zugeordneten zeichnen-Befehl (en) im Vergleich zum Senden eines kombinierten Netzes unter einem Renderer.</span><span class="sxs-lookup"><span data-stu-id="90b02-242">Each Renderer in Unity will have it's associated draw call(s) versus submitting a combined mesh under one Renderer.</span></span>

>[!NOTE]
> <span data-ttu-id="90b02-243">Wenn Sie die Eigenschaften von Renderer. Material zur Laufzeit ändern, wird eine Kopie des Materials erstellt und somit die Batch Verarbeitung möglicherweise unterbrechen.</span><span class="sxs-lookup"><span data-stu-id="90b02-243">Modifying properties of Renderer.material at runtime will create a copy of the Material and thus potentially break batching.</span></span> <span data-ttu-id="90b02-244">Verwenden Sie Renderer. sharedmaterial, um freigegebene Materialeigenschaften über gameobjects zu ändern.</span><span class="sxs-lookup"><span data-stu-id="90b02-244">Use Renderer.sharedMaterial to modify shared material properties across GameObjects.</span></span>

## <a name="gpu-performance-recommendations"></a><span data-ttu-id="90b02-245">Empfehlungen zur GPU-Leistung</span><span class="sxs-lookup"><span data-stu-id="90b02-245">GPU performance recommendations</span></span>

<span data-ttu-id="90b02-246">Weitere Informationen zum [Optimieren des Grafik Rendering in Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span><span class="sxs-lookup"><span data-stu-id="90b02-246">Learn more about [optimizing graphics rendering in Unity](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games)</span></span>

### <a name="optimize-depth-buffer-sharing"></a><span data-ttu-id="90b02-247">Optimieren der tiefen Puffer Freigabe</span><span class="sxs-lookup"><span data-stu-id="90b02-247">Optimize depth buffer sharing</span></span>

<span data-ttu-id="90b02-248">Im Allgemeinen wird empfohlen, die **Tiefe Puffer Freigabe** unter den Einstellungen von " **Player XR** " zu aktivieren, um die [Stabilität von – Hologramm](Hologram-stability.md)zu optimieren</span><span class="sxs-lookup"><span data-stu-id="90b02-248">It is generally recommended to enable **Depth buffer sharing** under **Player XR Settings** to optimize for [hologram stability](Hologram-stability.md).</span></span> <span data-ttu-id="90b02-249">Beim Aktivieren der tiefen basierten neuprojektion mit dieser Einstellung wird jedoch empfohlen, anstelle des **24-Bit-Tiefen**Formats ein **16-Bit-Tiefen Format** auszuwählen.</span><span class="sxs-lookup"><span data-stu-id="90b02-249">When enabling depth-based late-stage reprojection with this setting however, it is recommended to select **16-bit depth format** instead of **24-bit depth format**.</span></span> <span data-ttu-id="90b02-250">Durch die 16-Bit-Tiefen Puffer wird die Bandbreite (und damit auch die Stromversorgung) drastisch verringert, die dem tiefen Puffer Datenverkehr zugeordnet</span><span class="sxs-lookup"><span data-stu-id="90b02-250">The 16-bit depth buffers will drastically reduces the bandwidth (and thus power) associated with depth buffer traffic.</span></span> <span data-ttu-id="90b02-251">Dies kann ein großer Gewinn sowohl bei der Energie Reduzierung als auch bei der Leistungsverbesserung sein.</span><span class="sxs-lookup"><span data-stu-id="90b02-251">This can be a big win both in power reduction and performance improvement.</span></span> <span data-ttu-id="90b02-252">Es gibt jedoch zwei mögliche negative Ergebnisse, wenn Sie ein *16-Bit-Tiefen Format*verwenden.</span><span class="sxs-lookup"><span data-stu-id="90b02-252">However, there are two possible negative outcomes by using *16-bit depth format*.</span></span>

<span data-ttu-id="90b02-253">**Z-kämpfen**</span><span class="sxs-lookup"><span data-stu-id="90b02-253">**Z-Fighting**</span></span>

<span data-ttu-id="90b02-254">Die Genauigkeit der reduzierten tiefen Bereiche bewirkt, dass [z-Kämpfe](https://en.wikipedia.org/wiki/Z-fighting) mit einem 16-Bit-Wert als 24-Bit wahrscheinlicher werden.</span><span class="sxs-lookup"><span data-stu-id="90b02-254">The reduced depth range fidelity makes [z-fighting](https://en.wikipedia.org/wiki/Z-fighting) more likely to occur with 16-bit than 24-bit.</span></span> <span data-ttu-id="90b02-255">Um diese Artefakte zu vermeiden, ändern Sie die Near-und Far-Clip-Ebenen der [Unity-Kamera](https://docs.unity3d.com/Manual/class-Camera.html) , um die geringere Genauigkeit zu berücksichtigen.</span><span class="sxs-lookup"><span data-stu-id="90b02-255">To avoid these artifacts, modify the near/far clip planes of the [Unity camera](https://docs.unity3d.com/Manual/class-Camera.html) to account for the lower precision.</span></span> <span data-ttu-id="90b02-256">Bei hololens-basierten Anwendungen kann die mittlere Ausschneide Ebene von 50 Mio. anstelle des Unity-Standardwerts von 1000 Millionen in der Regel alle z-Kämpfe eliminieren.</span><span class="sxs-lookup"><span data-stu-id="90b02-256">For HoloLens-based applications, a far clip plane of 50m instead of the Unity default 1000m can generally eliminate any z-fighting.</span></span>

<span data-ttu-id="90b02-257">**Deaktivierter Schablonen Puffer**</span><span class="sxs-lookup"><span data-stu-id="90b02-257">**Disabled Stencil Buffer**</span></span>

<span data-ttu-id="90b02-258">Wenn Unity eine [rendertextur mit 16-Bit-Tiefe](https://docs.unity3d.com/ScriptReference/RenderTexture-depth.html)erstellt, wird kein Schablonen Puffer erstellt.</span><span class="sxs-lookup"><span data-stu-id="90b02-258">When Unity creates a [Render Texture with 16-bit depth](https://docs.unity3d.com/ScriptReference/RenderTexture-depth.html), there is no stencil buffer created.</span></span> <span data-ttu-id="90b02-259">Durch die Auswahl des 24-Bit-Tiefen Formats pro Unity-Dokumentation wird ein 24-Bit-z-Puffer und ein [8-Bit-Schablone](https://docs.unity3d.com/Manual/SL-Stencil.html) erstellt (wenn 32-Bit auf dem Gerät anwendbar ist, was im Allgemeinen der Fall ist, z. b. hololens).</span><span class="sxs-lookup"><span data-stu-id="90b02-259">Selecting 24-bit depth format, per Unity documentation, will create a 24-bit z-buffer as well as an [8-bit stencil buffer](https://docs.unity3d.com/Manual/SL-Stencil.html) (if 32-bit is applicable on device which is generally the case such as HoloLens).</span></span>

### <a name="avoid-full-screen-effects"></a><span data-ttu-id="90b02-260">Vermeiden von vollbildeffekten</span><span class="sxs-lookup"><span data-stu-id="90b02-260">Avoid full-screen effects</span></span>

<span data-ttu-id="90b02-261">Techniken, die auf dem Vollbildmodus ausgeführt werden, können sehr aufwendig sein, da die Reihenfolge der Größe in jedem Frame Millionen von Vorgängen ist.</span><span class="sxs-lookup"><span data-stu-id="90b02-261">Techniques that operate on the full screen can be quite expensive since their order of magnitude is millions of operations every frame.</span></span> <span data-ttu-id="90b02-262">Daher wird empfohlen, [nach Verarbeitungs Effekten](https://docs.unity3d.com/Manual/PostProcessingOverview.html) wie Antialiasing, Blüte und mehr zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="90b02-262">Thus, it is recommended to avoid [post-processing effects](https://docs.unity3d.com/Manual/PostProcessingOverview.html) such as anti-aliasing, bloom, and more.</span></span>

### <a name="optimal-lighting-settings"></a><span data-ttu-id="90b02-263">Optimale Beleuchtungseinstellungen</span><span class="sxs-lookup"><span data-stu-id="90b02-263">Optimal lighting settings</span></span>

<span data-ttu-id="90b02-264">Mit der [globalen Echtzeitbeleuchtung](https://docs.unity3d.com/Manual/GIIntro.html) in Unity können visuelle Ergebnisse bereitgestellt werden, aber es sind sehr teure Beleuchtungsberechnungen enthalten.</span><span class="sxs-lookup"><span data-stu-id="90b02-264">[Real-time Global Illumination](https://docs.unity3d.com/Manual/GIIntro.html) in Unity can provide oustanding visual results but involves quite expensive lighting calculations.</span></span> <span data-ttu-id="90b02-265">Es wird empfohlen, die globale Echtzeitbeleuchtung für jede Unity-Szenen Datei über **Fenster** > **Rendering** > **Beleuchtungseinstellungen** zu deaktivieren > die **Globale Beleuchtung in Echtzeit**zu deaktivieren.</span><span class="sxs-lookup"><span data-stu-id="90b02-265">It is recommended to disable Realtime Global Illumination for every Unity scene file via **Window** > **Rendering** > **Lighting Settings** > Uncheck **Real-time Global Illumination**.</span></span>

<span data-ttu-id="90b02-266">Außerdem wird empfohlen, alle Schatten Umwandlungen zu deaktivieren, da diese auch teure GPU-Pässe zu einer Unity-Szene hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="90b02-266">Further, it is recommended to disable all shadow casting as these also add expensive GPU passes onto a Unity scene.</span></span> <span data-ttu-id="90b02-267">Schatten können pro Licht deaktiviert werden, können aber auch über Qualitätseinstellungen ganzheitlich gesteuert werden.</span><span class="sxs-lookup"><span data-stu-id="90b02-267">Shadows can be disable per light but can also be controlled holistically via Quality settings.</span></span>

<span data-ttu-id="90b02-268">**Bearbeiten** Sie > **Projekteinstellungen**, und wählen Sie dann die Kategorie **Qualität** aus, > Wählen Sie für die UWP-Plattform **niedrige Qualität** aus.</span><span class="sxs-lookup"><span data-stu-id="90b02-268">**Edit** > **Project Settings**, then select the **Quality** category > Select **Low Quality** for the UWP Platform.</span></span> <span data-ttu-id="90b02-269">Sie können auch die **Shadows** -Eigenschaft so festlegen, dass **Schatten deaktiviert**werden.</span><span class="sxs-lookup"><span data-stu-id="90b02-269">One can also just set the **Shadows** property to **Disable Shadows**.</span></span>

### <a name="reduce-poly-count"></a><span data-ttu-id="90b02-270">Reduzieren der polyzahl</span><span class="sxs-lookup"><span data-stu-id="90b02-270">Reduce poly count</span></span>

<span data-ttu-id="90b02-271">Die Polygon Anzahl wird in der Regel durch</span><span class="sxs-lookup"><span data-stu-id="90b02-271">Polygon count is usually reduced by either</span></span>
1) <span data-ttu-id="90b02-272">Entfernen von Objekten aus einer Szene</span><span class="sxs-lookup"><span data-stu-id="90b02-272">Removing objects from a scene</span></span>
2) <span data-ttu-id="90b02-273">Assetdezigierung, die die Anzahl von Polygonen für ein bestimmtes Mesh reduziert</span><span class="sxs-lookup"><span data-stu-id="90b02-273">Asset decimation which reduces the number of polygons for a given mesh</span></span>
3) <span data-ttu-id="90b02-274">Implementieren eines [Lod-Systems (Level of Detail)](https://docs.unity3d.com/Manual/LevelOfDetail.html) in Ihre Anwendung, das entfernte Objekte mit niedrigerer Polygon Version derselben Geometrie rendert</span><span class="sxs-lookup"><span data-stu-id="90b02-274">Implementing a [Level of Detail (LOD) System](https://docs.unity3d.com/Manual/LevelOfDetail.html) into your application which renders far away objects with lower-polygon version of the same geometry</span></span>

### <a name="understanding-shaders-in-unity"></a><span data-ttu-id="90b02-275">Grundlegendes zu Shadern in Unity</span><span class="sxs-lookup"><span data-stu-id="90b02-275">Understanding shaders in Unity</span></span>

<span data-ttu-id="90b02-276">Eine einfache Näherung zum Vergleichen von Shadern in der Leistung besteht darin, die durchschnittliche Anzahl der Vorgänge zu identifizieren, die jeweils zur Laufzeit ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="90b02-276">An easy approximation to compare shaders in performance is to identify the average number of operations each executes at runtime.</span></span> <span data-ttu-id="90b02-277">Dies kann in Unity problemlos erfolgen.</span><span class="sxs-lookup"><span data-stu-id="90b02-277">This can be done easily in Unity.</span></span>

1) <span data-ttu-id="90b02-278">Wählen Sie Ihr shaderasset aus, oder wählen Sie ein Material aus, und wählen Sie dann in der oberen rechten Ecke des Inspektorfensters das Zahnrad Symbol und dann **"Shader auswählen"** aus.</span><span class="sxs-lookup"><span data-stu-id="90b02-278">Select your shader asset or select a material, then in top right corner of the inspector window, select the gear icon and then **"Select Shader"**</span></span>

    ![Shader in Unity auswählen](images/Select-shader-unity.png)
2) <span data-ttu-id="90b02-280">Wenn das Shader-Medienobjekt ausgewählt ist, klicken Sie im Inspektor-Fenster auf die Schaltfläche **"Code kompilieren und anzeigen"** .</span><span class="sxs-lookup"><span data-stu-id="90b02-280">With the shader asset selected, click the **"Compile and show code"** button under the inspector window</span></span>

    ![Kompilieren von Shader-Code in Unity](images/compile-shader-code-unity.PNG)

3) <span data-ttu-id="90b02-282">Suchen Sie nach dem Kompilieren in den Ergebnissen nach dem Statistik Abschnitt, wobei die Anzahl der verschiedenen Vorgänge sowohl für den Scheitelpunkt als auch für den Pixelshader angezeigt wird (Hinweis: Pixel-Shader werden oft auch als fragmentshader bezeichnet).</span><span class="sxs-lookup"><span data-stu-id="90b02-282">After compiling, look for the statistics section in the results with the number of different operations for both the vertex and pixel shader (Note: pixel shaders are often also called fragment shaders)</span></span>

    ![Unity-Standard-Shader-Vorgänge](images/unity-standard-shader-compilation.png)

#### <a name="optmize-pixel-shaders"></a><span data-ttu-id="90b02-284">Pixel-Shader optmize</span><span class="sxs-lookup"><span data-stu-id="90b02-284">Optmize pixel shaders</span></span>

<span data-ttu-id="90b02-285">Wenn Sie die kompilierten statistischen Ergebnisse mithilfe der obigen Methode betrachten, führt der [fragmentshader](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) im Durchschnitt im Allgemeinen mehr Vorgänge aus als der [Vertex-Shader](https://en.wikipedia.org/wiki/Shader#Vertex_shaders) .</span><span class="sxs-lookup"><span data-stu-id="90b02-285">Looking at the compiled statistic results using the method above, the [fragment shader](https://en.wikipedia.org/wiki/Shader#Pixel_shaders) will generally execute more operations than the [vertex shader](https://en.wikipedia.org/wiki/Shader#Vertex_shaders) on average.</span></span> <span data-ttu-id="90b02-286">Der fragmentshader, auch als Pixelshader bezeichnet, wird pro Pixel auf der Bildschirmausgabe ausgeführt, während der Vertexshader nur pro Scheitelpunkt aller auf dem Bildschirm gezeichneten Netzen ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="90b02-286">The fragment shader, also known as the pixel shader, is executed per pixel on the screen output while the vertex shader is only executed per-vertex of all meshes being drawn to the screen.</span></span> 

<span data-ttu-id="90b02-287">Daher weisen nicht nur fragmentshader aufgrund der Beleuchtungsberechnungen mehr Anweisungen als Vertex-Shader auf. fragmentshader werden fast immer auf einem größeren Dataset ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="90b02-287">Thus, not only do fragment shaders have more instructions than vertex shaders because of all the lighting calculations, fragment shaders are almost always executed on a larger dataset.</span></span> <span data-ttu-id="90b02-288">Wenn die Bildschirmausgabe z. b. ein 2K-und 2K-Bild ist, kann der fragmentshader 2000 \* 2.000 = 4 Millionen Mal ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="90b02-288">For example, if the screen output is a 2k by 2k image, then the fragment shader can get executed 2,000\*2,000 = 4,000,000 times.</span></span> <span data-ttu-id="90b02-289">Wenn zwei Augen gerendert werden, verdoppelt sich diese Zahl, da zwei Bildschirme vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="90b02-289">If rendering two eyes, this number doubles since there are two screens.</span></span> <span data-ttu-id="90b02-290">Wenn eine gemischte Reality-Anwendung über mehrere Durchgänge, voll Bild Vorgänge nach der Verarbeitung oder das Rendern mehrerer Netze auf das gleiche Pixel verfügt, erhöht sich diese Anzahl erheblich.</span><span class="sxs-lookup"><span data-stu-id="90b02-290">If a mixed reality application has multiple passes, full-screen post-processing effects, or rendering multiple meshes to the same pixel, this number will increase dramatically.</span></span> 

<span data-ttu-id="90b02-291">Daher kann das Reduzieren der Anzahl von Vorgängen im fragmentshader im allgemeinen weitaus größere Leistungssteigerungen gegenüber Optimierungen im Vertexshader bieten.</span><span class="sxs-lookup"><span data-stu-id="90b02-291">Therefore, reducing the number of operations in the fragment shader can generally give far greater performance gains over optimizations in the vertex shader.</span></span>

#### <a name="unity-standard-shader-alternatives"></a><span data-ttu-id="90b02-292">Unity-Standard-Shader-Alternativen</span><span class="sxs-lookup"><span data-stu-id="90b02-292">Unity Standard shader alternatives</span></span>

<span data-ttu-id="90b02-293">Anstatt ein physisch basiertes Rendering (PBR) oder einen anderen hochwertigen Shader zu verwenden, sollten Sie einen leistungsfähigsten und kostengünstigeren Shader nutzen.</span><span class="sxs-lookup"><span data-stu-id="90b02-293">Instead of using a physically based rendering (PBR) or other high-quality shader, look at utilizing a more performant and cheaper shader.</span></span> <span data-ttu-id="90b02-294">Das [Mixed Reality Toolkit](https://github.com/Microsoft/MixedRealityToolkit-Unity) stellt den [mrtk-Standard-Shader](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) bereit, der für Projekte mit gemischter Realität optimiert wurde.</span><span class="sxs-lookup"><span data-stu-id="90b02-294">The [Mixed Reality Toolkit](https://github.com/Microsoft/MixedRealityToolkit-Unity) provides the [MRTK standard shader](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html) that has been optimized for mixed reality projects.</span></span>

<span data-ttu-id="90b02-295">Unity bietet auch eine nicht beleuchtete, vertexlit, diffuse und andere vereinfachte Shader-Optionen, die im Vergleich zum Unity-Standard-Shader erheblich schneller sind.</span><span class="sxs-lookup"><span data-stu-id="90b02-295">Unity also provides an unlit, vertex lit, diffuse, and other simplified shader options that are significantly faster compared to the Unity Standard shader.</span></span> <span data-ttu-id="90b02-296">Ausführlichere Informationen finden Sie [unter Nutzung und Leistung integrierter Shader](https://docs.unity3d.com/Manual/shader-Performance.html) .</span><span class="sxs-lookup"><span data-stu-id="90b02-296">See [Usage and Performance of Built-in Shaders](https://docs.unity3d.com/Manual/shader-Performance.html) for more detailed information.</span></span>

#### <a name="shader-preloading"></a><span data-ttu-id="90b02-297">Shader-vorab laden</span><span class="sxs-lookup"><span data-stu-id="90b02-297">Shader preloading</span></span>

<span data-ttu-id="90b02-298">Verwenden Sie das *Vorladen von Shader* und andere Tricks, um die [Shader-Ladezeit](https://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html)zu optimieren.</span><span class="sxs-lookup"><span data-stu-id="90b02-298">Use *Shader preloading* and other tricks to optimize [shader load time](https://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html).</span></span> <span data-ttu-id="90b02-299">Das Vorladen von Shader bedeutet insbesondere, dass Sie aufgrund der Laufzeit-Shader-Kompilierung keine Treffer anzeigen können.</span><span class="sxs-lookup"><span data-stu-id="90b02-299">In particular, shader preloading means you won't see any hitches due to runtime shader compilation.</span></span>

### <a name="limit-overdraw"></a><span data-ttu-id="90b02-300">Limit überzeichnen</span><span class="sxs-lookup"><span data-stu-id="90b02-300">Limit overdraw</span></span>

<span data-ttu-id="90b02-301">In Unity kann eine Überzeichnung für Ihre Szene angezeigt werden, indem Sie das [**Zeichnungsmodus-Menü**](https://docs.unity3d.com/Manual/ViewModes.html) in der oberen linken Ecke der **Szene Ansicht** umschalten und **überzeichnen**auswählen.</span><span class="sxs-lookup"><span data-stu-id="90b02-301">In Unity, one can display overdraw for their scene, by toggling the [**draw mode menu**](https://docs.unity3d.com/Manual/ViewModes.html) in the top left corner of the **Scene view** and selecting **Overdraw**.</span></span>

<span data-ttu-id="90b02-302">Im Allgemeinen kann die Überschreibung durch die Erstellung von Objekten vor dem Senden an die GPU verringert werden.</span><span class="sxs-lookup"><span data-stu-id="90b02-302">Generally, overdraw can be mitigated by culling objects ahead of time before they are sent to the GPU.</span></span> <span data-ttu-id="90b02-303">Unity bietet ausführliche Informationen zum Implementieren von [Okklusions Berechnungen](https://docs.unity3d.com/Manual/OcclusionCulling.html) für die Engine.</span><span class="sxs-lookup"><span data-stu-id="90b02-303">Unity provides details on implementing [Occlusion Culling](https://docs.unity3d.com/Manual/OcclusionCulling.html) for their engine.</span></span>

## <a name="memory-recommendations"></a><span data-ttu-id="90b02-304">Speicher Empfehlungen</span><span class="sxs-lookup"><span data-stu-id="90b02-304">Memory recommendations</span></span>

<span data-ttu-id="90b02-305">Eine übermäßige Speicher Belegung & Zuordnungs Vorgängen kann negative Auswirkungen auf Ihre Holographic-Anwendung haben, was zu inkonsistenter Leistung, fixierten Frames und anderem schädlichen Verhalten führt.</span><span class="sxs-lookup"><span data-stu-id="90b02-305">Excessive memory allocation & deallocation operations can have adverse effects on your holographic application resulting in inconsistent performance, frozen frames, and other detrimental behavior.</span></span> <span data-ttu-id="90b02-306">Es ist besonders wichtig, die Arbeitsspeicher Aspekte zu verstehen, wenn Sie in Unity entwickeln, da die Speicherverwaltung durch die Garbage Collector gesteuert wird.</span><span class="sxs-lookup"><span data-stu-id="90b02-306">It is especially important to understand memory considerations when developing in Unity since memory management is controlled by the garbage collector.</span></span>

#### <a name="garbage-collection"></a><span data-ttu-id="90b02-307">Garbage Collection</span><span class="sxs-lookup"><span data-stu-id="90b02-307">Garbage collection</span></span>

<span data-ttu-id="90b02-308">Holographic apps verlieren die Verarbeitung der COMPUTE-Zeit auf die Garbage Collector (GC), wenn die GC aktiviert ist, um Objekte zu analysieren, die während der Ausführung nicht mehr im Gültigkeitsbereich sind, und der Arbeitsspeicher freigegeben werden muss, damit Sie wieder verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="90b02-308">Holographic apps will loose processing compute time to the garbage collector (GC) when the GC is activated to analyze objects that are no longer in scope during execution and their memory needs to be released so it can be made available for re-use.</span></span> <span data-ttu-id="90b02-309">Konstante Zuordnungen und Zuordnungen erfordern im Allgemeinen, dass die Garbage Collector häufiger ausgeführt werden, wodurch Leistung und Benutzer Leistung beeinträchtigt werden.</span><span class="sxs-lookup"><span data-stu-id="90b02-309">Constant allocations and de-allocations will generally require the garbage collector to run more frequently thus hurting performance and user experience.</span></span>

<span data-ttu-id="90b02-310">Unity hat eine hervorragende Seite bereitgestellt, auf der ausführlich erläutert wird, wie die Garbage Collector funktioniert und wie Sie in Bezug auf die Speicherverwaltung effizienterer Code schreiben können.</span><span class="sxs-lookup"><span data-stu-id="90b02-310">Unity has provided an excellent page that explains in detail how the garbage collector works and tips to write more efficient code in regards to memory management.</span></span>
- [<span data-ttu-id="90b02-311">Optimieren von Garbage Collection in Unity-spielen</span><span class="sxs-lookup"><span data-stu-id="90b02-311">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)

<span data-ttu-id="90b02-312">Eine der gängigsten Methoden, die zu einer übermäßigen Garbage Collection führt, besteht darin, keine Verweise auf Komponenten und Klassen in der Unity-Entwicklung zwischenzuspeichern.</span><span class="sxs-lookup"><span data-stu-id="90b02-312">One of the most common practices that leads to excessive garbage collection is not caching references to components and classes in Unity development.</span></span> <span data-ttu-id="90b02-313">Alle Verweise sollten während des Starts () oder in "Awake ()" aufgezeichnet und in späteren Funktionen wie "Update ()" oder "lateupdate ()" wieder verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="90b02-313">Any references should be captured during Start() or Awake() and re-used in later functions such as Update() or LateUpdate().</span></span>

<span data-ttu-id="90b02-314">Weitere Quick Infos:</span><span class="sxs-lookup"><span data-stu-id="90b02-314">Other quick tips:</span></span>
- <span data-ttu-id="90b02-315">Verwenden der [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2) C# -Klasse zum dynamischen Erstellen komplexer Zeichen folgen zur Laufzeit</span><span class="sxs-lookup"><span data-stu-id="90b02-315">Use the [StringBuilder](https://docs.microsoft.com/dotnet/api/system.text.stringbuilder?view=netframework-4.7.2) C# class to dynamically build complex strings at runtime</span></span>
- <span data-ttu-id="90b02-316">Entfernen Sie Aufrufe von Debug. log (), wenn Sie nicht mehr benötigt werden, da Sie immer noch in allen Buildversionen einer app ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="90b02-316">Remove calls to Debug.Log() when no longer needed as they still execute in all build versions of an app</span></span>
- <span data-ttu-id="90b02-317">Wenn Ihre Holographic-app in der Regel viel Speicher erfordert, sollten Sie beim Laden von Phasen (z. b. beim Anzeigen eines Lade-oder Übergangs Bildschirms [ _**) System. GC. Collect () aufrufen.**_ ](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2)</span><span class="sxs-lookup"><span data-stu-id="90b02-317">If your holographic app generally requires lots of memory, consider calling  [_**System.GC.Collect()**_](https://docs.microsoft.com/dotnet/api/system.gc.collect?view=netframework-4.7.2) during loading phases such as when presenting a loading or transition screen</span></span>

#### <a name="object-pooling"></a><span data-ttu-id="90b02-318">Objekt Pooling</span><span class="sxs-lookup"><span data-stu-id="90b02-318">Object pooling</span></span>

<span data-ttu-id="90b02-319">Objekt Pooling ist eine gängige Methode, um die Kosten für fortlaufende Zuordnungen & die Zuordnung von Objekten zu reduzieren.</span><span class="sxs-lookup"><span data-stu-id="90b02-319">Object pooling is a popular technique to reduce the cost of continuous allocations & deallocations of objects.</span></span> <span data-ttu-id="90b02-320">Dies erfolgt durch Zuordnen eines großen Pools identischer Objekte und erneutes verwenden inaktiver, verfügbarer Instanzen aus diesem Pool, anstatt ständig Objekte im Zeitverlauf zu erzeugen und zu zerstören.</span><span class="sxs-lookup"><span data-stu-id="90b02-320">This is done by allocating a large pool of identical objects and re-using inactive, available instances from this pool instead of constantly spawning and destroying objects over time.</span></span> <span data-ttu-id="90b02-321">Objekt Pools eignen sich hervorragend für wiederverwendbare Komponenten, die während einer APP über eine Variablen Lebensdauer verfügen.</span><span class="sxs-lookup"><span data-stu-id="90b02-321">Object pools are great for re-useable components that have variable lifetime during an app.</span></span>

- [<span data-ttu-id="90b02-322">Tutorial zum Objektpooling in Unity</span><span class="sxs-lookup"><span data-stu-id="90b02-322">Object Pooling Tutorial in Unity</span></span>](https://unity3d.com/learn/tutorials/topics/scripting/object-pooling) 

## <a name="startup-performance"></a><span data-ttu-id="90b02-323">Startleistung</span><span class="sxs-lookup"><span data-stu-id="90b02-323">Startup performance</span></span>

<span data-ttu-id="90b02-324">Sie sollten die app in einer kleineren Szene starten und dann *[scenemanager. loadsceneasync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* verwenden, um den Rest der Szene zu laden.</span><span class="sxs-lookup"><span data-stu-id="90b02-324">You should consider starting your app with a smaller scene, then using *[SceneManager.LoadSceneAsync](https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html)* to load the rest of the scene.</span></span> <span data-ttu-id="90b02-325">Dadurch kann Ihre APP so schnell wie möglich einen interaktiven Zustand erreichen.</span><span class="sxs-lookup"><span data-stu-id="90b02-325">This allows your app to get to an interactive state as fast as possible.</span></span> <span data-ttu-id="90b02-326">Beachten Sie, dass es möglicherweise zu einer großen CPU-Spitze kommt, während die neue Szene aktiviert wird, und dass sich jeder gerenderte Inhalt möglicherweise in den Ruhezustand versetzt.</span><span class="sxs-lookup"><span data-stu-id="90b02-326">Be aware that there may be a large CPU spike while the new scene is being activated and that any rendered content might stutter or hitch.</span></span> <span data-ttu-id="90b02-327">Eine Möglichkeit, dieses Problem zu umgehen, besteht darin, die AsyncOperation. allowsceneactivation-Eigenschaft in der zu ladenden Szene auf "false" festzulegen, die Szene zu laden, den Bildschirm in schwarz zu löschen und dann auf "true" festzulegen, um die Szenen Aktivierung abzuschließen.</span><span class="sxs-lookup"><span data-stu-id="90b02-327">One way to work around this is to set the AsyncOperation.allowSceneActivation property to false on the scene being loaded, wait for the scene to load, clear the screen to black, and then set back to true to complete the scene activation.</span></span>

<span data-ttu-id="90b02-328">Beachten Sie, dass beim Laden der Startszene der Holographic-Begrüßungsbildschirm für den Benutzer angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="90b02-328">Remember that while the startup scene is loading the holographic splash screen will be displayed to the user.</span></span>

## <a name="see-also"></a><span data-ttu-id="90b02-329">Weitere Informationen:</span><span class="sxs-lookup"><span data-stu-id="90b02-329">See also</span></span>
- [<span data-ttu-id="90b02-330">Optimieren des Grafik Rendering in Unity-spielen</span><span class="sxs-lookup"><span data-stu-id="90b02-330">Optimizing graphics rendering in Unity games</span></span>](https://unity3d.com/learn/tutorials/temas/performance-optimization/optimizing-graphics-rendering-unity-games?playlist=44069)
- [<span data-ttu-id="90b02-331">Optimieren von Garbage Collection in Unity-spielen</span><span class="sxs-lookup"><span data-stu-id="90b02-331">Optimizing garbage collection in Unity games</span></span>](https://unity3d.com/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069)
- <span data-ttu-id="90b02-332">[Bewährte Methoden für die Physik [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span><span class="sxs-lookup"><span data-stu-id="90b02-332">[Physics Best Practices [Unity]](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)</span></span>
- <span data-ttu-id="90b02-333">[Optimieren von Skripts [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span><span class="sxs-lookup"><span data-stu-id="90b02-333">[Optimizing Scripts [Unity]](https://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)</span></span>
